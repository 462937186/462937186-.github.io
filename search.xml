<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[发布订阅模式的思考]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fvue%E3%80%81react%2F%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%2F</url>
    <content type="text"><![CDATA[emit和on这一点有点像vuex和redux里面的某部分概念，也跟$emit和$on和node自带的event模块作用很相像，其实可以这样理解，如果单独用对象把数据存起来，数据改变的时候没有人会追踪到，所以这里在每次改变数据前都放入一个或多个回调函数形成队列去监听on方法，这些回调函数在队列中等待，直到触发了某些机制，这些函数才按顺序逐一回来触发emit方法，从而可以在这个时刻监听到新的数据变化并完成逻辑 123456789101112131415161718192021222324252627282930313233343536373839let weux = &#123;&#125;;// 这次换成一个对象类型的缓存列表weux.list = &#123;&#125;;weux.on = function (key, fn) &#123; // 如果对象中没有对应的key值 // 也就是说明没有订阅过 // 那就给key创建个缓存列表 if (!this.list[key]) &#123; this.list[key] = []; &#125; // 把函数添加到对应key的缓存列表里 this.list[key].push(fn);&#125;;weux.emit = function (key, param) &#123; // 或者let key = [].shift.call(arguments); // 或者let fns = this.list[key]; // 根据获取改函数数组队列 let fns = this.list[key]; // 如果缓存列表里没有函数就返回false if (!fns || fns.length === 0) &#123; return false; &#125; // 遍历key值对应的缓存列表 // 依次执行函数的方法 fns.forEach(fn =&gt; &#123; // 传入参数 fn(param); // 或者 fn.apply(this, arguments); &#125;);&#125;;// 测试用例weux.on(&apos;test&apos;, (param) =&gt; &#123; console.log(&apos;位置:&apos; + param.position); console.log(&apos;技能:&apos; + param.skill);&#125;);weux.emit(&apos;test&apos;, &#123; position: &apos;前端&apos;, skill: [&apos;ps&apos;, &apos;css&apos;, &apos;js&apos;]&#125;); 简单的队列可以没有仓库存放中介值，也可以$emit和$on的健值对，只有一个简单的队列，按放入的顺序，然后按顺序重新执行出来 123456789101112131415161718192021222324252627282930313233343536373839class Subject &#123; constructor() &#123; this.observers = [] &#125; addObserver(observer) &#123; this.observers.push(observer) &#125; removeObserver(observer) &#123; var index = this.observers.indexOf(observer) if (index &gt; -1) &#123; this.observers.splice(index, 1) &#125; &#125; notify() &#123; this.observers.forEach(observer =&gt; &#123; observer.update() &#125;) &#125;&#125;let subject = new Subject()class Observer &#123; constructor(vm, key, callback) &#123; this.vm = vm // mvvm 对象 this.key = key // data 的属性 this.callback = callback //callback &#125; // 更新值 update() &#123; console.log(&quot;update&quot;) this.callback() &#125;&#125;subject.addObserver(new Observer(document.body, &#123; name: &quot;wscats&quot;&#125;, () =&gt; &#123; console.log(&quot;回调函数&quot;)&#125;))console.log(subject)subject.notify(); 在上面的基础上添加健值对，可以改写成下面这样，这样写可以应付大部分发布订阅模式的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Subject &#123; constructor() &#123; this.observers = [] &#125; addObserver(key, observer) &#123; var index = this.observers.indexOf(observer) if (!this.observers[key]) &#123; // 没有创建新的队列 this.observers[key] = [] &#125; this.observers[key].push(observer) &#125; removeObserver(observer) &#123; var index = this.observers.indexOf(observer) if (index &gt; -1) &#123; this.observers.splice(index, 1) &#125; &#125; // 这里其实不但可以放key，还可以再增加一个参数传进观察者里面，在触发的时候，使用该函数 notify(key) &#123; this.observers[key].forEach(observer =&gt; &#123; observer.update() &#125;) &#125;&#125;let subject = new Subject()// 可以添加观察者，并在里面存着数据和方法，并保留着一个update方法给notify时候触发class Observer &#123; constructor(vm, key, callback) &#123; this.vm = vm // mvvm 对象 this.key = key // data 的属性 this.callback = callback //callback &#125; // 更新值 update() &#123; console.log(&quot;update&quot;) this.callback() &#125;&#125;subject.addObserver(&quot;test1&quot;, new Observer(document.body, &#123; name: &quot;wscats&quot;&#125;, () =&gt; &#123; console.log(&quot;回调函数1&quot;)&#125;))subject.addObserver(&quot;test2&quot;, new Observer(document.body, &#123; name: &quot;wscats&quot;&#125;, () =&gt; &#123; console.log(&quot;回调函数2&quot;)&#125;))subject.notify(&quot;test1&quot;);subject.notify(&quot;test2&quot;);console.log(subject) 类似vuex和redux继续往下改造，可以改成类似vuex的模式，在仓库中留着一份共享的数据，然后利用on缓存回调函数事件放入队列里面，然后利用emit在合适的时候释放该队列 1234567891011121314151617181920212223242526272829303132333435363738let wuex = &#123; store: &#123; position: &apos;温哥华&apos;, skill: [&apos;jsx&apos;, &apos;ts&apos;] &#125;, list: &#123;&#125;, on: function (key, fn) &#123; // 如果有则继续加队列 if (!this.list[key]) &#123; // 没有创建新的队列 this.list[key] = []; &#125; this.list[key].push(fn); &#125;, emit: function (key, param) &#123; let fns = this.list[key]; // 遍历更改仓库的值 for (p in param) &#123; this.store[p] = param[p] &#125; // 触发数组中的回调函数 fns.forEach(fn =&gt; &#123; fn(param); &#125;); &#125;&#125;;wuex.on(&apos;test&apos;, (param) =&gt; &#123; console.log(&apos;位置:&apos; + param.position); console.log(&apos;技能:&apos; + param.skill);&#125;);wuex.on(&apos;test&apos;, (param) =&gt; &#123; console.log(&apos;位置:&apos; + param.position); console.log(&apos;技能:&apos; + param.skill);&#125;);wuex.emit(&apos;test&apos;, &#123; position: &quot;香港&quot;, skill: [&apos;ps&apos;, &apos;css&apos;, &apos;js&apos;]&#125;); 组件通信发布订阅模式可以用在，两个组件之间的通信 实现双向数据绑定配合Object.defineProperty实现类似Vue的双向数据绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106let store = &#123; list: &#123;&#125;, on: function (key, fn) &#123; // 如果有则继续加队列 if (!this.list[key]) &#123; // 没有创建新的队列 this.list[key] = []; &#125; this.list[key].push(fn); &#125;, emit: function (key, param) &#123; let fns = this.list[key]; fns.forEach(fn =&gt; &#123; fn(param); &#125;); &#125;&#125;;class Vue &#123; constructor(options = &#123;&#125;) &#123; this.$el = document.querySelector(options.el); let data = this.data = options.data; Object.keys(data).forEach((key) =&gt; &#123; this.proxyData(key); &#125;); this.watcherTask = &#123;&#125;; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom &#125; // 把data挂到Vue实例化后的vm对象里面，vm.data.name获取或者改变，则触发get或者set proxyData(key) &#123; let that = this; Object.defineProperty(that, key, &#123; configurable: false, enumerable: true, get() &#123; return that.data[key]; &#125;, set(newVal) &#123; console.log(newVal) that.data[key] = newVal; &#125; &#125;); &#125; observer(data) &#123; let that = this Object.keys(data).forEach(key =&gt; &#123; let value = data[key] this.watcherTask[key] = [] Object.defineProperty(data, key, &#123; configurable: false, enumerable: true, get() &#123; return value &#125;, set(newValue) &#123; console.log(key) if (newValue !== value) &#123; value = newValue // 发布 // 更改vm的数据的时候触发set，然后会触发compileText的订阅store.on监听事件 store.emit(key, &#123;&#125;) &#125; &#125; &#125;) &#125;) &#125; compile(el) &#123; var nodes = el.childNodes; for (let i = 0; i &lt; nodes.length; i++) &#123; const node = nodes[i]; if (node.nodeType === 3) &#123; var text = node.textContent.trim(); //移除字串前後的空白字元以及行結束字元。 if (!text) continue; this.compileText(node, &apos;textContent&apos;) &#125; &#125; &#125; compileText(node, type) &#123; var self = this; // 匹配出该节点下的&#123;&#123;&#125;&#125;这种写法 let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g, txt = node.textContent; if (reg.test(txt)) &#123; node.textContent = txt.replace(reg, (matched, value) =&gt; &#123; // matched &#123;&#123;name&#125;&#125; // value name // 订阅 store.on(value, () =&gt; &#123; //node, this, value, type node[type] = self.data[value] &#125;); return this[value] &#125;) &#125; &#125;&#125;var vm = new Vue(&#123; el: &quot;#demo&quot;, data: &#123; skill: &quot;ps&quot; &#125;&#125;) ES6的写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class Subject &#123; constructor() &#123; this.observers = [] &#125; addObserver(key, observer) &#123; var index = this.observers.indexOf(observer) if (!this.observers[key]) &#123; // 没有创建新的队列 this.observers[key] = [] &#125; this.observers[key].push(observer) &#125; removeObserver(observer) &#123; var index = this.observers.indexOf(observer) if (index &gt; -1) &#123; this.observers.splice(index, 1) &#125; &#125; // 这里其实不但可以放key，还可以再增加一个参数传进观察者里面，在触发的时候，使用该函数 notify(key) &#123; this.observers[key].forEach(observer =&gt; &#123; observer.update() &#125;) &#125;&#125;// 可以添加观察者，并在里面存着数据和方法，并保留着一个update方法给notify时候触发class Observer &#123; constructor(node, vm, value, type, callback) &#123; this.node = node // node节点 this.vm = vm // mvvm 对象 this.value = value // data 的属性 this.type = type // node类型 this.callback = callback //callback &#125; // 更新值 update() &#123; console.log(&quot;update&quot;) this.callback() &#125;&#125;class Vue &#123; constructor(options = &#123;&#125;) &#123; this.$el = document.querySelector(options.el); let data = this.data = options.data; Object.keys(data).forEach((key) =&gt; &#123; this.proxyData(key); &#125;); this.subject = new Subject(); // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom &#125; // 把data挂到Vue实例化后的vm对象里面，vm.data.name获取或者改变，则触发get或者set proxyData(key) &#123; let that = this; Object.defineProperty(that, key, &#123; configurable: false, enumerable: true, get() &#123; return that.data[key]; &#125;, set(newVal) &#123; console.log(newVal) that.data[key] = newVal; &#125; &#125;); &#125; observer(data) &#123; let that = this Object.keys(data).forEach(key =&gt; &#123; let value = data[key] this.subject.observers[key] = [] Object.defineProperty(data, key, &#123; configurable: false, enumerable: true, get() &#123; return value &#125;, set(newValue) &#123; console.log(key) if (newValue !== value) &#123; value = newValue // 发布 // 更改vm的数据的时候触发set，然后会触发compileText的订阅store.on监听事件 that.subject.notify(key) &#125; &#125; &#125;) &#125;) &#125; compile(el) &#123; var nodes = el.childNodes; for (let i = 0; i &lt; nodes.length; i++) &#123; const node = nodes[i]; if (node.nodeType === 3) &#123; var text = node.textContent.trim(); //移除字串前後的空白字元以及行結束字元。 if (!text) continue; this.compileText(node, &apos;textContent&apos;) &#125; &#125; &#125; compileText(node, type) &#123; var self = this; // 匹配出该节点下的&#123;&#123;&#125;&#125;这种写法 let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g, txt = node.textContent; if (reg.test(txt)) &#123; node.textContent = txt.replace(reg, (matched, value) =&gt; &#123; // matched &#123;&#123;name&#125;&#125; // value name // 订阅 this.subject.addObserver(value, new Observer( node, this, value, type, () =&gt; &#123; node[type] = self.data[value] &#125;)) return this[value] &#125;) &#125; &#125;&#125;var vm = new Vue(&#123; el: &quot;#demo&quot;, data: &#123; skill: &quot;ps&quot; &#125;,&#125;)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue脚手架--vue-cli]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fvue%E3%80%81react%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、vue脚手架安装步骤https://cli.vuejs.org/ 1.全局安装1npm install -g @vue/cli 2.安装完，会在全局有vue命令1vue -V 3.创建项目1vue create weibo 4.定位到该文件夹1cd weibo 5.启动服务器1npm run serve 利用路由传递参数 12this.$route.push(&#123;path:&apos;/xxx&apos;,query:&#123;id:1&#125;&#125;);//类似get传参，通过URL传递参数this.$route.push(&#123;path:&apos;/xxx&apos;,params:&#123;id:1&#125;&#125;);//类似post传参 接收参数 12this.$route.query.idthis.$route.params.id 利用emit发送数据 1this.$emit(&apos;showCityName&apos;,data); 利用on接收数据 12345this.$on(&apos;increment&apos;,function(msg)&#123; //获取$emit方法传递的第二个参数 console.log(msg); alert(&quot;1&quot;); &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基本语法]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fvue%E3%80%81react%2Fvue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vue1. 直接在html引入vue.js12&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js&quot;&gt;&lt;/script&gt;//中间的网址即为下载地址 2.jquery与vue的异同 jquery.js提供$或者jquery全局变量 vue.js提供vue全局变量 Vue的核心库只关注视图层，读音view 双向数据绑定，data里数据改变视图也改变 如果页面注重操作节点，用jquery 如果页面数据比较多，建议用vue 二、开发工具1.用git下载谷歌浏览器工具，然后方便我们开发vue项目1git clone https://github.com/vuejs/vue-devtools.git 此时你会看到文件中多了一个vue-devtools文件 进入到这个文件npm install，安装依赖包； 安装成功之后npm run build 若不执行以上命令会报错，无法加载背景脚本”build/background.js” //…… 打开shells&gt;chrome&gt;manifest.json并把json文件里的”persistent”:false改成true //…….. 打开chrome浏览器，打开更多工具&gt;扩展程序； 再点击加载已解压的扩展程序，然后把shells&gt;chrome文件夹放入 三、helloworld1.先实例化Vue,里面允许我们放很多选项(https://cn.vuejs.org/v2/api/),可以放**数据，DOM，生命钩子，资源和组合**123var vm = new Vue(&#123; // 选项&#125;) 2.你用jQ，第一要有数据，第二要有节点，没节点，数据没意义123$.ajax()//$(el).html(data)//寻找节点，然后放数据 3.放入必要的选项，el和data是必须要有的1el就是寻找节点（找作用域），data就是配合`&#123;&#123;&#125;&#125;`来渲染数据 1234567var vm = new Vue(&#123; // 选项 data:&#123; name:"lemon1" &#125;, el:"#demo"&#125;) 4.在view层的id为demo的作用域里面配合双括号绑定数据123&lt;div id=&quot;demo&quot;&gt; &lt;p&gt;&#123;&#123;num+1+&apos;1&apos;&#125;&#125;&lt;/p&gt;&lt;/div&gt; 四、jQuery和Vue的表达式和指令1.文本值123456jq写法$().text();vue写法&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;p v-text=&quot;name&quot;&gt;&lt;/p&gt; 2.属性值 :style和:class是必须接受一个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; .red&#123; color:red &#125; .bg&#123; background-color:yellow &#125; .size&#123; font-size:28px &#125; &lt;/style&gt; &lt;div id=&quot;demo&quot;&gt; &lt;p :name=&quot;name&quot; :id=&quot;name+&apos;&amp;laoxie&apos;&quot;&gt;属性&lt;/p&gt; &lt;p :style=&quot;style1&quot;&gt;样式1&lt;/p&gt; =========================================== &lt;p :style=&quot;&#123; color:&apos;red&apos;, fontSize:&apos;14px&apos;, backgroundColor:&apos;yellow&apos; &#125;&quot;&gt;样式2&lt;/p&gt; &lt;p :class=&quot;class1&quot;&gt;样式1&lt;/p&gt; &lt;/div&gt; ===================================================== &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;var vm = new Vue(&#123; // 选项 // 数据选项 data:&#123; name:&quot;lemon&quot;, style1:&#123; color:&apos;red&apos;, fontSize:&apos;14px&apos;, backgroundColor:&apos;yellow&apos; &#125;, class1:&#123; red:true, bg:false, size:true &#125; &#125;, el:&quot;#demo&quot; &#125;) 解释：就是你要是写style样式，或者是要以类名的方式添加样式，就要在下面写成对象的方式，然后再给上面添加变量即可 :xxx都可以接受任何变量 1234567jq写法$().attr();$().css();$().addClass();vue写法&lt;p :name=&quot;name&quot;&gt;&lt;/p&gt; 插入html结构 123$().html()&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; 显示或者隐藏，本质是控制css，节点一直存在的，频繁切换（选项卡，加载的动画） 123456jq写法$().show()$().hide()vue写法&lt;div v-show=&quot;!bool&quot;&gt;你好&lt;/div&gt; 对节点增加或者删除，节点要不存在或者不存在 1234567jq写法$().append()$().remove()vue写法&lt;div v-if=&quot;!bool&quot;&gt;你好&lt;/div&gt;&lt;div v-else&gt;假的&lt;/div&gt; v-for放哪里，那个节点就跟着遍历对应的数组,支持嵌套其他指令v-for,v-if和v-show 123456789jq写法$().each()vue写法&lt;div v-for="item in arr" v-text="item.name"&gt;&lt;/div&gt;备注：v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。v-for 可以绑定数据到数组来渲染一个列表 v-on:click简写为@click，就是把原生的onmousedown-&gt;@mousedown，把on改为@，把事件监听函数方法选项的methods里面 123456jq写法$().on()$().click()vue写法&lt;button @click="loadMore"&gt;查看更多&lt;/button&gt; v-bind:xxx简写为:xxx 1234&lt;p v-bind:name="name"&gt;测试&lt;/p&gt;==============================&lt;p :name="name"&gt;测试&lt;/p&gt;备注：两种写法为一个意思 v-model是把视图的值，带回选项data里面，只能用在这三个标签里面 视图层影响数据层v-model或者v-on:click 12345&lt;input v-model=&quot;name&quot; /&gt;&lt;select&gt;&lt;textarea&gt;备注：v-model链接data中定义的数据 五、data、methods、双括号 data用于定义属性 12345678例如：data:&#123; name:&quot;lemon&quot;, style1:&#123; color:&apos;red&apos;, fontSize:&apos;14px&apos;, backgroundColor:&apos;yellow&apos;&#125;, methods 用于定义的函数，可以通过 return 来返回函数值。 123456789101112131415methods: &#123; testClick: function () &#123; console.log(&quot;你触发了点击事件&quot;) &#125;, testKeyup() &#123; console.log(&quot;你触发了输入事件&quot;) &#125;, loadMore() &#123; this.arr.push(&#123; name: &apos;laotian&apos;, age: 16, skill: [&apos;xmind&apos;] &#125;) &#125;&#125; 双括号 用于输出对象属性和函数返回值。 12345&lt;div id=&quot;demo&quot;&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;arr&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;arr[0]&#125;&#125;&lt;/p&gt; &lt;/div&gt; 六、模板语法 使用v-html指令用于输出html代码 1234567891011121314&lt;div id=&quot;demo&quot;&gt; &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &quot;#demo&quot;, data: &#123; html: &quot;&lt;p&gt;123&lt;span&gt;456&lt;/span&gt;789&lt;/p&gt;&quot; &#125; &#125;) &lt;/script&gt;备注：v-html一般用于输出HTML结构]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react脚手架及语法]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fvue%E3%80%81react%2Freact%E8%84%9A%E6%89%8B%E6%9E%B6%E5%8F%8A%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、react脚手架安装步骤1234$ cnpm install -g create-react-app //全局安装react$ create-react-app my-app //创建脚手架$ cd my-app/ $ npm start 二、react添加取消类名方式1. 添加取消类名 思路：现在上面定义一个变量，例如：isShowSearchBar:true，然后给你要点击的那个东西添加onClick={}事件，然后根据变量的true和false来决定添加取消类名， 1234567891011121314151617181920212223 className=&#123;this.state.isShowSearchBar? &quot;weui-search-bar&quot;: &quot;weui-search-bar weui-search-bar_focusing&quot;&#125;============定义变量阶段================ constructor(props)&#123; super(props); this.state = &#123; isShowSearchBar:true &#125; &#125; =============改变变量阶段================changeSearchBar()&#123; this.setState(&#123; isShowSearchBar:!this.state.isShowSearchBar &#125;) &#125; ==================绑定事件阶段==========&lt;a href=&quot;javascript:&quot; onClick=&#123;this.changeSearchBar.bind(this)&#125; className=&quot;weui-search-bar__cancel-btn&quot; id=&quot;searchCancel&quot;&gt;取消&lt;/a&gt;======================================================== 2. tab切换形式 思路：先定义一个变量为0，以索引的形式切换，把点击事件写给你要点击的东西，当你点击的时候，把索引传给函数，通过函数事件把index赋给你定义的变量，然后在下面根据你的变量等于索引的三元表达式形式，添加类名，例子如下： 12345678910111213141516171819202122232425262728293031323334353637class Xfooter extends Component &#123; constructor(props)&#123; super(props); this.state = &#123; tab:0, tabs:[&#123; title:&quot;微信&quot;, href:&quot;wechat&quot;, num:8, dot:false &#125;,&#123; title:&quot;通讯录&quot;, href:&quot;contact&quot;, num:0, dot:true &#125;,&#123; title:&quot;发现&quot;, href:&quot;research&quot;, num:0, dot:false &#125;,&#123; title:&quot;我&quot;, href:&quot;mine&quot;, num:0, dot:false &#125;] &#125; &#125;==================================================== toggloClass(index,e)&#123; this.setState(&#123; tab:index &#125;) &#125; =================================================== &lt;a href=&quot;javascript:;&quot; key=&#123;index&#125; onClick=&#123;this.toggloClass.bind(this,index)&#125; className=&#123;this.state.tab==index? &quot;weui-tabbar__item weui-bar__item_on&quot;: &quot;weui-tabbar__item&quot;&#125;&gt; 三、文本框聚焦 思路：先给你要聚焦的文本框绑定ref=“变量名”，然后在你的点击事件里面写，this.refs.变量名.focus();既可聚焦 12345==================this.refs.imput.focus();==========================================&lt;input ref=&quot;imput&quot; type=&quot;search&quot; className=&quot;weui-search-bar__input&quot; id=&quot;searchInput&quot; placeholder=&quot;搜索&quot; required=&quot;&quot; /&gt; 四、获取文本框的value方法 思路：先给文本框绑定onChange事件，记住要用大括号的形式{}，在上面的事件函数里面传个e，就直接获取e.target.value,然后再上面this.state里面定义一个变量，例如：searchValue:””,然后通过this.setState({})的方法把值赋给那个变量既可。 123456789101112131415161718==============定义阶段=============== constructor(props)&#123; super(props); this.state = &#123; isShowSearchBar:true, searchValue:&quot;&quot; &#125; &#125; ==========获取文本框值阶段======== getInputValue(e)&#123; this.setState(&#123; searchValue:e.target.value &#125;) console.log(e.target.value) &#125; 五、函数式编程1思路：能在虚拟dom里任意一地方放&#123;&#123;&#125;&#125;编写逻辑，会在虚拟Dom里渲染return的数据 1234567步骤：1.先在上面定义一个数组 2.然后在下面写一个自执行的函数，例如：&#123;(()=&gt;&#123; return this.state.tabs.map((item,index)=&gt;&#123; &#125;) &#125;)()&#125; 六、路由1. 路由的起步 下载路由模块 1npm install react-router-dom 在index.js引入 1import &#123; BrowserRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;; 在index.js外面包上&lt;Router&gt;&lt;/Router&gt; 12345678910ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Xheader /&gt; &lt;Xsearch /&gt; &lt;Xpannel /&gt; &lt;Xfooter /&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById(&apos;root&apos;)) 2. 路由的跳转实现及步骤 建议在index.js页面引入哈希路由 1import &#123; HashRouter as Router, Route &#125; from &apos;react-router-dom&apos; 在ReactDOM.render下面写上 1234567891011ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Route path=&quot;/home/&quot; component=&#123;Home&#125; /&gt; //判断路径如果是/home/就去home组件 &lt;Route path=&quot;/Detail/&quot; component=&#123;Detail&#125; /&gt; //判断路径如果detail就去detail组件 &#123;/* &lt;Redirect from=&quot;/home&quot; to=&quot;/home/wechat&quot; /&gt; */&#125; &lt;/div&gt; &lt;/Router&gt;, document.getElementById(&apos;root&apos;)) 然后在home页面引入路有插件和小组件 123456import &#123; Route &#125; from &apos;react-router-dom&apos;import Wechat from &apos;../Wechat/Wechat&apos;import Contact from &apos;../Contact/Contact&apos;import Research from &apos;../Research/Research&apos;import Mine from &apos;../Mine/Mine&apos; 根据路径判断调到那个路由 1234&lt;Route path=&quot;/home/wechat&quot; component=&#123;Wechat&#125; /&gt;&lt;Route path=&quot;/home/contact&quot; component=&#123;Contact&#125; /&gt;&lt;Route path=&quot;/home/research&quot; component=&#123;Research&#125; /&gt;&lt;Route path=&quot;/home/mine&quot; component=&#123;Mine&#125; /&gt; 去Xfooter页面引入路由组件 1import &#123; Link &#125; from &apos;react-router-dom&apos; 1把`a`标签改为`Link`，然后在里面写`to&#123;/home/$&#123;item.href&#125;&#125;` 123456&lt;Link to=&#123;`/home/$&#123;item.href&#125;`&#125;&gt;&lt;/Link&gt;解释：你的href要在上面就定义好，然后直接调用，例如：&#123;title:&quot;微信&quot;,href:&quot;wechat&quot;,num:8,dot:false&#125; 3. 设置默认路由 进入页面引入时加Redirect 1import &#123; HashRouter as Router, Route , Redirect ,Switch&#125; from &apos;react-router-dom&apos; 下面写默认路由 123456789101112131415ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;div className=&quot;container iphonex_padding&quot;&gt; &lt;Switch&gt; &lt;Route path=&quot;/home/&quot; component=&#123;Home&#125; /&gt; &lt;Redirect from=&quot;/&quot; exact to=&quot;/home/HomeIndex&quot; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); ====================== &lt;Link to=&#123; &#123;pathname:`/home/$&#123;item.href&#125;` &#125;&#125; replace &gt; &lt;/Link&gt; 七、redux组件通信12npm install --save react-reduxnpm install --save redux 在index.js引入 123//reduximport &#123;Provider, connect&#125; from &apos;react-redux&apos;;import &#123;createStore&#125; from &apos;redux&apos;; 创建仓库 123const store = createStore(function(state=&#123;&#125;,action)&#123;&#125;) 在下面用Provider包住 12345678910111213ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; //注入store &lt;Router&gt; &lt;div&gt; &lt;Route path=&quot;/home/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/Detail/&quot; component=&#123;Detail&#125; /&gt; &lt;Redirect from=&quot;/home&quot; to=&quot;/home/wechat&quot; /&gt; &lt;/div&gt; &lt;/Router&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)) 在你要用redux的仓库引入 1import &#123; connect&#125; from &apos;react-redux&apos;; 在最下面写 12345678910111213141516171819export default connect((state)=&gt;&#123; return state //把你从仓库拿到的东西return出来&#125;,(dispatch)=&gt;&#123; return &#123; toggleSheet() &#123; //把你改的东西return出去 dispatch(&#123; type: &apos;toggleSheet&apos;, isShowActionSheet: false &#125;) &#125; &#125;&#125;)(XactionSheet)================在结构里面写的================= &lt;div className=&quot;weui-skin_android&quot; onClick=&#123;this.props.toggleSheet&#125; id=&quot;androidActionsheet&quot; style=&#123;&#123; opacity: 1, display:this.props.isShowActionSheet ? &quot;block&quot;: &quot;none&quot; &#125;&#125;&gt; 在index.js里面接收回你改的东西 1234567891011121314const store = createStore(function(state=&#123; isShowActionSheet:false //初始化设置为false&#125;,action)&#123; switch (action.type) &#123; case &apos;toggleSheet&apos;: //如果类型为 ‘toggleSheet’ return &#123; ...state, //展开state isShowActionSheet:action.isShowActionSheet //设置为接收回来的状态 &#125; default: return state //默认返回state的东西 &#125;&#125;) 九、组件 里面包含html，css，js react是把所有的html，css都放进js文件里面 react定义组件，先创建xxx.js，在文件里面引入react模块 1import React, &#123; Component &#125; from 'react'; 所有组件继承于Component 1class 组件名字 extends Component &#123;&#125; 导出组件 1export default App; 12345678910使用redux时，记住一定要把东西在仓库就先return出来，要不然外边拿不到 switch (action.type) &#123; // case &apos;toggleSheet&apos;: // return &#123; // ...state, // isShowActionSheet:action.isShowActionSheet // &#125; default: return state &#125; 3. react路由设置、及重定向1234567891011路由冲定向时会报错，记得要引入 **import &#123; HashRouter as Router, Route , Redirect ,Switch&#125; from &apos;react-router-dom&apos;===========用switch包住你的路由判断那里&lt;Switch&gt; &lt;Route path=&quot;/home/&quot; component=&#123;Home&#125; /&gt; &lt;Redirect from=&quot;/&quot; exact to=&quot;/home/HomeIndex&quot; /&gt;&lt;/Switch&gt;===============在link里面要把普通的`to`改成`to=&#123; &#123;pathname:`/home/$&#123;item.href&#125;` &#125;&#125; replace` 4. redux修改仓库中数组的某一项、实现联动效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970如果你要是想通过点击事件触发仓库中的某一个值，是数组的情况下，你需要遍历仓库中的数组，把你要变得索引传过来，然后让其他的不变，例如：const store = createStore(function (state = &#123; navs: [&#123; title: &apos;推荐&apos;, href: &apos;recommend&apos;, isShow:true, recommend: [] &#125;, &#123; title: &apos;少儿&apos;, href: &apos;children&apos;, isShow:false, children: [] &#125;, &#123; title: &apos;成人&apos;, href: &apos;adult&apos;, isShow:false, adult: [] &#125;, &#123; title: &apos;父母&apos;, href: &apos;parents &apos;, isShow:false, parents: [] &#125;, &#123; title: &apos;家庭&apos;, href: &apos;family&apos;, isShow:false, family: [] &#125;, &#123; title: &apos;旅行&apos;, href: &apos;travel&apos;, isShow:false, travel: [] &#125;] &#125; ,action) &#123; switch (action.type) &#123; case &apos;isActive&apos;: var &#123;navs&#125; = state // 把仓库赋值给navs for(var i=0;i&lt;navs.length;i++)&#123; // 遍历navs仓库，找到你要的东西 navs[i].isShow=false navs[action.index].isShow =action.isShow console.log(navs[i]) &#125; navs.isShow = action.noShow return &#123; ...state, isShow:false &#125; default: return state &#125;&#125;)===============触发那边==============export default connect((state)=&gt;&#123; return state &#125; , (dispatch) =&gt; &#123; return &#123; isActive(index)&#123; console.log(this.props) this.setState(&#123; isActive:index //修改本地的内容 &#125;) dispatch(&#123; type:&quot;isActive&quot;, index: index, //传索引`index` isShow:true //传状态 &#125;) &#125; &#125;&#125;)(Xnav); 6. 路由嵌套问题 在哪个页面的二级路由，就写在哪个页面，例如：你要在首页写二级路由，你就把二级路由写在首页， 然后一级路由会基于你二级路由跳转的路径跳转，所以你要加个斜杠/在一级路由那里/${item.href} 123456789101112131415===================二级路由home写法=====================&lt;Route path=&apos;/home/Xrecommend&apos; component=&#123;Xrecommend&#125; /&gt;&lt;Route path=&quot;/home/Xchildren&quot; component=&#123;Xchildren&#125; /&gt;&lt;Route path=&quot;/home/Xadult&quot; component=&#123;Xadult&#125; /&gt;&lt;Route path=&quot;/home/Xparents&quot; component=&#123;Xparents&#125; /&gt;&lt;Route path=&quot;/home/Xfamily&quot; component=&#123;Xfamily&#125; /&gt;&lt;Route path=&quot;/home/Xtravel&quot; component=&#123;Xtravel&#125; /&gt;=============一级路由跳转============= &lt;Link to=&#123; &#123;pathname:`/$&#123;item.href&#125;` &#125;&#125; replace key=&#123;index&#125; onClick=&#123;this.toggleClass.bind(this,index)&#125; className=&#123;this.state.tab===index? &quot;public_tab_item active&quot; : &quot;public_tab_item&quot;&#125; id=&#123;item.dataId&#125;&gt; &lt;div className=&quot;public_tab_info&quot;&gt; &lt;p className=&#123;`public_tab_icon $&#123;item.dataClass&#125;`&#125;&gt;&lt;/p&gt; &lt;p&gt;&#123;item.title&#125;&lt;/p&gt; &lt;/div&gt; &lt;/Link&gt; 7. 导航高亮刷新保持 window.location.hash.slice(2)参考链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354switch (window.location.hash.slice(2)) &#123; case &quot;/home/Xrecommend&quot;: this.state.tab=0 break; case &quot;bestchoice&quot;: this.state.tab=1 break; case &quot;search&quot;: this.state.tab=2 break; case &quot;mine&quot;: this.state.tab=3 break; default: this.state.tab=0 break; &#125; &#125; **然后下面根据路径变化打类名 =============正常方法================// 根据路径给togoleclass赋值 switch (props.location.pathname) &#123; case &quot;/home/Xrecommend&quot;: this.state.togolleClass=0 break; case &quot;/home/Xchildren&quot;: this.state.togolleClass=1 break; case &quot;/home/Xadult&quot;: this.state.togolleClass=2 break; case &quot;/home/Xparents&quot;: this.state.togolleClass=3 break; case &quot;/home/Xfamily&quot;: this.state.togolleClass=4 break; case &quot;/home/Xtravel&quot;: this.state.togolleClass=5 break; default: this.state.togolleClass=0 break; &#125; ===========传值给子组件========== &lt;Xnav tab=&#123;this.state.togolleClass&#125;/&gt; ==========接收============ this.props = props; ===========赋值============== this.state = &#123; isActive:this.props.tab &#125; //然后下面根据三元正常判断即可 9.邮箱验证码步骤及思路 思路：当你点击发送验证码时，发起ajax请求，后端生成验证码，发送到你上面注册的邮箱，后端缓存验证码，留到用户拿到验证码输入时进行比对，正确，则插入数据库，失败不插入 先下载模块nodemailer 1cnpm install nodemailer --save-dev 引入模块 12345678910111213141516171819202122232425262728293031323334const nodemailer = require(&apos;nodemailer&apos;); //引入模块let transporter = nodemailer.createTransport(&#123; service: &apos;qq&apos;, //类型qq邮箱 port: 465, secure: true, // true for 465, false for other ports auth: &#123; user:&apos;854453495@qq.com&apos;, // 发送方的邮箱 pass: &apos;vrtjembbhfcmbegj&apos; // smtp 的授权码 &#125;&#125;);function sendMail(mail,code,call)&#123; // 发送的配置项 let mailOptions = &#123; from: &apos;&quot;Fred Foo 👻&quot; &lt;854453495@qq.com&gt;&apos;, // 发送方 to: mail, // 接收方 subject: &apos;欢迎注册“小雨伞”保险！&apos;, // 标题 text: &apos;Hello world?&apos;, // 文本内容 html: `&lt;h1&gt;您的验证码是:$&#123;code&#125;,请注意安全性，该验证码有效期为 5分钟&lt;/h1&gt;`//页面内容 &#125;; //发送函数 transporter.sendMail(mailOptions, (error, info) =&gt; &#123; if (error) &#123; call(-1) &#125; call(0)//因为是异步 所有需要回调函数通知成功结果 &#125;);&#125;module.exports=&#123;sendMail&#125; 接收前端路由处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var express = require(&apos;express&apos;);var router = express.Router();var db = require(&apos;../lib/db.js&apos;);var email = require(&apos;./sendEmail.js&apos;); //引入封装好的函数console.log(email)//解决跨域问题router.all(&apos;*&apos;, function (req, res, next) &#123; res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); //Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行 res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;); res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;*&apos;); res.header(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;); next();&#125;);/* GET users listing. */router.get(&apos;/&apos;, function(req, res, next) &#123; res.send(&apos;respond with a resource&apos;);&#125;);let check=&#123;&#125; //声明一个对象缓存邮箱和验证码，留着router.post(&apos;/email&apos;, function(req, res, next) &#123; console.log(req.body.params) let mail=req.body.params.email if (!mail) &#123;return res.send(&apos;参数错误&apos;)&#125; //email出错时或者为空时 let code = parseInt(Math.random(0,1)*10000) //生成随机验证码 check[mail]=code //发送邮件 email.sendMail(mail,code,(state)=&gt;&#123; if (state) &#123; res.send(&apos;验证码发送成功&apos;) &#125;else&#123; res.send(&apos;验证码发送失败&apos;) &#125; &#125;) &#125;);router.post(&apos;/login&apos;, function(req, res, next) &#123; console.log(req.body.params) db.query(function(db) &#123; //这里要用函数 db.collection(&quot;login&quot;).insertMany([req.body.params], function(err, result) &#123; res.send(&apos;succees&apos;); &#125;); &#125;)&#125;);module.exports = router; 10.路由获取方法 思路：在最大的组件获取到路由，通过props方法传到需要的子组件去 备注：因为小组件拿不到props 12var url = this.props.loction.pathname&lt;Xheader url=&#123;url&#125;/&gt; 11.路由跳转的两种方式 备注：如果不是需要注册登录那种判断，用Link即可 Link方式 1234import &#123; Link &#125; from &apos;react-router-dom&apos;&lt;Link to=&#123; &#123;pathname:`/$&#123;item.href&#125;` &#125;&#125; replace &gt; &lt;/Link&gt;&lt;Link to=&#123; &#123;`/home`&#125;&#125; replace &gt; &lt;/Link&gt; withRouter 方式 应用场景说明: 123456 &lt;Route exact path="/Home" component=&#123;Home&#125;/&gt;目的就是让被修饰的组件可以从属性中获取history,location,match,路由组件可以直接获取这些属性，而非路由组件就必须通过withRouter修饰后才能获取这些属性了1.只有包裹在Route组件里的才能使用`this.props.location`，2.假如有个需求，是面包屑或者导航组件里需要拿到`this.props.location`（导航组件或者面包屑一般不会包裹在`Route`里吧），那么直接这么写显然就不行了。必须通过withRouter修饰后才能获取到。 123456789101112import &#123; withRouter &#125; from &apos;react-router-dom&apos;===========React-Router 2.4.0版本以上=========import &#123; withRouter &#125; from &apos;react-router&apos;;clsss ABC extends Component &#123;&#125;module.exports = withRouter(ABC);===========React-Router 3.0.0版本以上=========this.props.router.push(&apos;/home/Xrecommend&apos;)===========React-Router 4.0版本以上===========this.props.history.push(&apos;/home/Xrecommend&apos;) 稳稳的写法 1234567import &#123; withRouter &#125; from &apos;react-router-dom&apos;=============================================goCar()&#123; this.props.history.push(&apos;/carOrder&apos;) &#125;============================================= export default withRouter(Xorder) 12.参数的获取1使用`this.props.match.params.xxx` 可以获取到当前路由的参数 13.react cookie用法 先下载模块 1cnpm install react-cookie --save-dev 引入 1import cookie from &apos;react-cookies&apos; 存入cookie basic1cookie.save(&apos;userId&apos;, this.state.value)； 删除cookie 1cookie.remove(&apos;userId&apos;) 获取cookie 12select([regex])this.state = &#123; userId: cookie.load(&apos;userId&apos;) &#125;; 14.React的Sass配置 先下载 1npm install sass-loader node-sass --save-dev 找到配置文件， 1node_modules/react-scripts/config/webpack.config.dev.js 找到module下的rules，然后找到最后一个配置，修改成如下的样子 1234567891011121314151617181920212223&#123; exclude: [/\.js$/,/\.html$/,/\.json$/,/\.scss$/], loader: require.resolve(&apos;file-loader&apos;), options: &#123; name: &apos;static/media/[name].[hash:8].[ext]&apos;, &#125;,&#125;,&#123; test:/\.scss$/, loaders:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;备注：如果不行的话，再把`webpack.config.prod.js`也变成同样的配置 15.loading效果 veu、react通用 下载、引入axios 1234567========react=========cnpm install axios --save-devimport axios from &apos;axios&apos;=========vue==========cnpm install mint-ui --save-devimport Mint from &apos;mint-ui&apos;;Vue.use(Mint); 下载引入antd-mobile 1234=========react==========import &#123; Toast &#125; from &apos;antd-mobile&apos;;import &apos;./assets/antd-mobile.css&apos;==========vue=========== 引入样式 1234备注：样式在node-modues里面，可自行找路径，或复制过来import &apos;./assets/antd-mobile.css&apos;*vue如需引用样式，同理import &apos;mint-ui/lib/style.css&apos;; 在index.js写如下代码 12345678910111213141516=============请求之前loading==============axios.interceptors.request.use((config) =&gt; &#123; Toast.loading(&apos;&apos;, 3,true); return config;&#125;, (err) =&gt; &#123; return Promise.reject(err)&#125;)===========请求成功之后取消loading=======axios.interceptors.response.use((response) =&gt; &#123; Toast.hide(); //关闭loading return response;&#125;, (err) =&gt; &#123; return Promise.reject(err);&#125;) 在vue的main.js中 12345678910111213141516171819============请求之前loading==============Axios.interceptors.request.use((config) =&gt; &#123; Mint.Indicator.open(&#123; //打开loading text: &apos;加载中...&apos;, spinnerType: &apos;fading-circle&apos; &#125;); return config;&#125;, (err) =&gt; &#123; return Promise.reject(err)&#125;)==============请求成功之后取消loading=======Axios.interceptors.response.use((response) =&gt; &#123; Mint.Indicator.close(); //关闭loading return response;&#125;, (err) =&gt; &#123; return Promise.reject(err);&#125;) 16.回退goback()用法12345678910import &#123;createHashHistory&#125; from &apos;history&apos;;//组件引入const history = createHashHistory();===========后退=========goback()&#123; this.props.history.goBack() &#125;===========前进======== push()&#123; this.props.history.push() &#125; 切换路由回退顶部12345678910111213141516171819202122232425262728293031323334class ScrollToTop extends Component &#123; componentDidUpdate(prevProps) &#123; if (this.props.location !== prevProps.location) &#123; window.scrollTo(0, 0); &#125; &#125; render() &#123; return this.props.children; &#125;&#125;export default withRouter(ScrollToTop);//Route包裹 传入location 监听其变化新旧location不相等则执行window.scrollTo(0, 0);回顶部&lt;Route history=&#123;history&#125; render=&#123;(&#123; location &#125;) =&gt; ( &lt;ScrollToTop location=&#123;location&#125;&gt; &lt;div style=&#123;&#123;position: &apos;absolute&apos;,width:&apos;100%&apos;,height:&apos;100%&apos;&#125;&#125;&gt; &lt;Switch location=&#123;location&#125;&gt; &lt;Route path=&quot;/home/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/detail/&quot; component=&#123;Detail&#125; /&gt; &lt;Route path=&quot;/param/&quot; component=&#123;Param&#125; /&gt; &lt;Route path=&quot;/comment/&quot; component=&#123;Comment&#125; /&gt; &lt;Route path=&quot;/mine/&quot; component=&#123;Mine&#125; /&gt; &lt;Route path=&quot;/list&quot; component=&#123;List&#125;/&gt; &lt;Route history=&#123;history&#125; path=&quot;/login&quot; component=&#123;Login&#125;/&gt; &lt;Route history=&#123;history&#125; path=&quot;/registe&quot; component=&#123;Registe&#125;/&gt; &lt;Route path=&quot;/phone&quot; component=&#123;Phone&#125;/&gt; &lt;Route path=&quot;/exchangeRate&quot; component=&#123;ExchangeRate&#125;/&gt; &lt;Route path=&quot;/cart/&quot; component=&#123;Cart&#125;/&gt; &lt;Route path=&quot;/personal/&quot; component=&#123;Personal&#125;/&gt; &lt;Redirect history=&#123;history&#125; from=&quot;/&quot; exact to=&quot;/home/mainPage1&quot; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/ScrollToTop&gt;)&#125;/&gt;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序起步（2）]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[安装官方文档首先下载微信小程序的开发者工具小程序开发者工具，再下载微信小程序DEMO源码安装开发者工具，并解压DEMO源码，在开发者工具中导入源码项目 注册打开微信公众平台，在里面注册账号选择小程序，用户体选择个人 app.json(全局配置)我们使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多tab等 pages如果学过其他框架，可以把它理解为路由，在app.json文件的pages属性里面定义路由和对应的组件，默认是在pages文件夹里面寻找xxx组件的xxx.js文件，当然没有后缀 pages/index/index =&gt; page文件夹下的index组件的文件夹下的所有资源 pages接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成，每一项代表对应页面的路径+文件名信息 数组的第一项代表小程序的初始页面，小程序中新增/减少页面，都需要对 pages 数组进行修改 文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合 123456789&#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;, &quot;pages/test/test&quot;, &quot;pages/text/text&quot; ],//code&#125; tabBartabBar其实就是配置底部的选项卡，在app.json文件的tabBar属性里面定义底部的选项卡的详细配置 如果我们的小程序是一个多 tab 应用(客户端窗口的底部或顶部有tab栏可以切换页面)，那么我们可以通过tabBar配置项指定tab栏的表现，以及tab切换时显示的对应页面 通过页面跳转wx.navigateTo或者页面重定向wx.redirectTo所到达的页面，即使它是定义在 tabBar 配置中的页面，也不会显示底部的tab栏 tabBar是一个数组，只能配置最少2个、最多5个tab，tab按数组的顺序排序 12345678910111213141516171819202122&#123;//code &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#666&quot;, &quot;selectedColor&quot;: &quot;#268dcd&quot;, &quot;borderStyle&quot;: &quot;white&quot;, &quot;backgroundColor&quot;: &quot;#fafafa&quot;, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;image/wscats.png&quot;, &quot;selectedIconPath&quot;: &quot;image/wscats.png&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;分类&quot; &#125; //code ] &#125;&#125; 一般我们可以新建一个放图标的文件夹image，此文件夹跟pages同级，然后在里面我们可以放图标 我在文件夹里面放了两张图片wscats.png和wscats-active.png，我们就可以在iconPath和selectedIconPath里面把图片引进来，设置的分别是切换选项卡时候出现的图标 tabBar属性 作用 color 未选中时候文字颜色 selectedColor 选中时候文字颜色 borderStyle 边样式，可以设置颜色和粗细 backgroundColor 背景颜色 list 详情看下表 list接受一个数组，数组中的每个项都是一个对象，其属性值如下 list属性 作用 pagePath 跳转路由 iconPath 未选中时候的图标 selectedIconPath 选中时候的图标 text 文字描述 window用于设置小程序的状态栏、导航条、标题、窗口背景色 networkTimeout可以设置各种网络请求的超时时间 debug可以在开发者工具中开启debug模式，在开发者工具的控制台面板，调试信息以info的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发 。可以帮助开发者快速定位一些常见的问题 page.json每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置app.json中的window配置项的内容，页面中配置项会覆盖app.json的window中相同的配置项 页面的.json只能设置window相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键 如图，在logs组件里面的logs.json设置对应的参数，那就会覆盖app.json原有的配置项 xxx.json(页面配置)每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置 页面的配置只能设置app.json中部分window配置项的内容，页面中配置项会覆盖app.json的window中相同的配置项，示例如下 1234567&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125; 组件可以建立一个components的目录 在tab-content1.wxml写入以下代码，这里可以配合使用&lt;slot&gt;&lt;/slot&gt;让我们使用组件的时候插入片段 12345&lt;view&gt; &lt;!--components/tab-content1/tab-content1.wxml--&gt; &lt;text&gt;components/tab-content1/tab-content1.wxml&lt;/text&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; 里面新建一个目录为tab-content1的目录作为组件的放置位置，然后可以在pages目录下的index.json下写入以下代码 12345&#123; &quot;usingComponents&quot;: &#123; &quot;tab-content1&quot;: &quot;/components/tab-content1/tab-content1&quot; &#125;&#125; 然后在pages目录下的index.wxml下写入以下代码，来使用组件 12345&lt;view class=&quot;weui-tab__content&quot; hidden=&quot;&#123;&#123;activeIndex != 0&#125;&#125;&quot;&gt; &lt;tab-content1&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/tab-content1&gt;&lt;/view&gt; 生命周期组件里面有的生命周期，可以在这里做逻辑或者监听其他组件的逻辑来通信数据 定义段 类型 是否必填 描述 created Function 否 组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用 setData attached Function 否 组件生命周期函数，在组件实例进入页面节点树时执行 ready Function 否 组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用 SelectorQuery ） moved Function 否 组件生命周期函数，在组件实例被移动到节点树另一个位置时执行 detached Function 否 组件生命周期函数，在组件实例被从页面节点树移除时执行 组件通信组件和组件之间的通信，我个人会用$on和$emit来实现，参考发布订阅模式 父传子的数据通信 父组件在子组件的标签值上传递值 1&lt;pannel channel=&quot;hot&quot;&gt;&lt;/pannel&gt; 子组件&lt;pannel&gt;用properties属性接受，逻辑中用this.properties.channel获取值，这种方法类似于vue和react中的props方法 12345678Component(&#123; /** * 组件的属性列表 */ properties: &#123; channel: String &#125;&#125; 模板语法使用 name 属性，作为模板的名字。然后在&lt;template/&gt;内定义代码片段，可以构建一个可复用的模板 123&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 使用模板，先 import 对应模板的文件路径，使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入 123456789101112&lt;import src=&quot;item.wxml&quot; /&gt;&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot; /&gt;&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt;Page(&#123; data: &#123; item: &#123; index: 0, msg: &apos;this is a template&apos;, time: &apos;2016-09-15&apos; &#125; &#125;&#125;) is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板： 12345678910&lt;template name=&quot;odd&quot;&gt; &lt;view&gt; odd &lt;/view&gt;&lt;/template&gt;&lt;template name=&quot;even&quot;&gt; &lt;view&gt; even &lt;/view&gt;&lt;/template&gt;&lt;block wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;&quot;&gt; &lt;template is=&quot;&#123;&#123;item % 2 == 0 ? &apos;even&apos; : &apos;odd&apos;&#125;&#125;&quot; /&gt;&lt;/block&gt; WeUI在Github下载WeUI for 小程序 为微信小程序量身设计 Github仓库 把weui-wxss/dist/style/目录中的weui.wxss放到程序根目录下，然后在app.wxss全局引用weui样式 1@import &apos;weui.wxss&apos;; 然后就可以复制粘贴src/example文件夹里面的组件进行开发了 导航导航相当于路由跳转，用navigator标签，然后在属性值上面放自己定义好的组件页面 1234567&quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;, &quot;pages/test/test&quot;, &quot;pages/text/text&quot;, &quot;pages/detail/detail&quot; ], 比如要跳到详情页组件就写url=&quot;/pages/detail/detail&quot;，如果要跳到主页那就写url=&quot;/pages/index/index&quot;，根据pages属性值里面定义好的路由去改相应的链接地址 1&lt;navigator url=&quot;/pages/detail/detail&quot; class=&quot;weui-media-box weui-media-box_appmsg&quot; hover-class=&quot;weui-cell_active&quot;&gt;&lt;/navigator&gt; 路由传参我们在链接上带上哈希值，然后传递给详情页 1&lt;navigator url=&quot;/pages/detail/detail?id=&#123;&#123;index&#125;&#125;&quot; class=&quot;weui-media-box weui-media-box_appmsg&quot; hover-class=&quot;weui-cell_active&quot;&gt; 在详情页中获取options中的哈希值 12345Page(&#123; onLoad: function (options) &#123; console.log(options) &#125;&#125;) 获取视图输入值input输入框显示自己输入的值，bindinput来对输入的值进行接受，再把值赋给一个变量 1&lt;input name=&quot;user&quot; value=&quot;&#123;&#123;user&#125;&#125;&quot; bindinput=&quot;inputUser&quot; type=&quot;text&quot; /&gt; 1`value=&quot;&#123;&#123;user&#125;&#125;&quot;`显示绑定的值，bindinput绑定事件，在e中的detail属性中获取 123456inputUser: function (e) &#123; console.log(e.detail.value) this.setData(&#123; user: e.detail.value &#125;)&#125; 常用APIwx.request(Object object)发起HTTPS网络请求，这个相当于微信小程序给我们封装好的ajax请求 在使用之前记得要去后台页面设置安全域名 12345678910111213wx.request(&#123; url: &apos;test.php&apos;, //仅为示例，并非真实的接口地址 data: &#123; x: &apos;&apos;, y: &apos;&apos; &#125;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; // 默认值 &#125;, success (res) &#123; console.log(res.data) &#125;&#125;) 当然如果只是测试可以勾选不校验合法域名 mpvuempvue github地址 请参见是一个使用Vue.js开发小程序的前端框架。框架基于Vue.js核心，mpvue修改了Vue.js的runtime和compiler实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套Vue.js开发体验 安装搭建环境 12345678910111213141516171819202122# 1. 先检查下 Node.js 是否安装成功$ node -vv8.9.0$ npm -v5.6.0# 2. 可以考虑切换源为 taobao 源$ npm set registry https://registry.npm.taobao.org/# 3. 全局安装 vue-cli# 一般是要 sudo 权限的$ npm install --global vue-cli@2.9# 4. 创建一个基于 mpvue-quickstart 模板的新项目# 新手一路回车选择默认就可以了$ vue init mpvue/mpvue-quickstart my-project# 5. 安装依赖$ cd my-project$ npm install$ npm run dev 注意事项新增的页面需要重新npm run dev来进行编译，比如新建的vue组件需要重新编译，小程序的工具才能看出效果 对应小程序的文件vue文件对应小程序里面的那些文件 12345678910111213&lt;template&gt;/* 这部分相当于原生小程序的 app.wxml */&lt;/template&gt;&lt;script&gt;/* 这部分相当于原生小程序的 app.js */export default &#123; created () &#123; &#125;&#125;&lt;/script&gt;&lt;style&gt;/* 这部分相当于原生小程序的 app.wxss */&lt;/style&gt; 全局的app.json就是对应小程序的app.json 1234567891011121314151617181920212223242526272829&#123; &quot;pages&quot;: [ &quot;pages/index/main&quot;, &quot;pages/logs/main&quot;, &quot;pages/counter/main&quot;, &quot;pages/setting/main&quot; ], &quot;window&quot;: &#123; &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;你是谁&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot; &#125;, &quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/index/main&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/main&quot;, &quot;text&quot;: &quot;日志&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;pages/counter/main&quot;, &quot;text&quot;: &quot;vuex&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/setting/main&quot;, &quot;text&quot;: &quot;设置&quot; &#125;] &#125;&#125; 局部的main.json对应的是page里面的xxx.json 1234&#123; &quot;navigationBarTitleText&quot;: &quot;查看启动日志&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#58bc58&quot;&#125; Vuex状态管理 12345678910111213141516171819import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment: (state) =&gt; &#123; const obj = state obj.count += 1 &#125;, decrement: (state) =&gt; &#123; const obj = stat obj.count -= 1 &#125; &#125;&#125;)export default store 组件可以通过store.commit(&#39;increment&#39;)，注意发现在语法上用单引号，结尾不要用分号，还有函数括号前要放空格，不然会报错 12345678import store from &apos;../store&apos;export default &#123; methods: &#123; edit () &#123; store.commit(&apos;increment&apos;) &#125; &#125;&#125; 可以直接使用store.state.xxx获取state的值 12345678import store from &apos;../store&apos;export default &#123; computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; 其他注意点 在模板中，动态插入HTML的v-html指令不可用 小程序的界面并不是基于浏览器的BOM/DOM的，所以不能动态的在界面模板里直接插入HTML片段来显示 如果要插入html片段可以用&lt;rich-text&gt;组件或者wxParse(https://github.com/icindy/wxParse)来实现%E6%9D%A5%E5%AE%9E%E7%8E%B0) 在模板中，用于数据绑定的双括号语法中的表达式功能存在诸多限制，以下功能都不能使用 表达式中放函数 1&lt;div&gt;&#123;&#123; formatMessage(msg) &#125;&#125;&lt;/div&gt; 调用对象的方法 1&lt;div&gt;&#123;&#123; msg.trim().split(&apos;,&apos;).join(&apos;#&apos;) &#125;&#125;&lt;/div&gt; 过滤器 1&lt;div&gt;&#123;&#123; msg | format &#125;&#125;&lt;/div&gt; 在模板中，除事件监听外，其余地方都不能调用methods下的函数 1&lt;div v-if=&quot;getErrorNum() &gt; 0 &amp;&amp; code == 10001&quot; class=&quot;error&quot;&gt;&#123;&#123; errorMsg &#125;&#125;&lt;/div&gt; 在模板中，不支持直接绑定一个对象到style或class属性上 官方建议的方案如下 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div :class=&quot;classStr&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125; &#125; &#125;, computed: &#123; classStr() &#123; let arr = [] for (let p in this.classObject) &#123; if (this.classObject[p]) &#123; arr.push(p) &#125; &#125; return arr.join(&apos; &apos;) &#125; &#125;&#125;&lt;/script&gt; 在模板中，嵌套使用v-for时，必须指定索引index 123&lt;ul v-for=&quot;(category, index) in categories&quot;&gt; &lt;li v-for=&quot;(product, productIndex) in category.products&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 事件处理中的注意点 在mpvue中，一般可以使用Web的DOM事件名来绑定事件，mpvue会将Web事件名映射成对应的小程序事件名 1234567891011121314151617181920212223// 左侧为WEB事件 : 右侧为对应的小程序事件&#123; click: &apos;tap&apos;, touchstart: &apos;touchstart&apos;, touchmove: &apos;touchmove&apos;, touchcancel: &apos;touchcancel&apos;, touchend: &apos;touchend&apos;, tap: &apos;tap&apos;, longtap: &apos;longtap&apos;, input: &apos;input&apos;, change: &apos;change&apos;, submit: &apos;submit&apos;, blur: &apos;blur&apos;, focus: &apos;focus&apos;, reset: &apos;reset&apos;, confirm: &apos;confirm&apos;, columnchange: &apos;columnchange&apos;, linechange: &apos;linechange&apos;, error: &apos;error&apos;, scrolltoupper: &apos;scrolltoupper&apos;, scrolltolower: &apos;scrolltolower&apos;, scroll: &apos;scroll&apos;&#125; 对于表单，请直接使用小程序原生的表单组件 一句话，表单组件又多又复杂，框架可能Hold不住。所以在实际开发中，推荐直接使用小程序的表单组件标签来写，而不是使用Web的表单组件标签来写。当然了，在mpvue中使用了小程序的组件标签，数据绑定功能还是完全可以用的 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;picker @change=&quot;handlePickerChange&quot; :value=&quot;selectedIndex&quot; :range=&quot;messages&quot;&gt; &lt;view class=&quot;picker&quot;&gt;当前消息：&#123;&#123; messages[selectedIndex] &#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; selectedIndex: 0, messages: [&apos;Hello&apos;, &apos;World&apos;, &apos;Haha&apos;] &#125; &#125;, methods: &#123; handlePickerChange (e) &#123; console.log(e) &#125; &#125;&#125;&lt;/script&gt; vue-router和axios无法使用 另外，在Vue开发Web应用的时候，通常使用vue-router来进行页面路由。但是在mpvue小程序开发中，不能用这种方式，请使用标签和小程序原生API wx.navigateTo等来做路由功能 还有就是请求后端数据，我们通常在Web开发中使用axios等ajax库来实现，但是在小程序开发中也是不能用的，也请使用小程序的原生API wx.request等来进行 参考文档 mpvue官网 使用Vue开发微信小程序：mpvue框架]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装的拖拽与放大缩小， 旋转]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2F%E6%8B%96%E6%8B%BD%E6%94%BE%E5%A4%A7%2C%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[封装的拖拽与放大缩小， 旋转首先基础的有两个元素来控制旋转和放大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//html和css先为这样 &lt;style&gt; .box &#123; display: flex; justify-content: center; align-items: center; color: #ffffff; position: relative; width: 500px; height: 500px; background: red; cursor: pointer; &#125; .rotate &#123; cursor: pointer; position: absolute; top: 0; right: 0; width: 50px; height: 50px; background: #000; display: flex; align-items: center; justify-content: center; &#125; .del &#123; cursor: pointer; position: absolute; top: 0; left: 0; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background: #000; &#125; .deag &#123; cursor: pointer; position: absolute; bottom: 0; right: 0; width: 50px; height: 50px; background: #000; display: flex; align-items: center; justify-content: center; &#125; &lt;/style&gt;&lt;/head&gt; &lt;div class=&quot;box&quot;&gt; 拖拽移动 &lt;i class=&quot;rotate&quot;&gt;旋转&lt;/i&gt; &lt;i class=&quot;del&quot;&gt;删除&lt;/i&gt; &lt;i class=&quot;deag&quot;&gt;拖拽放大缩小&lt;/i&gt; &lt;/div&gt; js部分旋转123456789101112131415161718192021222324252627282930313233343536373839404142var preX, preY; //上一次鼠标点的坐标var curX, curY; //本次鼠标点的坐标var preAngle; //上一次鼠标点与圆心(150,150)的X轴形成的角度(弧度单位)var transferAngle; //当前鼠标点与上一次preAngle之间变化的角度var a = 0;$(".rotate").mousedown(function(e) &#123; e.stopPropagation(); e.preventDefault(); //获取圆心（盒子距离浏览器的距离+自身宽高的一半） let oldY = $(".box").offset().top + $(".box")[0].offsetHeight / 2; let oldX = $(".box").offset().left + $(".box")[0].offsetWidth / 2; //按钮父元素 let myimg = e.target.parentElement; //clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 preX = e.clientX; preY = e.clientY; //atan2() 方法可返回从 x 轴到点 (x,y) 之间的角度。 //计算当前点击的点与圆心的X轴的夹角(弧度) --&gt; 上半圆为负(0 ~ -180), 下半圆未正[0 ~ 180] preAngle = Math.atan2(preY - oldY, preX - oldX); document.onmousemove = function(ev) &#123; ev.stopPropagation(); ev.preventDefault(); //新的点的位置，即鼠标的(x,y)的位置 curX = event.clientX; curY = event.clientY; //移动后的鼠标点与圆心的X轴形成的角度(弧度单位) var curAngle = Math.atan2(curY - oldY, curX - oldX); transferAngle = curAngle - preAngle; a += (transferAngle * 180 / Math.PI); myimg.style.transform = "rotate(" + a + "deg)"; //移动后坐标点重新赋值 preX = curX; preY = curY; preAngle = curAngle; ev.target.onmouseup = function(e) &#123; document.onmousedown = null; document.onmouseup = null; document.onmousemove = null; &#125; &#125;&#125;) 放大缩小123456789101112131415161718192021222324252627282930313233343536$(".deag").mousedown(function(e) &#123; let target = e.target; let mybox = target.parentElement; //盒子 // 阻止冒泡,避免缩放时触发移动事件 e.stopPropagation(); e.preventDefault(); //获取盒子的长宽和点击时候鼠标距离浏览器的距离 var pos = &#123; 'w': mybox.offsetWidth, 'h': mybox.offsetHeight, 'x': e.clientX, 'y': e.clientY &#125;; document.onmousemove = function(ev) &#123; ev.stopPropagation(); ev.preventDefault(); //clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 //Math.max返回两个数值的最大值，此处用来设置最小宽度 var w = Math.max(200, ev.clientX - pos.x + pos.w) // 新的宽/旧的宽 得到比例尺 var tt = w / pos.w; //高也乘以比例尺达到等比放大缩小 var h = pos.h * tt; //offsetWidth返回元素的宽度 //offsetTop返回元素的上外缘距离最近采用定位父元素内壁的距离， //如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离 mybox.style.width = w + 'px'; mybox.style.height = h + 'px'; // 释放事件 ev.target.onmouseup = function(e) &#123; document.onmousedown = null; document.onmouseup = null; document.onmousemove = null; &#125; &#125;&#125;) 拖拽12345678910111213141516171819202122232425262728$(".box").mousedown(function(e) &#123; var nowshowimg = e.target; // 浏览器有一些图片的默认事件,这里要阻止 e.preventDefault(); var nowbox = e.target; //获取鼠标在盒子内的距离 var disX = e.clientX - nowbox.style.left.slice(0, -2); var disY = e.clientY - nowbox.style.top.slice(0, -2); nowshowimg.onmousemove = function(ev) &#123; // ev.preventDefault(); //获取鼠标移动后整个盒子距离浏览器的距离 var x = ev.clientX - disX; var y = ev.clientY - disY; // 图形移动的边界判断 x = x &lt;= 0 ? 0 : x; x = x &gt;= document.offsetWidth - nowshowimg.offsetWidth ? document.offsetWidth - nowshowimg.offsetWidth : x; y = y &lt;= 0 ? 0 : y; y = y &gt;= document.offsetHeight - nowshowimg.offsetHeight ? document.offsetHeight - nowshowimg.offsetHeight : y; nowbox.style.left = x + 'px'; nowbox.style.top = y + 'px'; &#125; nowshowimg.onmouseup = function(ev) &#123; // ev.preventDefault(); nowshowimg.onmousemove = null; nowshowimg.onmouseup = null; &#125;&#125;)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序起步]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[小程序一、小程序起步1.微信小程序官网](https://mp.weixin.qq.com/cgi-bin/wx)注册账号 2.进入官网看文档 二、微信小程序路由配置 在pages里面新建pages会在pack.json自动生成路由 1234567"pages": [ "pages/index/index", "pages/logs/logs", "pages/mine/mine", "pages/serach/search", "pages/find/find"], tabBar写在window后面 1234567891011121314151617181920212223242526272829"tabBar": &#123; "selectedColor": "#666", //选中时的样式 "list": [ &#123; "pagePath": "pages/index/index", "text": "首页", "iconPath": "./pages/images/首页-未选中.png", //字体图标路径 "selectedIconPath": "./pages/images/首页-选中.png" //选中时字体图标路径 &#125;, &#123; "pagePath": "pages/serach/search", "text": "发现", "iconPath": "./pages/images/发现未选中.png", "selectedIconPath": "./pages/images/发现-选中.png" &#125;, &#123; "pagePath": "pages/logs/logs", "text": "日志", "iconPath": "./pages/images/日志.png", "selectedIconPath": "./pages/images/日志选中.png" &#125;, &#123; "pagePath": "pages/mine/mine", "text": "我的", "iconPath": "./pages/images/我 的.png", "selectedIconPath": "./pages/images/我的选中.png" &#125; ]&#125;, 三、数据绑定及渲染1.渲染1234567&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt;Page(&#123; data: &#123; message: &apos;Hello MINA!&apos; &#125;&#125;) wx:if用法123&gt; 备注：这种属性方法的都要用`&quot;&#123;&#123;&#125;&#125;&quot;`这种形式，例如，`wx:for=&quot;&#123;&#123;&#125;&#125;&quot;`、&gt;&gt; `wx:if=&quot;&#123;&#123;&#125;&#125;&quot;`、`checked=&quot;&#123;&#123;false&#125;&#125;&quot;`，还有三元运算`hidden=&quot;&#123;&#123;flag ? true : false&#125;&#125;&quot;` 2.列表渲染wx:for123&gt; 在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。&gt;&gt; 默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item` 123&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 四、做音乐播放器小程序步骤1.先创建你需要的页面及路由1&gt; 例如：先创建一个首页、一个详情页、搜索页 2.引入weui 、search组件、pannel组件3.新建components在里面写小组件4.在index.js发起ajax请求，利用组件通信传到pannel组件里面12345678910111213141516171819202122232425262728293031323334353637383940414243Page(&#123; data:&#123; song_list:[], //定义一个空数组 offset:0 &#125;, onReady()&#123; this.loadMore() &#125;, onLoad: function () &#123; this.setData(&#123; icon20: base64.icon20, icon60: base64.icon60 &#125;); &#125;, onPullDownRefresh() &#123; this.loadMore() &#125;, loadMore() &#123; var self = this; wx.request(&#123; url: 'https://tingapi.ting.baidu.com/v1/restserver/ting', //仅为示例，并非真实的接口地址 data: &#123; method: "baidu.ting.billboard.billList", type: 1, size: 10, offset: this.data.offset &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success(res) &#123; wx.stopPullDownRefresh() self.setData(&#123; offset:++self.data.offset &#125;) console.log(res.data.song_list) //把请求回来的数据合并到空数组，因为是上拉刷新，所以就要用新数组合并旧数据，以达到每次上面都是新的 self.setData(&#123; song_list: res.data.song_list.concat(self.data.song_list) &#125;) &#125; &#125;) &#125; 5.利用组件通信传数据到子组件1&lt;xpannel songList=&quot;&#123;&#123;song_list&#125;&#125;&quot;&gt;&lt;/xpannel&gt; 6.接收父组件传过来的数据1234567891011121314properties: &#123; songList: &#123; // 属性名 type: Array, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型） value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个 observer: function (newVal, oldVal, changedPath) &#123; console.log(newVal) this.setData(&#123; song: newVal //把接收过来的数组存到本地 &#125;) // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange' // 通常 newVal 就是新设置的数据， oldVal 是旧数据 &#125; &#125;, &#125;, 7.动态渲染接收过来的数据123456789&lt;navigator url=&quot;&#123;&#123;&apos;/pages/detail/detail?songId=&apos;+item.song_id&#125;&#125;&quot; wx:for=&quot;&#123;&#123;song&#125;&#125;&quot; class=&quot;weui-media-box weui-media-box_appmsg&quot; hover-class=&quot;weui-cell_active&quot;&gt; &lt;view class=&quot;weui-media-box__hd weui-media-box__hd_in-appmsg&quot;&gt; &lt;image class=&quot;weui-media-box__thumb&quot; src=&quot;&#123;&#123;item.pic_big&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;weui-media-box__bd weui-media-box__bd_in-appmsg&quot;&gt; &lt;view class=&quot;weui-media-box__title&quot;&gt;&#123;&#123;item.album_title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;weui-media-box__desc&quot;&gt;&#123;&#123;item.country&#125;&#125;-&#123;&#123;item.author&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/navigator&gt; 8.传songid到详情页1&gt; 传songid到详情页的目的是，让详情页根据你传过来的id发起ajax请求，渲染数据 123&lt;navigator url=&quot;&#123;&#123;&apos;/pages/detail/detail?songId=&apos;+item.song_id&#125;&#125;&quot; wx:for=&quot;&#123;&#123;song&#125;&#125;&quot; class=&quot;weui-media-box weui-media-box_appmsg&quot; hover-class=&quot;weui-cell_active&quot;&gt;备注：通过拼接字符串的形式传送 url=&quot;&#123;&#123;&apos;/pages/detail/detail?songId=&apos;+item.song_id&#125;&#125;&quot; 9.接收传过来的id,设置给本地变量1234567891011 onLoad: function (options) &#123; // console.log(options.songId) this.setData(&#123; songId: options.songId &#125;) this.getSong(); this.getlrc() console.log(this.data.songId) &#125;备注：`options`为形参，好比vue和react中的`props` 10.在详情页引入audio组件 html页面 1234567&lt;!-- audio.wxml --&gt;&lt;audio poster=&quot;&#123;&#123;poster&#125;&#125;&quot; name=&quot;&#123;&#123;name&#125;&#125;&quot; author=&quot;&#123;&#123;author&#125;&#125;&quot; src=&quot;&#123;&#123;src&#125;&#125;&quot; id=&quot;myAudio&quot; controls loop&gt;&lt;/audio&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;audioPlay&quot;&gt;播放&lt;/button&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;audioPause&quot;&gt;暂停&lt;/button&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;audio14&quot;&gt;设置当前播放时间为14秒&lt;/button&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;audioStart&quot;&gt;回到开头&lt;/button&gt; js页面 12345678910111213141516171819202122232425// audio.jsPage(&#123; onReady: function (e) &#123; // 使用 wx.createAudioContext 获取 audio 上下文 context this.audioCtx = wx.createAudioContext('myAudio') &#125;, data: &#123; poster: 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000', name: '此时此刻', author: '许巍', src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&amp;fromtag=46', &#125;, audioPlay: function () &#123; this.audioCtx.play() &#125;, audioPause: function () &#123; this.audioCtx.pause() &#125;, audio14: function () &#123; this.audioCtx.seek(14) &#125;, audioStart: function () &#123; this.audioCtx.seek(0) &#125;&#125;) 11.把引入的audio参数全变成变量123456789data: &#123; songId:"", poster: '', name: '', author: '', src: '', lrc:"", time:0&#125;, 12.发起ajax请求把请求回来的数据赋给data里面的变量1234567891011121314151617181920212223getSong() &#123; var self = this; wx.request(&#123; url: 'https://tingapi.ting.baidu.com/v1/restserver/ting', //仅为示例，并非真实的接口地址 data: &#123; method:"baidu.ting.song.play", songid:this.data.songId &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success(res) &#123; console.log(res.data) self.setData(&#123; poster: res.data.songinfo.pic_big, name: res.data.songinfo.title, author: res.data.songinfo.author, src: res.data.bitrate.file_link &#125;) &#125; &#125;) &#125; 备注：此时就可以播放歌曲了 13.歌词处理12345678910111213141516171819202122232425262728293031323334353637383940414243getlrc() &#123; var self = this; wx.request(&#123; url: 'https://tingapi.ting.baidu.com/v1/restserver/ting', //仅为示例，并非真实的接口地址 data: &#123; method:"baidu.ting.song.lry", songid:this.data.songId &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success(res) &#123; // console.log(res.data) let obj = self.parseLyric(res.data.lrcContent) //执行函数拿到歌词 console.log(obj) self.setData(&#123; lrc: obj &#125;) &#125; &#125;) &#125;, //把歌词处理成一段一段的 parseLyric(lrc) &#123; var lyrics = lrc.split("\n"); var lrcObj = &#123;&#125;; for (var i = 0; i &lt; lyrics.length; i++) &#123; var lyric = decodeURIComponent(lyrics[i]); var timeReg = /\[\d*:\d*((\.|\:)\d*)*\]/g; var timeRegExpArr = lyric.match(timeReg); if (!timeRegExpArr) continue; var clause = lyric.replace(timeReg, ''); for (var k = 0, h = timeRegExpArr.length; k &lt; h; k++) &#123; var t = timeRegExpArr[k]; var min = Number(String(t.match(/\[\d*/i)).slice(1)), sec = Number(String(t.match(/\:\d*/i)).slice(1)); var time = min * 60 + sec; lrcObj[time] = clause; &#125; &#125; return lrcObj; &#125;, 14.渲染歌词1&gt; 你可以在本地设置个时间为time:0,然后再设置个定时器，让time每秒+1，根据time渲染歌词 12345678910111213141516171819202122232425 data: &#123; songId:&quot;&quot;, poster: &apos;&apos;, name: &apos;&apos;, author: &apos;&apos;, src: &apos;&apos;, lrc:&quot;&quot;, time:0 //设置tiem &#125;, ====================== audioPlay: function () &#123; this.audioCtx.play(); timer=setInterval(() =&gt; &#123; this.setData(&#123; time: ++this.data.time &#125;) &#125;,1000) &#125;, //按暂停时清除定时器 audioPause: function () &#123; this.audioCtx.pause(); clearInterval(timer); &#125;, //渲染歌词&lt;text&gt;&#123;&#123;lrc[time]&#125;&#125;&lt;/text&gt; 15.搜索歌曲做法123&gt; 1.serach组件复用`&lt;xsearchBar status=&quot;find&quot;&gt;&lt;/xsearchBar&gt; `&gt;&gt; 2.接收search`status` 12345678910111213141516 properties: &#123; status: String // 简化的定义方式 &#125;,=============================== ready() &#123; console.log(this.data.inputVal) if (this.data.status == "find") &#123; this.setData(&#123; inputShowed: true //显示取消和输入光标 &#125;); &#125; else &#123; this.setData(&#123; inputShowed: false &#125;); &#125; &#125; 1&gt; 3.点击取消回到首页 1234showInput: function () &#123; wx.navigateTo(&#123; url: &quot;/pages/find/find&quot; &#125;) 1&gt; 4.输入文字发起ajax请求 123456789101112131415161718192021222324252627282930313233343536data: &#123; inputShowed: false, inputVal: "", renderSong:[] &#125;, =================================== inputTyping: function (e) &#123; this.searchSong(e.detail.value) //执行搜索歌曲函数，传入输入框的`value` this.setData(&#123; inputVal: e.detail.value &#125;); console.log(this.data.inputVal) &#125;, =========================================== searchSong(keyword) &#123; var self = this; wx.request(&#123; url: 'https://tingapi.ting.baidu.com/v1/restserver/ting', //仅为示例，并非真实的接口地址 data: &#123; method: "baidu.ting.search.catalogSug", query: keyword &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success(res) &#123; console.log(res.data) self.setData(&#123; renderSong: res.data.song ? res.data.song:"" //把得到的数据赋给本地变量 &#125;) console.log(self.renderSong) &#125; &#125;) &#125;, 16.点击的时候把数据传到详情页123456&lt;navigator url=&quot;&#123;&#123;&apos;/pages/detail/detail?songId=&apos;+item.songid&#125;&#125;&quot; class=&quot;weui-cell&quot; wx:for=&quot;&#123;&#123;renderSong&#125;&#125;&quot; hover-class=&quot;weui-cell_active&quot;&gt; &lt;view class=&quot;weui-cell__bd&quot;&gt; &lt;view&gt;&#123;&#123;item.artistname&#125;&#125;-&#123;&#123;item.songname&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; 备注：传songid到详情页 url=&quot;&#123;&#123;&apos;/pages/detail/detail?songId=&apos;+item.songid&#125;&#125;&quot;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli版本对比整理]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fvue%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Vue-cli 3.0版本与2.X版本比较3.0版本创建的目录 (vue create my-project 以下创建的是默认的模板) 2.X版本创建的目录 (创建命令 vue init webpack my-project) 二者区别：主要是配置webpack的区别2.x版本里会帮你以webpack的模板创建好各类文件都有默认的参数，只需要改就行了。而3.0版本开始，目录结构相比2.0有很大的改变，之前的build和config文件夹没有了，如果要像以前那样配置webpack的参数，只需要在项目的根目录下新建vue.config.js 文件注意是根目录，不是src目录。如果你还想继续使用vue-cli2.x的创建方法可以这样做：123$ npm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同$ vue init webpack my-project vue-cli 2.x项目目录说明123456789101. build文件夹中放的是webpack的配置文件，其中webpack.base.conf.js是通用配置，webpack.dev.conf.js是我们在开发项目的时候启动项目的配置，webpack.prod.conf.js是我们开发完成之后，最后打包的时候的配置2. config文件夹里是将一些配置抽离出来的文件，例如开发服务器的配置3. static是我们的静态文件目标 我们把一些文件放入到static目录中之后就可以使用服务器的绝对地址来引入这些文件了，不用担心打包输出文件后目录结构变化带来的影响4. src是我们的开发目录 webpack是一个模块化打包工具，开发的时候可能会写很多模块，这些模块都会互相依赖，最终需要放入到一个文件中，这个文件就是我们的入口文件，而vue项目中一般有一个入口文件就好了 main.js是我们的入口文件 我们在开发vue项目的时候，一般情况下都是这样的： 在外面有一个根实例，根实例里面又有一个根组件，其他的所有的组件都会直接或者间接的引入到根组件中 在main.js里我们会把引入全局工具、进行全局配置的代码在这里运行或者引入 vue-cli 3 创建项目步骤： 第一个是默认模板；第二个是自定义选择；第一个会默认安装基本模板、选择第二个进入以下选择 方向键控制空格选择 Enter进入下一步 路由是否选择history模式 ,否的话是哈希路由，选择css预处理器 sass和less 选择代码规范配置 选择保存时候进行代码检测，在后面也可以关闭检测 会保存在根目录下，然后会有一步是否保存本次配置，可以选择保存此次配置作为下次开发的模板。vue-cli 3.x需要在根目录也就是与src同级的目录创建一个vue.config.js用来配置webpack，代理等参数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// vue.config.js 配置说明// 这里只列一部分，具体配置惨考文档module.exports = &#123; // baseUrl type:&#123;string&#125; default:'/' 从 Vue CLI 3.3 起已弃用，请使用publicPath // 将部署应用程序的基本URL // 默认情况下，Vue CLI假设您的应用程序将部署在域的根目录下。 // https://www.my-app.com/。如果应用程序部署在子路径上，则需要使用此选项指定子路径。例如，如果您的应用程序部署在https://www.foobar.com/my-app/，集baseUrl到'/my-app/'.//这个值也可以被设置为空字符串 ('') 或是相对路径 ('./') 修改这个 那么打包出来的index.html里的路径也是根据这个改变 publicPath: "./", // outputDir: 在npm run build时 生成文件的目录 type:string, default:'dist' outputDir: 'dist', // pages:&#123; type:Object,Default:undfind &#125; /* 构建多页面模式的应用程序.每个“页面”都应该有一个相应的JavaScript条目文件。该值应该是一 个对象，其中键是条目的名称，而该值要么是指定其条目、模板和文件名的对象，要么是指定其条目 的字符串， 详情请看下面多页面配置 注意：请保证pages里配置的路径和文件名 在你的文档目录都存在 否则启动服务会报错的*/ pages: &#123; //此处如果打包后打开显示空白那就直写 entry 其他不写 console: &#123; // 应用入口配置，相当于单页面应用的main.js，必需项 entry: 'src/modules/console/console.js', // 应用的模版，相当于单页面应用的public/index.html，可选项，省略时默认与模块名一致 // template: 'public/console.html', // 编译后在dist目录的输出文件名，可选项，省略时默认与模块名一致 // filename: 'console.html', // 标题，可选项，一般情况不使用，通常是在路由切换时设置title // 需要注意的是使用title属性template 中的 title 标签需要是 &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; // title: 'console page', // 包含的模块，可选项 // chunks: ['console'] &#125;, // 只有entry属性时，直接用字符串表示模块入口 client: 'src/modules/client/client.js' &#125;, // lintOnSave：&#123; type:Boolean default:true &#125; 问你是否使用eslint lintOnSave: true, // productionSourceMap：&#123; type:Bollean,default:true &#125; 生产源映射 // 如果您不需要生产时的源映射，那么将此设置为false可以加速生产构建 productionSourceMap: false, // devServer:&#123;type:Object&#125; 3个属性host,port,https // 它支持webPack-dev-server的所有选项 devServer: &#123; port: 8085, // 端口号 host: 'localhost', https: false, // https:&#123;type:Boolean&#125; open: true, //配置自动启动浏览器 // proxy: 'http://localhost:4000' // 配置跨域处理,只有一个代理 proxy: &#123; '/api': &#123; target: '&lt;url&gt;', ws: true, changeOrigin: true &#125;, '/foo': &#123; target: '&lt;other_url&gt;' &#125; &#125;, // 配置多个代理 &#125;&#125; 基本上以上的vue.config.js配置能解决大部分的问题如果还需要修改就根据具体的业务进行修改。Vue cli 3 多页面配置创建多页面应用首先，安装两个插件，vue-router和vue-wechat-title。vue-router不解释了，vue-wechat-title为单页面应用修改标题的插件.(就是标签页的名字) 创建模块在src下创建目录modules，在modules下创建两个模块console和client； 在public下添加模版console.html和clien.html(直接复制原有的index.html即可，然后修改里面唯一div的id) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="console"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253///模块里的 js vue文件与 app.vue main.js 对比模块console 的 console.js//import Vue from &apos;vue&apos;import Console from &apos;./Console.vue&apos;import router from &apos;./router&apos;Vue.use(require(&apos;vue-wechat-title&apos;))new Vue(&#123; router, render: h =&gt; h(Console)&#125;).$mount(&apos;#console&apos;)//main.js//import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;)////console.vue&lt;template&gt; &lt;div id=&quot;console&quot; v-wechat-title=&quot;$route.meta.title&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;console&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;////app.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 应用路由配置通过vue-router为应用配置路由，以console模块为例，在router.js中添加路由配置： 123456789101112import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;//需要加路由的话就像单页面那样配置Vue.use(VueRouter)const routes = [ &#123; path: &apos;/&apos;, name: &apos;login&apos;, component: r =&gt; &#123; require([&apos;./login/Login&apos;], r) &#125;, meta: &#123; title: &apos;console 登录&apos; &#125;&#125;]export default new VueRouter(&#123; routes: routes&#125;) 应用title跟随路由切换12345678910import Vue from 'vue'import Console from './Console.vue'import router from './router'Vue.use(require('vue-wechat-title'))new Vue(&#123; router, render: h =&gt; h(Console)&#125;).$mount('#console') 在console.vue中添加v-wechat-title指令，console.vue内容为： 12345678910111213141516&lt;template&gt; //如此路由里就能根据 router.js 里配置的 title 进行切换 &lt;div id=&quot;console&quot; v-wechat-title=&quot;$route.meta.title&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;console&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 至此，针对console模块的配置完成，对client模块做相同配置即可。 项目结构图 模块里的文件可完全复制app.vue和main.js修改。 参考文档1 参考文档2 axios踩坑记录+拦截器使用+vue cli代理跨域proxy+webpack打包部署到服务器https://www.cnblogs.com/goloving/p/8901960.html (由于还未在项目中实战使用先记到这里，等使用过后再来更新)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue整理文档（2. X脚手架版本2. X)]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fvue%2F</url>
    <content type="text"><![CDATA[Vue Vue是一个前端js框架， 由尤雨溪（尤小右）开发， 是个人项目 切图仔-前端工程师， UI设计师 网页分为动态网页和静态网页， 动态网页指的就是页面中渲染的是不断变化的动态数据 SSH thinkphp dijango / angularJS (mvc….) Vue近几年来特别的受关注， 三年前的时候angularJS霸占前端JS框架市场很长时间， 接着react框架横空出世， 因为它有一个特性是虚拟DOM, 从性能上碾轧angularJS, 这个时候， vue1.0悄悄的问世了， 它的优雅， 轻便也吸引了一部分用户， 开始收到关注， 16年中旬， VUE2.0问世， 这个时候vue不管从性能上， 还是从成本上都隐隐超过了react, 火的一塌糊涂， 这个时候， angular开发团队也开发了angular2.0版本， 并且更名为angular, 吸收了react、 vue的优点， 加上angular本身的特点， 也吸引到很多用户， 目前已经迭代到5.0了。 学习vue是现在前端开发者必须的一个技能。 前端js框架到底在干嘛， 为什么要用js框架帮助开发者写js逻辑代码， 在开发应用的时候js的功能划分为如下几点： 渲染数据 操作dom(写一些效果） 操作cookie等存储机制api… 在前端开发中， 如何高效的操作dom、 渲染数据是一个前端工程师需要考虑的问题， 而且当数据量大， 流向较乱的时候， 如何正确使用数据， 操作数据也是一个问题 而js框架对上述的几个问题都有自己趋于完美的解决方案， 开发成本降低。 高性能高效率。 唯一的缺点就是需要使用一定的成本来学习。 Vue官网介绍vue是渐进式JavaScript框架 vue的主张较弱 “渐进式框架”和“自底向上增量开发的设计”是Vue开发的两个概念 Vue可以在任意其他类型的项目中使用， 使用成本较低， 更灵活， 主张较弱， 在Vue的项目中也可以轻松融汇其他的技术来开发， 并且因为Vue的生态系统特别庞大， 可以找到基本所有类型的工具在vue项目中使用 特点： 易用（使用成本低）， 灵活（生态系统完善， 适用于任何规模的项目）， 高效（体积小， 优化好， 性能好） Vue是一个MVVM的js框架， 但是， Vue 的核心库只关注视图层， 开发者关注的只是m-v的映射关系 与AngularJS的对比Vue的很多api、 特性都与angularJS相似， 其实是因为Vue在开发的时候借鉴了很多AngularJS中的特点， 而AngularJS中固有的缺点， 在Vue中已经解决， 也就是青出于蓝而胜于蓝， Vue的学习成本比AngularJS低很多， 因为复杂性就低 AngularJS是强主张的， 而Vue更灵活 Vue的数据流是单向的， 数据流行更清晰 Angular里指令可以是操作dom的， 也可以封装一段结构逻辑代码， 例如： 广告展示模块 Vue中的指令只是操作dom的， 用组件来分离结构逻辑 AngularJS的性能比不上Vue Vue的使用Vue不支持IE8， 因为使用了ES5的很多特性 可以直接通过script标签来引入vue.js, 有开发版本和生产版本， 开发版本一般我们在开发项目的时候引入， 当最后开发完成上线的时候引入生产版本， 开发版本没有压缩的， 并且有很多提示， 而生产版本全部删掉了 在Vue中提供了一个脚手架（命令行工具）可以帮我们快速的搭建基于webpack的开发环境。 .. Vue的实例每一个应用都有一个根实例， 在根实例里我们通过组件嵌套来实现大型的应用 也就是说组件不一定是必须的， 但是实例是必须要有的 在实例化实例的时候我们可以传入一个； 配置项， 在配置项中设置很多属性方法可以实现复杂的功能 在配置中可以设置el的属性， el属性代表的是此实例的作用范围 在配置中同过设置data属性来为实例绑定数据 mvc/mvvm阮大神博客 mvc 分为三层， 其实M层是数据模型层， 它是真正的后端数据在前端js中的一个映射模型， 他们的关系是： 数据模型层和视图层有映射关系， model改变， view展示也会更改， 当view产生用户操作或会反馈给controller, controller更改model, 这个时候view又会进行新的数据渲染 作业： 能说清楚MVC, MVP, MVVM的区别， 能画出三种图 这是纯纯的MVC的模式， 但是很多框架都会有一些更改 前端mvc框架， 如angularjs, backbone: 会发现， 用户可以直接操作controller(例如用户更改hash值， conrtoller直接监听hash值变化后执行逻辑代码， 然后通知model更改） 控制器可以直接操作view, 如果， 让某一个标签获得进入页面获得焦点， 不需要model来控制， 所以一般会直接操作（angularJS, 指令） view可以直接操作model （数据双向绑定） MVP: mvp view和model不能直接通信， 所有的交互都由presenter来做， 其他部分的通信都是双向的 view较薄 ， presenter较为厚重 MVVM: mvvm MVVM和MVP及其相似， 只是view和viewmodel的通信是双向绑定， view的操作会自动的像viewmodel通过 v-for这是一个指令， 只要有v-的就是指令（directive 操作dom ） 在vue中可以通过v-for来循环数据的通知循环dom, 语法是item in/of items, 接收第二个参数是索引 (item, index) of items, 还可以循环键值对， 第一个参数是value, 第二个是key, 第三个依然是索引 v-on在vue中还有v-on来为dom绑定事件， 在v-on: 后面加上要绑定的事件类型， 值里可以执行一些简单javascript表达式： ++ – = … 可以将一些方法设置在methods里， 这样就可以在v-on:click的值里直接写方法名字可以， 默认会在方法中传入事件对象， 当写方法的时候加了（)就可以传参， 这个时候如果需要事件对象， 那就主动传入$event v-on绑定的事件可以是任意事件， v-on:可以缩写为@ 为什么在 HTML 中监听事件？ 你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。 但不必担心， 因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上， 它不会导致任何维护上的困难。 实际上， 使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件， 你的 ViewModel 代码可以是非常纯粹的逻辑， 和 DOM 完全解耦， 更易于测试。 当一个 ViewModel 被销毁时， 所有的事件处理器都会自动被删除。 你无须担心如何自己清理它们。 模板语法1234567891011在vue中， 我们使用mustache插值(&#123; &#123;&#125;&#125;) 来将数据渲染在模板中使用v - once指令可以控制只能插入一次值， 当数据变化的时候， 模板对应的视图不更新使用v - html指令可以解析html格式的数据在html标签属性里不能使用mustache插值， 这个时候给元素添加动态属性的时候使用v - bind来绑定属性， 可以缩写成: 在使用v - bind绑定class和内联样式的时候， vue做了一些优化， 可以使用对象语法和数组的语法来控制 防止表达式闪烁： v-cloak 给模板内的元素添加v - cloak属性后， 元素在vue没有加载完的时候就有这个属性， 当vue加载完成后这个属性就消失了， 所以我们可以给这个属性设置css样式为隐藏 1234&lt; style &gt; [v - cloak] &#123; visibility: hidden; &#125; &lt; /style&gt; v-text/v-html v - text会指定将模板内元素的textContent属性替换为指令值所代表的数据， 也可以用于防止闪烁 v - html可以解析标签， 更改元素的innerHTML， 性能比v - text较差 v-pre 跳过元素和其子元素的编译过程， 可以用来显示mustache vue-resource基于Promise的HTTP库 这是一款vue的插件， 可以用来进行数据交互， 支持的请求方式： GET/POST/JSONP/OPTIONS… 这个插件官方宣布不在更新维护， 也就是说尽量不要使用， 推荐我们使用axios 计算属性、 监听有的时候我们需要在模板中使用数据a, 这个时候就需要用到表达式， 但是有的地方我们需要对a数据进行一些简单的处理后才能使用， 那么我们就会在表达式中写一些js逻辑运算 123456&lt; div id = &quot;example&quot; &gt; &#123; &#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; &lt; /div&gt; 这样我们的维护就会非常困难， 也不便于阅读 那め我们就可以在methods里设置一个方法， 在模板的表达式中使用这个方法 1234567&lt; p &gt; Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot; &lt; /p&gt;// 在组件中methods: &#123; reversedMessage: function() &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 但是这个时候， 只要vm中有数据变化， 这个变化的数据可能和我们关注的数据无关， 但是vm都会重新渲染模板， 这个时候表达式中的方法就会重新执行， 大大的影响性能 这个时候其实我们可以使用监听器里完成： 在vm实例中设置watch属性， 在里面通过键值对来设置一些监听， 键名为数据名， 值可以是一个函数， 这个函数在数据改变之后才会执行， 两个参数分别是性格前的值和更改后的值 123a: function(val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal)&#125; 值还可以是一个方法名字，当数据改变的时候这个方法会执行 当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听： 123456c: &#123; deep: true, handler: function(val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal) &#125;&#125;, 监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了 123456num: &#123; immediate: true, handler: function(val) &#123; this.nums = val * 2 &#125;&#125; 我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂 watch还可以通过实例对象直接使用:vm.$watch，返回一个取消监听的函数，这个函数执行之后会取消监听 我们一般都会用到一个叫计算属性的东西来解决： 计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发送变化的时候，新数据也会发送变化 与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据 计算属性也拥有getter和setter，默认写的是getter，设置setter执行可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性 123456789xm: &#123; get: function() &#123; //getter 当依赖改变后设置值的时候 return this.xing + &apos;丶&apos; + this.ming &#125;, set: function(val) &#123; //setter 当自身改变后执行 this.xing = val.split(&apos;丶&apos;)[0] this.ming = val.split(&apos;丶&apos;)[1] &#125;&#125; 过滤器vue中可以设置filter(过滤器）来实现数据格式化， 双花括号插值和 v-bind 表达式中使用 vue1.0的有默认的过滤器， 但是在2.0的时候全部给去掉了 所以在vue中如果想要使用过滤器就需要自定义 自定义的方法有两种： 全局定义和局部定义， 全局定义的过滤器在任意的实例、 组件中都可以使用， 局部定义就是在实例、 组件中定义， 只能在这个实例或组件中使用 全局定义 Vue.filter(name, handler) name是过滤器的名字， handler是数据格式化处理函数， 接收的第一个参数就是要处理的数据， 返回什么数据， 格式化的结果就是什么 在模板中通过 | (管道符) 来使用, 在过滤器名字后面加（） 来传参， 参数会在handler函数中第二个及后面的形参来接收 12345678910&lt; p &gt; &#123; &#123; msg | firstUpper(3, 2) &#125;&#125; &lt; /p&gt;Vue.filter(&apos;firstUpper&apos;, function(value, num = 1, num2) &#123; console.log(num2) return value.substr(0, num).toUpperCase() + value.substr(num).toLowerCase()&#125;) 局部定义 在实例、 组件的配置项中设置 filters， 键名为过滤器名， 值为handler 123456filters: &#123; firstUpper: function(value, num = 1, num2) &#123; console.log(num2) return value.substr(0, num).toUpperCase() + value.substr(num).toLowerCase() &#125;&#125; 注意： 过滤器只能在mustache插值、 v - bind里使用， 其他的指令等地方都不能用 作业： 自定义类似于angularJS中的currency、 order、 filter过滤器 条件渲染在Vue中可以使用v-if来控制模板里元素的显示和隐藏， 值为true就显示， 为false就隐藏 v-if控制的是是否渲染这个节点 当我们需要控制一组元素显示隐藏的时候， 可以用template标签将其包裹， 将指令设置在template上， 等等vm渲染这一组元素的时候， 不会渲染template 当有else分支逻辑的时候， 可以给该元素加上v-else指令来控制， v-else会根据上面的那个v-if来控制， 效果与v-if相反， 注意， 一定要紧挨着 还有v-else-if指令可以实现多分支逻辑 1234567891011121314151617181920212223242526272829&lt; input type = &quot;text&quot;v - model = &quot;mode&quot; &gt; &lt; template v - if = &quot;mode==&apos;A&apos;&quot; &gt; &lt;h1 &gt; 1. title &lt; /h1&gt; &lt;p &gt; 我的第一个P标签 &lt; /p&gt; &lt; / template &gt; &lt; template v - else - if = &quot;mode==&apos;B&apos;&quot; &gt; &lt;h1 &gt; 2. title &lt; /h1&gt; &lt;p &gt; 我的第二个P标签 &lt; /p&gt; &lt; / template &gt; &lt; template v - else - if = &quot;mode==&apos;C&apos;&quot; &gt; &lt;h1 &gt; 3. title &lt; /h1&gt; &lt;p &gt; 我的第三个P标签 &lt; /p&gt; &lt; / template &gt; &lt; template v - else &gt; &lt; p &gt; 不好意思， 输入有误 &lt; /p&gt; &lt; / template &gt; 需要注意的另一个地方是： Vue 会尽可能高效地渲染元素， 通常会复用已有元素而不是从头开始渲染。 这样确实能使Vue变得更快， 性能更高， 但是有的时候我们需要让实例去更新dom而不是复用， 就需要给dom加上不同的key属性， 因为vue在判断到底渲染什么的时候， 包括哪些dom可以复用， 都会参考key值， 如果dom表现基本一致， 符合复用的条件， 但是key值不同， 依然不会复用 Vue还提供了v-show指令， 用法和v-if基本一样， 控制的是元素的css中display属性， 从而控制元素的显示和隐藏 ， 不能和v-else配合使用， 且不能使用在template标签上， 因为template不会渲染， 再更改它的css属性也不会渲染， 不会生效 v-if vs v-showv-if 是“真正”的条件渲染， 因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的： 如果在初始渲染时条件为假， 则什么也不做——直到条件第一次变为真时， 才会开始渲染条件块。相比之下， v-show 就简单得多——不管初始条件是什么， 元素总是会被渲染， 并且只是简单地基于 CSS 进行切换。一般来说， v-if 有更高的切换开销， 而 v-show 有更高的初始渲染开销。 因此， 如果需要非常频繁地切换， 则使用 v-show 较好； 如果在运行时条件很少改变， 则使用 v-if 较好。 mixin在Vue中， 我们可以通过定义多个mixin来实现代码抽离复用， 便于维护， 提升页面的逻辑性 要注意的是： data属性不要使用mixin, 因为从逻辑上来说， 每一个实例、 组件的数据都应该是独立的 一个mixin其实就是一个纯粹的对象， 上面挂载着抽离出来的配置， 在某一个实例中， 通过mixins选项（数组）导入后， 此实例就拥有导入的mixin的配置 且导入的配置不会覆盖原有的， 而是合并到一起 虚拟dom频繁且复杂的dom操作通常是前端性能瓶颈的产生点， Vue提供了虚拟dom的解决办法 虚拟的DOM的核心思想是： 对复杂的文档DOM结构， 提供一种方便的工具， 进行最小化地DOM操作。 这句话， 也许过于抽象， 却基本概况了虚拟DOM的设计思想 (1) 提供一种方便的工具， 使得开发效率得到保证(2) 保证最小化的DOM操作， 使得执行效率得到保证 也就是说， 虚拟dom的框架/工具都是这么做的： 根据现有的真实dom来生成一个完整的虚拟dom树结构 当数据变化， 或者说是页面需要重新渲染的时候， 会重新生成一个新的完整的虚拟dom 拿新的虚拟dom来和旧的虚拟dom做对比（使用diff算法）， 。 得到需要更新的地方之后， 更新内容 这样的话， 就能大量减少真实dom的操作， 提高性能 组件化模块化就是将系统功能分离成独立的功能部分的方法， 一般指的是单个的某一种东西， 例如js、 css 而组件化针对的是页面中的整个完整的功能模块划分， 组件是一个html、 css、 js、 image等外链资源， 这些部分组成的一个聚合体 优点： 代码复用， 便于维护 划分组件的原则： 复用率高的， 独立性强的 组件应该拥有的特性： 可组合， 可重用， 可测试， 可维护 组件在vue中， 我们通过Vue.extend来创建Vue的子类， 这个东西其实就是组件 也就是说Vue实例和组件的实例有差别但是差别不带， 因为毕竟一个是父类一个是子类 一般的应用， 会拥有一个根实例， 在根实例里面都是一个一个的组件 因为组件是要嵌入到实例或者父组件里的， 也就是说， 组件可以互相嵌套， 而且， 所有的组件最外层必须有一个根实例， 所以组件分为： 全局组件和局部组件 全局组件在任意的实例、 父级组件中都能使用， 局部组件只能在创建自己的父级组件或者实例中使用 组件通过不同的注册方法成为全局、 局部组件 创建组件： 1Vue.extend(options) 全局注册： 1234var App = Vue.extend(&#123; template: &quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;&#125;)Vue.component(&apos;my-app&apos;, App) 简便写法： 1234// 创建组件构造器和注册组件合并一起 Vue.component(&apos;hello&apos;, &#123; //Vue会自动的将此对象给Vue.extend template: &quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;&#125;) 组件通过template来确定自己的模板， template里的模板必须有根节点， 标签必须闭合 组件的属性挂载通过： data方法来返回一个对象作为组件的属性， 这样做的目的是为了每一个组件实例都拥有独立的data属性 局部注册： 123456new Vue(&#123; el: &quot;#app&quot;, components: &#123; &apos;my-app&apos;: App &#125;&#125;) 简便写法： 123456data: &#123;&#125;, components: &#123; &apos;hello&apos;: &#123; template: &quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot; &#125; &#125; 在实例或者组件中注册另一个组件， 这个时候， 被注册的组件只能在注册它的实例或组件的模板中使用， 一个组件可以被多个组件或实例注册 注意浏览器规则因为vue在解析模板的时候会根据某些html的规则， 例如， 在table里只能放tr, td, th..， 如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件 1234&lt; table id = &quot;app&quot; &gt; &lt; tr is = &quot;hello&quot; &gt; &lt; /tr&gt; &lt; / table &gt; template我们可以在html的某个地方通过template标签来定义组件的模板， 在组件的template属性中通过选择器指定对应的template标签内容就可以了， 注意， 需要给template标签加id来指定 12345678910&lt; template id = &quot;my-hello&quot; &gt; &lt; div &gt; &lt; h1 &gt; hello world &lt; /h1&gt; &lt;p &gt; hahahah &lt; /p&gt; &lt; / div &gt; &lt; /template&gt;//组件中template: &quot;#my-hello&quot; is切换在实例、 组件的模板中的某一个标签上， 可以通过is属性来指定为另一个目标的组件， 这个时候我们一般会使用component标签来占位、 设置is属性来指定目标组件 1234567891011121314&lt; component: is = &quot;type&quot; &gt; &lt; /component&gt;//组件中data: &#123; type: &apos;aaa&apos; &#125;, components: &#123; &apos;aaa&apos;: &#123; template: &quot;&lt;h1&gt;AAAAAAAAAAAAA&lt;/h1&gt;&quot; &#125;, &apos;bbb&apos;: &#123; template: &quot;&lt;h1&gt;BBBBBBBBBBBBB&lt;/h1&gt;&quot; &#125; &#125; 组件嵌套应用中划分的组件可能会很多， 为了更好的实现代码复用， 所以必然会存在组件的嵌套关系 组件设计初衷就是要配合使用的， 最常见的就是形成父子组件的关系： 组件 A 在它的模板中使用了组件 B. prop 传递数据组件实例的作用域是孤立的， 父组件不能直接使用子组件的数据， 子组件也不能直接使用父组件的数据 父组件在模板中使用子组件的时候可以给子组件传递数据 1&lt; bbb money = &quot;2&quot; &gt; &lt; /bbb&gt; 子组件需要通过props属性来接收后才能使用 12&apos;bbb&apos;: &#123; props: [&apos;money&apos;] 如果父组件传递属性给子组件的时候键名有‘-‘， 子组件接收的时候写成小驼峰的模式 1234&lt; bbb clothes - logo = &apos;amani&apos;clothes - price = &quot;16.58&quot; &gt; &lt; /bbb&gt;////props: [&apos;clothesLogo&apos;, &apos;clothesPrice&apos;] 我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。 每当父组件的数据变化时， 该变化也会传导给子组件 单向数据流Prop 是单向绑定的： 当父组件的属性变化时， 将传导给子组件， 但是反过来不会。 这是为了防止子组件无意间修改了父组件的状态， 来避免应用的数据流变得难以理解。 另外， 每次父组件更新时， 子组件的所有 prop 都会更新为最新值。 这意味着你不应该在子组件内部改变 prop. 如果你这么做了， Vue 会在控制台给出警告。 在两种情况下， 我们很容易忍不住想去修改 prop 中数据： Prop 作为初始值传入后， 子组件想把它当作局部数据来用； Prop 作为原始数据传入， 由子组件处理成其它数据输出。 对这两种情况， 正确的应对方式是： 定义一个局部变量， 并用 prop 的值初始化它： 12345678910111213props: [&apos;initialCounter&apos;], data: function() &#123; return &#123; counter: this.initialCounter &#125; &#125;//定义一个计算属性，处理 prop 的值并返回：props: [&apos;size&apos;], computed: &#123; normalizedSize: function() &#123; return this.size.trim().toLowerCase() &#125; &#125; 注意在 JavaScript 中对象和数组是引用类型， 指向同一个内存空间， 如果 prop 是一个对象或数组， 在子组件内部改变它会影响父组件的状态。 prop验证我们可以为组件的 prop 指定验证规则。 如果传入的数据不符合要求， Vue 会发出警告。 这对于开发给他人使用的组件非常有用 验证主要分为： 类型验证、 必传验证、 默认值设置、 自定义验证 1234567891011121314151617181920212223242526props: &#123; //类型验证: str: String, strs: [String, Number], //必传验证 num: &#123; type: Number, required: true &#125;, //默认数据 bool: &#123; type: Boolean, // default:true, default: function() &#123; return true &#125; &#125;, //自定义验证函数 nums: &#123; type: Number, validator: function(value) &#123; return value % 2 == 0 &#125; &#125;&#125; 当父组件传递数据给子组件的时候， 子组件不接收， 这个数据就会挂载在子组件的模板的根节点上 slotvue里提供了一种将父组件的内容和子组件的模板整合的方法： 内容分发， 通过slot插槽来实现 匿名插槽 123&lt; aaa &gt; abc &lt; /aaa&gt;template: &quot;&lt;h1&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/h1&gt;&quot; 在父组件中使用子组件的时候， 在子组件标签内部写的内容， 在子组件的模板中可以通过来使用 具名插槽 父组件在子组件标签内写的多个内容我们可以给其设置slot属性来命名， 在子组件的模板通过通过使用带有name属性的slot标签来放置对应的slot, 当slot不存在的时候， slot标签内写的内容就出现 12345&lt; my - button &gt; 提交 &lt; /my-button&gt; &lt;my - button &gt; 重置 &lt; /my-button&gt; &lt;my - button &gt; &lt; /my-button&gt;template: &quot;&lt;button&gt;&lt;slot&gt;按钮&lt;/slot&gt;&lt;/button&gt;&quot; transitionVue提供了transition组件来帮助我们实现过渡效果， 依据就是在控制元素显示隐藏的时候为dom在指定的时刻添加上对应的类名 而我们只要在这些类名里写上对应的css样式 在进入/离开的过渡中， 会有 6 个 class 切换（v代表的是transition的name属性的值）。 v-enter: 定义进入过渡的开始状态。 在元素被插入时生效， 在下一个帧移除。 v-enter-active: 定义过渡的状态。 在元素整个过渡过程中作用， 在元素被插入时生效， 在 transition/animation 完成之后移除。 这个类可以被用来定义过渡的过程时间， 延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。 在元素被插入一帧后生效 (于此同时 v-enter 被删除）， 在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。 在离开过渡被触发时生效， 在下一个帧移除。 v-leave-active: 定义过渡的状态。 在元素整个过渡过程中作用， 在离开过渡被触发后立即生效， 在 transition/animation 完成之后移除。 这个类可以被用来定义过渡的过程时间， 延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。 在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除）， 在 transition/animation 完成之后移除。 如果有多个元素需要用transition-group包裹， 并且需要有key值做标记 animate.css: 引入animate.css之后， 按照下面的写法： 1234567&lt; transitionleave - active - class = &quot;animated fadeOut&quot;enter - active - class = &quot;animated slideInLeft&quot; &gt; &lt; p v - if = &quot;isShow&quot; class = &quot;box&quot; &gt; &lt; /p&gt; &lt; / transition &gt; 渲染函数和jsx在vue中我们可以不用template来指定组件的模板， 而是用render函数来创建虚拟dom结构， 用这种方法优点就是性能高， 缺点就是使用成本高， 代码可读性较低， 可以使用jsx来在render函数中创建， 这样既提高了性能， 又减少了成本 但是， 我们在使用了vue-cli脚手架之后， 因为脚手架中有对template标签转换虚拟dom的处理， 所以， 不需要使用jsx, 我们也能高效的转换为createElement形式 Vue里组件的通信通信： 传参、 控制（A操控B做一个事件）、 数据共享 模式： 父子组件间、 非父子组件 父组件可以将一条数据传递给子组件， 这条数据可以是动态的， 父组件的数据更改的时候， 子组件接收的也会变化 子组件被动的接收父组件的数据, 子组件不要再更改这条数据了 父组件如果将一个引用类型的动态数据传递给子组价的时候， 数据会变成双向控制的， 子组件改数据的时候父组件也能接收到数据变化， 因为子组件改的时候不是在改数据（地址）， 而是在改数据里的内容， 也就是说引用类型数据的地址始终没有变化， 不算改父组件数据 父子间数据共享（ 双向控制）, 基本不会使用， 违背了单向数据流 父组件可以将一个方法传递给子组件， 子组件调用这个方法的时候， 就可以给父组件传递数据 父组件被动的接收子组件的数据 父组件可以将一个事件绑定在子组件的身上， 这个事件的处理程序是父组件某一个方法， 当子组件触发自己的这个被绑定的事件的时候， 相当于触发了父组件的方法 父组件被动的接收子组件的数据 在组件间可以用过ref形成ref链， 组件还拥有一个关系链（$parent, $children, $root), 通过这两种链； 理论来说， 任意的两个组件都可以互相访问， 互相进行通信 任意组件通信， 用的少… event bus 事件总线 小天使 专注于非父子组件的通信， 其实父子组件也可以使用， 只是没有必要 在B组件的某个钩子函数为event_bus绑定一个事件， 事件的处理程序是B想做的事情 在A组件的某一个操作里， 触发event_bus绑定的事件 大量组件间数据共享的时候 vuex 组件的生命周期每一个组件或者实例都会经历一个完整的生命周期， 总共分为三个阶段： 初始化、 运行中、 销毁 实例、 组件通过new Vue() 创建出来之后会初始化事件和生命周期， 然后就会执行beforeCreate钩子函数， 这个时候， 数据还没有挂载ね， 只是一个空壳， 无法访问到数据和真实的dom, 一般不做操作 挂载数据， 绑定事件等等， 然后执行created函数， 这个时候已经可以使用到数据， 也可以更改数据， 在这里更改数据不会触发updated函数， 在这里可以在渲染前倒数第二次更改数据的机会， 不会触发其他的钩子函数， 一般可以在这里做初始数据的获取 接下来开始找实例或者组件对应的模板， 编译模板为虚拟dom放入到render函数中准备渲染， 然后执行beforeMount钩子函数， 在这个函数中虚拟dom已经创建完成， 马上就要渲染， 在这里也可以更改数据， 不会触发updated, 在这里可以在渲染前最后一次更改数据的机会， 不会触发其他的钩子函数， 一般可以在这里做初始数据的获取 接下来开始render, 渲染出真实dom, 然后执行mounted钩子函数， 此时， 组件已经出现在页面中， 数据、 真实dom都已经处理好了， 事件都已经挂载好了， 可以在这里操作真实dom等事情。 .. 当组件或实例的数据更改之后， 会立即执行beforeUpdate, 然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染， 一般不做什么事儿 当更新完成后， 执行updated, 数据已经更改完成， dom也重新render完成， 可以操作更新后的虚拟dom 当经过某种途径调用$destroy方法后， 立即执行beforeDestroy, 一般在这里做一些善后工作， 例如清除计时器、 清除非指令绑定的事件等等 组件的数据绑定、 监听。 .. 去掉后只剩下dom空壳， 这个时候， 执行destroyed, 在这里做善后工作也可以 vue-cli脚手架grunt gulp webpack现在使用前端工程化开发项目是主流的趋势， 也就是说， 我们需要使用一些工具来搭建vue的开发环境， 一般情况下我们使用webpack来搭建， 在这里我们直接使用vue官方提供的， 基于webpack的脚手架工具： vue-cli 安装方法： 123456789#全局安装 vue - clinpm install--global vue - cli# 创建一个基于 webpack 模板的新项目vue init webpack my - project//init之后可以定义模板的类型# 安装依赖， 走你cd my - projectnpm installnpm run dev 模板类型： simple 对应的是一个超级简单的html文件 webpack 在配置的时候可以选择是否需要vue-router 注意的是， 模板创建的时候会询问使用需要使用ESLINT来标准化我们的代码 在脚手架中， 开发目录是src文件夹， build负责打包的， config是负责配置（内置服务器的端口、 proxy代理）， static是静态目录， test是测试 src中main.js是入口文件， 在里面创建了一个根实例， 根实例的模板就是根组件App的模板， 其他的组件都在根组件里面进行嵌套实现。 每一个组件都是一个单文件组件， 这种文件会被webpack利用vue-loader的工具进行编译 template部分负责写组件的模板内容， script中创建组件。 style里写组件的样式 assets目录也是静态目录， 在这个目标中的文件我们使用相对路径引入， 而static目录中的文件使用绝对地址来引入 在style上添加scoped能使这个style里的样式只作用于当前的组件， 不加scoped就是全局样式 习惯于在App.vue根组件的style里写全局样式， 而每个组件的style最好都是局部的 配置sass编译环境 vue-cli没有内置sass编译， 我们需要自己修改配置 下载对应工具： node-sass(4.0.0) sass-loader 在build目录下的webpack.base.conf.js中的module.rule里添加如下配置 1234&#123; test: /\.scss$/, loader: &apos;style-loader!css-loader!sass-loader&apos;&#125; 在需要使用scss代码的组件的style标签中添加 lang=’scss’ vue-router现在的应用都流行SPA应用（single page application) 传统的项目大多使用多页面结构， 需要切换内容的时候我们往往会进行单个html文件的跳转， 这个时候受网络、 性能影响， 浏览器会出现不定时间的空白界面， 用户体验不好 单页面应用就是用户通过某些操作更改地址栏url之后， 动态的进行不同模板内容的无刷新切换， 用户体验好。 Vue中会使用官方提供的vue-router插件来使用单页面， 原理就是通过检测地址栏变化后将对应的路由组件进行切换（卸载和安装） 简单路由实现： 引入vue-router, 如果是在脚手架中， 引入VueRouter之后， 需要通过Vue.use来注册插件 123import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router) 创建router路由器 1new Router(options) 创建路由表并配置在路由器中 123456789var routes = [&#123; path, component &#125; //path为路径，component为路径对应的路由组件]new Router(&#123; routes&#125;) 在根实例里注入router, 目的是为了让所有的组件里都能通过this.$router、 this.$route来使用路由的相关功能api 12345678new Vue(&#123; el: &apos;#app&apos;, router, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 利用router-view来指定路由切换的位置 使用router-link来创建切换的工具， 会渲染成a标签， 添加to属性来设置要更改的path信息， 且会根据当前路由的变化为a标签添加对应的router-link-active/router-link-exact-active(完全匹配成功）类名 123456&lt; router - link to = &quot;main&quot; &gt; main &lt; /router-link&gt; &lt;router - link to = &quot;news&quot; &gt; news &lt; /router-link&gt; .router - link - active &#123; color: red; &#125; 多级路由：在创建路由表的时候， 可以为每一个路由对象创建children属性， 值为数组， 在这个里面又可以配置一些路由对象来使用多级路由， 注意： 一级路由path前加‘/‘ 123456789101112131415161718const routes = [&#123; path: &apos;/main&apos;, component: AppMain &#125;, &#123; path: &apos;/news&apos;, component: AppNews, children: [&#123; path: &apos;inside&apos;, component: AppNewsInside &#125;, &#123; path: &apos;outside&apos;, component: AppNewsOutside &#125; ] &#125;,] 二级路由组件的切换位置依然由router-view来指定（指定在父级路由组件的模板中） 12345&lt; router - link to = &apos;inside&apos; &gt; inside &lt; /router-link&gt; &lt;router - link to = &apos;outside&apos; &gt; outside &lt; /router-link&gt; &lt; router - view &gt; &lt; /router-view&gt; 默认路由和重定向：当我们进入应用， 默认像显示某一个路由组件， 或者当我们进入某一级路由组件的时候想默认显示其某一个子路由组件， 我们可以配置默认路由： 1234&#123; path: &apos;&apos;, component: Main&#125; 当我们需要进入之后进行重定向到其他路由的时候， 或者当url与路由表不匹配的时候： 123456789&#123; path: &apos;&apos;, redirect: &apos;/main&apos;&#125;///...放在最下面&#123; path: &apos;**&apos;, redirect: &apos;/main&apos;&#125;, 命名路由我们可以给路由对象配置name属性， 这样的话， 我们在跳转的时候直接写name:main就会快速的找到此name属性对应的路由， 不需要写大量的urlpath路径了 动态路由匹配有的时候我们需要在路由跳转的时候跟上参数， 路由传参的参数主要有两种： 路径参数、 queryString参数 路由参数需要在路由表里设置 1234&#123; path: &apos;/user/:id&apos;, component: User&#125; 上面的代码就是给User路由配置接收id的参数， 多个参数继续在后面设置 在组件中可以通过this.$route.params来使用 queryString参数不需要在路由表设置接收， 直接设置？ 后面的内容， 在路由组件中通过this.$route.query接收 router-link 组件支持用户在具有路由功能的应用中（点击）导航。 通过 to 属性指定目标地址， 默认渲染成带有正确链接的 标签， 可以通过配置 tag 属性生成别的标签。 。 另外， 当目标路由成功激活时， 链接元素自动设置一个表示激活的 CSS 类名。 router-link的to属性， 默认写的是path(路由的路径）， 可以通过设置一个对象， 来匹配更多 1: to = &apos;&#123;name:&quot;detail&quot;,params:&#123;id:_new.id&#125;,query:&#123;content:_new.content&#125;&#125;&apos; name是要跳转的路由的名字， 也可以写path来指定路径， 但是用path的时候就不能使用params传参， params是传路径参数， query传queryString参数 replace属性可以控制router-link的跳转不被记录\ active-class属性可以控制路径切换的时候对应的router-link渲染的dom添加的类名 编程式导航有的时候需要在跳转前进行一些动作， router-link直接跳转， 需要在方法里使用$router的方法 router.push = router-link:torouter.replace = router-link:to.replacerouter.go() = window.history.go 路由模式路由有两种模式： hash、 history, 默认会使用hash模式， 但是如果url里不想出现丑陋hash值， 在new VueRouter的时候配置mode值为history来改变路由模式， 本质使用H5的histroy.pushState方法来更改url, 不会引起刷新， 但是需要后端进行路由的配置 路由钩子在某些情况下， 当路由跳转前或跳转后、 进入、 离开某一个路由前、 后， 需要做某些操作， 就可以使用路由钩子来监听路由的变化 全局路由钩子： 123456789101112router.beforeEach((to, from, next) =&gt; &#123; //会在任意路由跳转前执行，next一定要记着执行，不然路由不能跳转了 console.log(&apos;beforeEach&apos;) console.log(to, from) // next()&#125;)//router.afterEach((to, from) =&gt; &#123; //会在任意路由跳转后执行 console.log(&apos;afterEach&apos;)&#125;) 单个路由钩子：只有beforeEnter, 在进入前执行， to参数就是当前路由 1234567routes: [&#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125;&#125;] 路由组件钩子： 123456789101112131415beforeRouteEnter(to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！ 能！ 获取组件实例 `this` // 因为当守卫执行前， 组件实例还没被创建 &#125;, beforeRouteUpdate(to, from, next) &#123; // 在当前路由改变， 但是该组件被复用时调用 // 举例来说， 对于一个带有动态参数的路径 /foo/:id, 在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件， 因此组件实例会被复用。 而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave(to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125; 命名视图有时候想同时（同级）展示多个视图， 而不是嵌套展示， 例如创建一个布局， 有 sidebar(侧导航） 和 main(主内容） 两个视图， 这个时候命名视图就派上用场了。 你可以在界面中拥有多个单独命名的视图， 而不是只有一个单独的出口。 如果 router-view 没有设置名字， 那么默认为 default. 12345&lt; router - view class = &quot;view one&quot; &gt; &lt; /router-view&gt; &lt;router - view class = &quot;view two&quot;name = &quot;a&quot; &gt; &lt; /router-view&gt; &lt;router - view class = &quot;view three&quot;name = &quot;b&quot; &gt; &lt; /router-view&gt; 一个视图使用一个组件渲染， 因此对于同个路由， 多个视图就需要多个组件。 确保正确使用 components 配置（带上 s)： 12345678910const router = new VueRouter(&#123; routes: [&#123; path: &apos;/&apos;, components: &#123; default: Foo, //默认的，没有name的router-view a: Bar, b: Baz &#125; &#125;]&#125;) prop将路由与组件解耦在组件中接收路由参数需要this.$route.params.id, 代码冗余， 现在可以在路由表里配置props: true 123456&#123; path: &apos;detail/:id&apos;, component: AppNewsDetail, name: &apos;detail&apos;, props: true&#125; 在路由自己中可以通过props接收id参数去使用了 props:[‘id’] Axios 数据交互工具vue官方宣布在2.0版本中不再对Vue-resource进行维护了， 推荐使用axios工具 注意， axios默认配置不会设置session-cookie, 需要进行配置 axios.defaults.withCredentials = true 详细请看文档 响应式原理因为vue是mvvm的框架， 所以当数据变化的时候， 视图会立即更新， 视图层产生操作后会自动通知vm来更改model, 所以我们可以实现双向数据绑定， 而其中的原理就是实例会将设置的data逐个遍历利用Object.defineProperty给数据生成getter和setter, 当数据变化地方时候setter会监听到并且通知对应的watcher工具进行逻辑运算会更新视图 vuex借鉴了flux和redux的思想， 但是flux和redux是独立且完整的架构， vuex是耦合与vue框架的， 所以使用成本要比flux、 redux低 声明式渲染1234在vue中， 我们可以先在vue实例中声明数据， 然后通过 &#123; &#123;&#125;&#125;等方式渲染在dom中 VuexVuex是vue官方的一款状态管理工具， 什么是状态呢？ 我们在前端开发中有一个概念： 数据驱动， 页面中任意的显示不同， 都应该有一条数据来控制， 而这条数据又叫做state, 状态。 在vue中。 组件间进行数据传递、 通信很频繁， 而父子组件和非父子组件的通信功能也比较完善， 但是， 唯一困难的就是多组件间的数据共享， 这个问题由vuex来处理 Vuex的使用： 创建store: 123456789import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)//可以设置store管理的state/getter，mutations,actionsconst store = new Vuex.Store(&#123;&#125;) 设置state state就是一个纯对象， 上面有一些状态挂载， 而且一个应用应该只有一个数据源： 单一状态树、 唯一数据源 12345import state from &apos;./modules/state&apos;//可以设置store管理的state/getter，mutations,actionsconst store = new Vuex.Store(&#123; state&#125;) 在根实例里配置store 这样， 我们就可以在任意的组件中通过this.$store来使用关于store的api 12345678910import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 在组件中使用state 因为在组件中可以通过this.$store来访问store, 所以我们也可以通过this.$store.state来使用state中管理的数据 12345data() &#123; return &#123; num: this.$store.state.num &#125;&#125;, 但是我们发现， 这样使用的话， 当state的数据更改的时候， vue组件并不会重新渲染， 不会触发组件的相关生命周期函数 也就是说， 如果想要在组件中响应式的使用的时候， 我们需要通过计算属性（computed)来使用 12345computed: &#123; num() &#123; return this.$store.state.num &#125;&#125; 这样的写法很无趣， 而且如果使用的状态较多会产生冗余的感觉， 所以vuex提供了mapState辅助函数， 帮助我们在组件中获取并使用vuex的store中保存的状态 所以我们可以这样写： 1computed: mapState([&apos;num&apos;]), 但是如果组件中已经有了num这个数据了， 而state中的数据名字也叫num就会照成冲突， 这个时候我们可以在组件使用state的时候， 给状态起个别名： 123456computed: mapState(&#123; // _num:&apos;num&apos;,//键名为别名，值字符串代表的是真正的状态 _num(state) &#123; //方法名为别名，函数体里还可以对真正的状态做出一些处理 return state.num &#125;&#125;), 但是， 有的时候我们在组件中还有自己的业务逻辑需要用到计算属性： 1234567891011computed: &#123; a() &#123; return num + 1 &#125;, ...mapState(&#123; // _num:&apos;num&apos;,//键名为别名，值字符串代表的是真正的状态 _num(state) &#123; //方法名为别名，函数体里还可以对真正的状态做出一些处理 return state.num &#125; &#125;),&#125;, getters 有的时候， 我们需要根据state中的某一个状态派生出一个新的状态， 例如， 我们state中有一个num, 在某些组件中需要用到是num的二倍的一个状态， 我们就可以通过getters来创建 12345const getters = &#123; doublenum(state) &#123; return state.num * 2 &#125;&#125; 创建了之后， 在组件中通过this.$store.getters来获取里面的数据 当然vuex也提供了mapGetters辅助函数来帮助我们在组件中使用getters里的状态， 且， 使用的方法和mapState一模一样 使用mutations更改state 我们不能直接在组件中更改state: this.$store.state.num=2, 而是需要使用mutations来更改， mutations也是一个纯对象， 里面包含很多更改state 的方法， 这些方法的形参接收到state, 在函数体里更改， 这时， 组件用到的数据也会更改， 实现响应式。 但是我们也不能直接调用mutations 的方法， 需要使用this.$store.commit来调用， 第一个参数为调用的方法名， 第二げ参数为传递参数 12345const mutations = &#123; increment(state) &#123; state.num++ &#125;&#125; vuex提供了mapMutations方法来帮助我们在组件中调用mutations 的方法， 使用方法和mapState、 mapGetters一样 使用actions来处理异步操作 Action 类似于 mutation, 不同在于： Action 提交的是 mutation, 而不是直接变更状态。Action 可以包含任意异步操作。 也就是说， 如果有这样的需求： 在一个异步处理之后， 更改状态， 我们在组件中应该先调用actions, 来进行异步动作， 然后由actions调用mutation来更改数据 12345678910111213const actions = &#123; [CHANGE_NUM](&#123; commit &#125;) &#123; alert(1) setTimeout(() =&gt; &#123; let num = Math.floor(Math.random() * 10) //调用mitations的方法 commit(CHANGE_NUM, num) &#125;, 1000); &#125;&#125; 如上， actions的方法中可以进行异步的动作， 且形参会接收store, 从中取出commit方法用以调用mutations的方法 在组件中通过this.$store.dispatch方法调用actions的方法 当然也可以使用mapMutations来辅助使用 组件使用数据且通过异步动作更改数据的一系列事情： 生成store, 设置state 在根实例中注入store 组件通过计算属性或者mapState来使用状态 用户产生操作， 调用actions的方法， 然后进行异步动作 异步动作之后， 通过commit调用mutations的方法 mutations方法被调用后， 更改state state中的数据更新之后， 计算属性重新执行来更改在页面中使用的状态 组件状态被更改。.. 创建新的虚拟dom…… 组件的模板更新之后重新渲染在dom中 vuex的使用：目前市场上有两种使用vuex的情况， 第一种： 将需要共享、 需要管理的状态放入vuex中管理， 也就是说在必要时使用 第二种： 将所有的数据都交由vuex管理， 由vuex来承担更多的责任， 组件变得更轻量级， 视图层更轻 #####自定义指令 在实现回到顶部功能的时候， 我们写了一个backTop组件， 接下来需要通过监听window.scroll事件来控制这个组件显示隐藏 因为可能会有其他的组件会用到这样的逻辑， 所以将此功能做成一个自定义指令： 根据滚动的距离控制一个数据为true还是为false( v - scroll - show) 问题： 唯一需要注意的是， 在指令的钩子函数中我们可以访问到el, 也就是使用指令的标签， 但是我们不能直接更改value( 指令的值所代表的数据） 所以我们使用引用类型来进行地址的传递来解决这个问题 接下来有写了一个v - back - top指令， 就是将回到顶部功能做成一个指令， 哪个组件或者dom需要使用到回到顶部， 就加上这个指令就可以， 设置不同的参数来控制在不同的情况下触发 Vue的组件库组件库就是通用组件的集合 pc: element - ui iview mobile: mint - ui nextTick当我们在使用一些插件的时候， 经常需要在dom更新完成后进行必要操作， 但是在vue中提供的api只有updated钩子函数， 而在这个函数里， 任意数据的变化导致的dom更新完成都会触发， 所以很可能会造成无关数据的影响， 而使用监听的话只能监听到数据的变化， 此时dom还没有更新， 我们只能强行使用setTimeout来处理 这里推荐大家使用nextTick全局方法：在下次 DOM 更新循环结束之后执行延迟回调。 在修改数据之后立即使用这个方法， 获取更新后的 DOM. eq: getBillBoards() { axios.get(this.$root.config.host + &apos;mz/v4/api/billboard/home&apos;, { params: { __t: Date.now() } }).then(res =&gt; { console.log(res.data.data.billboards) this.billboards = res.data.data.billboards //当数据更新，dom循环完成后，执行回调 Vue.nextTick(function() { new Swiper(&apos;.app-home-banner&apos;, { loop: true }) }) }) } var f = function(v) { return v; }var f = v =&gt; {} keep - alive在component组件、 router - view外面包裹上keep - alive的话， 就会对组件进行缓存， 当切换回来的时候， 组件会立即渲染， 理论来说， 切换组件的时候其实会把上一个组件销毁， 使用了keep - alive则不会 设置include、 exclude属性控制有选择的缓存 include匹配到的组件会被缓存， exclude匹配到的不会被缓存 值可以为逗号隔开的字符串include = ‘a, b’;正则： include = ‘/a|b/‘;数组： include = [‘a’, ‘b’] 使用keep - alive缓存的组件连带它的子组件们都会拥有activated、 deactivated钩子函数， 会在切换回来和要切换出去的时候触发 比如， main做了缓存， 但是main的banner我们希望每次都去重新获取数据， 所以就在banner的activated里获取数据 Vue试题分析 v - for可以实现数据遍历显示， 不仅可以遍历数组， 也可以遍历对象， 还可以从数值中取值： v - for = &apos;n in 10&apos; n会打印1 - 10 vue的生命周期钩子： 通用： beforeCreate / created / beforeMount / mounted / beforeUpdate / updated / beforeDestroy / destroyed 路由守卫： beforeRouteEnter / beforeRouteUpdate(2.2 新增） / beforeRouteLeave keep - alive: activated / deactivated v - if v - show v - if是真正的条件渲染， 会确保在切换中条件块内的事件监听、 子组件都会适当的被销毁和重建 v - show总是将节点渲染在dom中， 只是基于css: display来控制节点的显示和隐藏 v - if有更高的切换开始， v - show有更高的初始渲染开销 v - if是惰性的， 初始条件为假， 就不会渲染 axios相关 axios请求的时候不会带上cookie, 不会影响带宽， 可以通过withCredentials: true来设置 对axios 的请求头进行设置： axios.defaults.headers = { &apos;Content-Type&apos;: &apos;...&apos; } vue2 .0 不在更新维护vue - resource, 官方推荐使用axios axios拦截器可以拦截请求和响应， 在then、 catch之前拦截 组件实例的作用域是孤立的， 意味着不能（ 不应该） 在子组件模板里直接引用父组件的数据， 要让子组件使用父组件数据的话， 需要通过props来将父组件的数据传递给子组件， 子组件不能也不应该修改父组件传入的数据， 但是可以通过传入引用类型的数据来实现数据共享 为了让组件可以组合， 我们需要一种方式来混合父组件的内容与子组件自己的模板。 这个过程被称为内容分发（即 Angular 用户熟知的“ transclusion”)。 Vue.js 实现了一个内容分发 API, 参照了当前 Web Components 规范草案， 使用特殊的 &lt; slot &gt; 元素作为原始内容的插槽。 a - template: &lt; p &gt; hello world &lt; /p&gt; &lt; b &gt; &lt; h1 &gt; hello world &lt; /h1&gt; &lt; / b &gt; b - template: &lt; slot &gt; &lt; /slot&gt; .... 如果把切换出去的组件保存在内存中， 保留状态避免重新渲染， 可以使用keep - alive include exclude 注册方式： 全局： Vue.component(name, Vue.extend({})) 局部： { components: { name: Vue.extend({}) } } 事件总线实现非父子组件通信 //创建bus let bus = new Vue() //a new Vue({ template: &apos;...&apos;, mounted() { bus.$on(&apos;emit-a&apos;, function() { alert(1) }) } }) //b new Vue({ template: &apos;...&apos;, methods: { emitA() { bus.$emit(&apos;emit-a&apos;) } } })//当b组件的emitA方法被调用的时候， A组件就会执行alert(1） methods和计算属性的区别 假设我们有一个数据为num, 还希望拥有一个数据为doublenum, 而且希望doublenum的值永远都是num的二倍 方法： 1234567891011121314151617181920212223242526* 因为是直接显示在模板中， 也就是说， 我们可以来一个doublenum的方法， 这个方法返回num的二倍， 将这个方法放到模板中的某个地方执行 &#123; &#123; doublenum() &#125;&#125;但是， 当无关的例如一个str的数据更改的时候， 组件会重新创建虚拟dom树， 与上一次的虚拟dom树对比之后重新渲染， 这个时候在重新渲染模板的时候doublenum函数会被再次的调用， 造成不必要的性能浪费 * 创建一个doublenum数据， 使其初始值为num的二倍， 然后利用watch来监听这两个数据， 在改变的时候更改对应的数据， 但是需要初始的为doublenum赋值为num的二倍， 如果num是动态获取到的， doublenun赋值会更繁琐 * computed计算数据， 我们可以利用computed来创建一条新的doublenum数据。 并且设置它的getter和setter, 并与num建立关系， 且computed会缓存， 在重新渲染的时候， 不会重新执行getter和settercomputed: &#123; doublenum: &#123; get() &#123; return this.num * 2 &#125;, set(val) &#123; this.num = val / 2 &#125; &#125;&#125; 绑定class的对象语法和数组语法 =&gt; =&gt; data(){ return { c: &apos;c&apos; } } =&gt; =&gt; new Vue({ el: &quot;#example-3&quot;, methods: { say(str) { alert(str) } } }) 单向数据流 prop是单向绑定的， 父组件属性变化， 传递给子组件， 但是， 子组件数据变化， 不能直接传递给父组件， 也就是数据的流行是从父组件流向子组件的， 为了防止子组件修改父组件的数据（会让应用的数据流变的更难开发、 更新、 维护） 使用了vuex工具的时候， store中数据在组件中使用的过程也是单向数据流， state-&gt;vue component-&gt;actions-&gt;mutations-&gt;state-&gt;vue component this.$router.push/replace({name:’user’, params:{userId:1}) this.$router.push / replace({ path: &apos;/register&apos;, query: { plan: &apos;private&apos; }) key相关当数据改变之后， vue会创建新的虚拟dom来和原来的虚拟dom做对比， 在创建新的虚拟的dom的时候， 会根据key来查找在原来的虚拟dom中有没有某个部分， 如果原来的有， 这次的也需要， 就会实现复用， 而且在做diff对比的时候， 如果有key会加快对比的查找速度， 提高性能 尽量循环的时候不要将key设置为数组的索引， 因为当删除某一个元素的时候， 就会导致删除位置下面的所有元素的key值都与上一次虚拟dom的key值不同， 导致复用失败， 这个时候我们最好使用关键的唯一的， 例如id这样的数据作为key 如果数据变化只是值的变化而不是条数和位置的变化， 可以使用索引作为key Vue.use()Vue.use会查找插件对象里的install方法去执行， 并且给install方法里传入Vue对象 var a = { install(Vue) { Vue.component(&quot;my-a&quot;, { ... }) } } Vue.use(a) 进入域后根据不同的情况显示不同的页面（PC/MOBILE)很多情况下， 一个应用会有PC和移动端两个版本， 而这两个版本因为差别大， 内容多， 所以不能用响应式开发但是单独开发， 而域名只有一个， 用户进入域后直接返回对应设备的应用， 做法主要有两种： 前端判断并跳转 进入一个应用或者一个空白页面后， 通过navigator.userAgent来判断用户访问的设备类型， 进行跳转 后端判断并响应对应的应用 用户地址栏进入域的时候， 服务器能接收到请求头上包含的userAgent信息， 判断之后返回对应应用 function foo() { // 第16行 getName = function() { console.log(1) } return this } foo.getName = function() { console.log(2) } foo.prototype.getName = function() { console.log(3) } var getName = function() { console.log(4) } function getName() { console.log(5) } foo.getName() //2 //foo是一个函数，也可以说是一个对象，所以它也可以挂载一些属性和方法，18行在其上挂载了一个getName方法 //执行的结果是 getName() //4 //21行有一个全局函数，全局函数声明提前后被20行的getName覆盖，所以输出4 foo().getName() //1 //foo()执行完成后，将全局的getName也就是window.getName给更改后返回this，而在这里this执行的就是window，所以最后执行的就是window.getName，所以输出1 getName() //1 //在上面已经更改全局的getName，所以依然是1 new foo.getName() //2 //new 操作符在实例化构造器的时候，会执行构造器函数，也就是说，foo.getName会执行，输出2 new foo().getName() //3 //new操作符的优先级较高，所以会先new foo()得到一个实例，然后再执行实例的getName方法,这个时候，实例的构造器里没有getName方法，就会执行构造器原型上的getName方法 new new foo().getName() //3 //先执行new foo()得到一个实例，然后在new 这个实例的getName方法,这个时候会执行这个方法，所以输出3 //除了本地对象的方法，其他的函数都能new]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket的使用方式]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fwebsocket%2F</url>
    <content type="text"><![CDATA[websocket socket.io ajax 前端主动发，后端被动收（req,res） websocket 前端主动发，后端被动收（req,res） 后端主动发，前端被动收（req,res） socket.io包含两部分，一部分在node的express下设置，另一部部分浏览器页面下加载socket.io.client.js 前端要下载客户端socket.io.js文件，在页面中引入1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="javascripts/socket.io.js"&gt;&lt;/script&gt; &lt;script&gt; var socket = io('http://localhost:3001'); socket.on('connect', function() &#123;&#125;); socket.on('event', function(data) &#123;&#125;); socket.on('disconnect', function() &#123;&#125;); //监听 socket.on('getServerMessage', function(data) &#123; console.log(data) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 后端在express中使用，以下代码 12345var app = require('express')();var server = require('http').createServer(app);var io = require('socket.io')(server);io.on('connection', function()&#123; /* … */ &#125;);server.listen(3000); 接口 描述 socket.on() 发送信息 socket.emit() 接受信息 1234567891011121314var app = require('express')(); var server = require('http').createServer(app); var io = require('socket.io')(server); io.on('connection', function(socket) &#123; //发送socket信息的逻辑写在这里 /* … */ //监听 //socket.on(); //发送 setInterval(()=&gt;&#123; socket.emit('getServerMessage',parseInt(Math.random()*100)); &#125;,1000) &#125;); server.listen(3001);]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tortoisegit使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2FTortoisegit%2F</url>
    <content type="text"><![CDATA[Tortoisegit使用方法1、按顺序安装安装包(小乌龟下载地址 下载好安装包和汉化包，先安装安装包再安装汉化包) 2、设置中文 利用Tortoisegit解决冲突 例如以上的界面左上角是远端拉下来的，右上角是本地的，红色的代表冲突部分，把需要代码复制到下面的框内， 然后保存时 标记冲突解决 再commit冲突就解决完成了。(请注意所有冲突部分是否修改完毕再进行保存) 利用Tortoisegit设置外部解决冲突程序解决冲突 设置合并工具这里我设置的是vscode,利用vscode进行冲突处理 首先双击红色冲突文件，解决冲突代码，在提交的时候把#后的东西删除并提交再推送远端那么冲突就解决完成了如果遇到上传无权限问题，请设置好您的ssh key 并且在可视化设置ssh客户端 一般来说都使用的是git的安装目录下的 usr\bin 的ssh.exe文件]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEO前端优化]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2FSEO%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、搜索引擎工作原理 当我们在输入框中输入关键词，点击搜索或查询时，然后得到结果。深究其背后的故事，搜索引擎做了很多事情。 在搜索引擎网站，比如百度，在其后台有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是百度程序从茫茫的互联网上一点一点下载收集而来的，这些程序称之为“搜索引擎蜘蛛”或“网络爬虫”。这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入数据库。反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。 一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容是它的语言，那么它便能看懂，它的语言即SEO。 二、SEO简介 全称：Search English Optimization，搜索引擎优化。自从有了搜索引擎，SEO便诞生了。 存在的意义：为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。简言之，就是希望百度等搜索引擎能多多我们收录精心制作后的网站，并且在别人访问时网站能排在前面。 分类：白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO，那么白帽SEO能做什么呢？ 1. 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的； 2. 网站内容优化：内容与关键字的对应，增加关键字的密度； 3. 在网站上合理设置Robot.txt文件； 4. 生成针对搜索引擎友好的网站地图； 5. 增加外部链接，到各个网站上宣传； 三、前端SEO 通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂，也能让“蜘蛛”看懂。 (1)网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。 一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬，“万一天黑迷路了怎么办”。并且根据相关调查：访客如果经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。为此我们需要做到： 1. 控制首页链接数量 网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。 因此对于中小型企业网站，建议首页链接在100个以内，链接的性质可以包含页面导航、底部导航、锚文字链接等等，注意链接要建立在用户的良好体验和引导用户获取信息的基础之上。 2.扁平化的目录层次，尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页。扁平化的目录结构，比如：“植物”–&gt; “水果” –&gt; “苹果”、“桔子”、“香蕉”，通过3级就能找到香蕉了。 3.导航优化 导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。 其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。 4. 网站的结构布局–不可忽略的细节 页面头部：logo及主导航，以及用户的信息。 页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。 页面底部：版权信息和友情链接。 特别注意：分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。 5.控制页面的大小，减少http请求，提高网站的加载速度。 一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。 (2)网页代码优化 1.标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的标题中不要设置相同的内容。 2.标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。 3.标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。 4.中的标签：尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6 是用于标题类的，标签是用来设置页面主导航的等。 5.标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。 6.正文标题要用标签：“蜘蛛” 认为它最重要，若不喜欢的默认样式可以通过CSS设置。尽量做到正文标题用标签，副标题用标签, 而其它地方不应该随便乱用 h 标题标签。 7.标签：只用于文本内容的换行，比如: 12345&lt;p&gt; 第一行文字内容&lt;br/&gt; 第二行文字内容&lt;br/&gt; 第三行文字内容&lt;/p&gt; 8.表格应该使用表格标题标签 9.应使用 “alt” 属性加以说明 10.、标签 : 需要强调时使用。标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，标签强调效果仅次于标签。 、标签: 只是用于显示效果时使用，在SEO中不会起任何效果。 10、文本缩进不要使用特殊符号 &nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。 12、巧妙利用CSS布局，将重要内容的HTML代码放在最前面，最前面的内容被认为是最重要的，优先让“蜘蛛”读取，进行内容关键词抓取。 13.重要内容不要用JS输出，因为“蜘蛛”不认识 14.尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容 15.谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。 16. 不断精简代码 17.js代码如果是操作DOM操作，应尽量放在body结束标签之前，html代码之后。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJS引入模块创建服务器]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fnode%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%20%2F</url>
    <content type="text"><![CDATA[node 安装node环境 npm install gulp 写一份gulpfile.js配置gulp的参数 gulp命令执行js来完成代码处理（压缩， 重命名） install如果没有安装的node环境去node官网安装维护版本 查看版本号， 在cmd中执行， 1node -v introduceNode.js®是一个基于 Chrome V8 引擎的JavaScript运行时 前端（浏览器端）123要运行JS, 必须借助于HTML文件， 没有HTML文件和浏览器环境， 那JS是无法运行 （要有HTML文件， 也要有浏览器环境）浏览器=界面+控制台JS是必须运行在浏览器上， 所以只能控制浏览器 后端（服务器端）1234要运行JS, （既不需要HTML文件， 也不需要浏览器环境， 只需要Node环境）， node替代了HTML文件， 也替代了浏览器服务器（node)=控制台JS有了node环境， 可以运行在非浏览器环境下， 因为node是装在系统上， 所以JS可以操作系统node(浏览器的控制台===chrome的V8引擎）&lt;浏览器 运行如何使用node 写一份JS代码 在命令行定位到此代码的位置， 运行命令 node JS文件的名字.js 模块化自定义模块化前端 写多条 &lt;script&gt;引入JS 在html分开引入 利用 require.js 123&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="cookie.js"&gt;&lt;/script&gt;&lt;script src="module.js"&gt;&lt;/script&gt; node(后端）它没有html, 所以需要借助于两个JS方法 导出， 借助于 module.exports 123456789101112function plus(a, b) &#123; return a + b&#125;function sub(a, b) &#123; return a - b&#125;module.exports = &#123; plus, sub&#125; 导入， 借助于 require , 建议用相对路径 1var tool = require("./plus.js"); 内置模块不需要自己写， 就是node环境自带， 它自己写好给你的， 就可以引入 Node拿来作为PHP的一种替代（多一种可选的方案） PHP能做的， Node也能做 模块 名字 读写文件 fs 创建服务器 http 查看系统 os 压缩文件 zip … … 其他模块参考 node官网内置模块API文档 HTTPhttp超文本传输协议前端最多就是ajax(http协议的一种前端实现方案） GET/POST GET POST 参数在url上 参数在请求体 有可能有长度 没长度限制 不安全 安全 状态码 1xx 开始执行 2xx 成功 3xx 重定向 4xx 客户端错误， 浏览器端 5xx 服务端 apache(wamp集成环境）+php 1234windowapachemysqlphp 创建服务器1234567var http = require('http');console.log(http);var server = http.createServer(Function(request, response) &#123; response.end("hello world");&#125;)server.listen(12345); //(0,65535)console.log("启动服务器"); 出现跨域， 加一个头部来解决 1header("Access-Control-Allow-Origin:*") 第三方模块我们可以从npm包管理中心去下载一些第三方包（别人写好传上去的）， 去在本地node平台实现自己的一些功能 安装第三方包模块 gulp就是一个常用的第三方模块 安装12npm install xxx(gulp) -gnpm i 建议安装 cnpm 替代 npm , 在命令行上输入以下代码安装 1npm install - g cnpm--registry = https: //registry.npm.taobao.org 除了全局安装之外， 安装任何包都会在该目录下 node_modules ， 你的包就会被安装在该文件夹下这个文件夹不要传到svn和git服务器上， 以后你移植这个项目的时候不要把 node_modules ， 只要用 package.json 描述文件去代替它， 这份文件记录着你开发node的一些关键信息， 比如你安装过什么模块作为依赖 卸载12npm uninstall xxx //卸载某个模块npm uninstall //全部卸载 初始化生成一份 package.json 描述文件 1npm init 使用第三方模块12var request = require('request');var gulp = require('gulp');]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>nodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node爬虫与request]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Frequest%E6%A8%A1%E5%9D%97cheerio%E7%88%AC%E8%99%AB%20%2F</url>
    <content type="text"><![CDATA[参考教程runoob菜鸟教程 异步前端（浏览器端）前端异步只有一下几种情况是异步 123ajax xmlhttprequestsetInterval / setTimeoutjsonp 后端（服务器端node)比前端多很多， 很多方法都是异步的 12fs.readFile //异步fs.readFileSync //同步 异步一般配合回调函数， 回调函数能让异步变得有意义 同步比异步少了回调函数 同步阻塞， 相对稳定， 不需要回调 异步非阻塞， 相对不稳定， 配合回调才有意义 12345678//同步var data = fs.readFileSync('./test.txt');console.log(data.toString());//异步fs.readFile('./test.txt', function(err, data2) &#123; console.log(data2.toString());&#125;); 回调嵌套如果出现多个回调嵌套的时候， 建议是用 promise 来去解决这个回调地狱 123456789101112131415161718192021222324252627function buyPizza() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log("买披萨"); resolve() &#125;, 1000); &#125;)&#125;function buyDrink() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log("买饮料"); resolve() &#125;, 1000); &#125;)&#125;function eatMeal() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log("吃东西"); //resolve() &#125;, 1000); &#125;)&#125;buyPizza().then(buyDrink).then(eatMeal); request任何前端请求都有 请求头（浏览器信息）， 请求体（POST请求， 请求参数会放在这个地方） 用户不可见的 响应头（服务器信息）， 响应体（页面的内容， 用户可见） request模块文档 爬虫爬取网站的内容， 然后可以保存到本地， 或者分析页面获取有价值的信息 1234567891011var request = require('request');var fs = require('fs');request('http://www.umei.cc/', function(error, response, body) &#123; //console.log('error:', error); // Print the error if one occurred //console.log('statusCode:', response &amp;&amp; response.statusCode); // Print the response status code if a response was received console.log('body:', body); // Print the HTML for the Google homepage. // fs.writeFile('test.html', body, function(err) &#123; // console.log("成功保存") // &#125;)&#125;);console.log("开始请求"); cheerio cheerio使用文档 实现网页内容分析， 用法类似于jQuery, node版本jQuery, 可以用它爬取文字， 图片， 音频 1234567891011var request = require('request');var cheerio = require('cheerio');request('http://www.umei.cc/', function(error, response, body) &#123; //console.log('body:', body); // Print the HTML for the Google homepage. const $ = cheerio.load(body); $("img").each((i, e) =&gt; &#123; console.log($(e).attr("src")) &#125;)&#125;);console.log("开始请求"); 并非所有网站都是能爬， 有些网站是防爬虫， 还有一些网页是前端JS动态生成 并非所有网站都是能爬， 有些网站是防爬虫， 还有一些网页是前端JS动态生成123&gt; 解释： * 爬虫的意义就是： 利用request链接到网站， 爬取它的内容； * 在请求出来的内容中用cheerio筛选出你要的有用的信息]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>nodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端解决跨域问题之nginx代理]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fnginx%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前端解决跨域问题之nginx代理（Visual Studio Code 用的本地启动服务端口的插件名称 GO Live 端口为http://127.0.0.1:5500/）一、下载nginx（https://nginx.org/en/download.html）二、以管理员身份设置 本机hosts文件C:\Windows\System32\drivers\etc 根目录hosts文件添加本地域名127.0.0.1 yun.localhost三、nginx文件夹conf 创建文件夹及新文件 serv yun.localhost四、nginx.conf 引入新建的文件include serv/yun.localhost;五、在yun.localhost 配置端口12345678910111213141516171819server&#123; listen 80; server_name yun.localhost; proxy_set_header upgrade $http_upgrade; proxy_set_header connection "upgrade"; location / &#123; proxy_pass http://127.0.0.1:5500/; &#125; //这些按后端给的接口文档里的接口配置 proxy_pass 是后端端口配置完成后重启nginx // nginx -s reload 重启服务 //然后在postman上测一下 location /screen &#123; proxy_pass http://192.168.11.118:6009; &#125; location /department &#123; proxy_pass http://192.168.11.118:6009; &#125;&#125; 六、nginx.conf 清除默认配置 访问的时候直接利用配好的端口加路径 yun.localhost/pages/management/management.htmlnginx的作用不只有这一点但是前端为了解决开发中的跨域问题上述配置已经足够，更多更详细的配置还需要继续学习。。。。]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>nodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置多账号]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fgit%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[某些时候我们既要到github上找轮子，又需要保持公司内部git与电脑的连接。此时就需要配置多账号 否则你的ssh key就会频繁更改。备注：所有执行命令的地方请在管理员模式下进行，即打开cmd，Git Bash客户端用管理员身份运行程序。 1. 生成github.com对应的私钥公钥(我是在git客户端直接生产key)先cd ~/.ssh到此目录后 ssh-keygen -t rsa -C 你的邮箱2. 同样的方式生产公司git所要的的私钥公钥 (邮箱地址可以相同可以不同)执行命令ssh-keygen -t rsa -C email 创建sshkey，命名为id_rsa_home (命名随便) 3.由于是在git的 ~/.ssh目录下创建的所以这是git默认访问的.ssh目录。除了秘钥文件之外，config文件是后面的步骤中手动生产的，known_hosts文件是后续自动生产的。（在cd ~/.ssh后 输入pwd可以查看~/.ssh所在的目录） 4.把github对应的公钥和公司git对应的公钥上传到服务器(步骤和github添加公钥差不多)5. 在.ssh目录创建config文本文件并完成相关配置(最核心的地方)每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可config文件配置如下：1234567891011121314# 配置github.comHost github.com HostName github.com IdentityFile ~/.ssh/id_rsa# 配置git.gitlab.net Host gitlab.com HostName gitlab.com IdentityFile ~/.ssh/id_rsa_gitlab HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 6. 打开Git Bash客户端（管理员身份运行）执行测试命令测试是否配置成功（会自动在.ssh目录生成known_hosts文件把私钥配置进去）7. 测试成功之后就可以在电脑上同时使用git,多账号同时操作，互不影响了.参考文档 参考文档2]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用命令及手动关联git本地和远端仓库1、关联git本地和远端仓库步骤 打开git，输入mkdir newProject 新建一个文件夹。 git init 初始化本地文件夹为一个可以管理的git仓库。 关联本地仓库和远端仓库：git remote add origin http://${path}.git. (如果是从远端仓库克隆下来那么本地仓库和远端仓库已经自动完成关联) 把文件放入本地仓库 git status // 列出没有被git管理或者修改但还没有未被提交的文件(如果有可视化工具此处很可观的可以观察到那些文件未提交) git add . // 将未被管理的文件添加到git git commit -m “提交文件” 把本地库推送到远端仓库 git push -u origin master ps：当远端仓库使用Readme文件初始化项目，需要先git pull origin master，有固定格式时需手动编辑，按i修改，:wq退出 ( shift+: 即可输入) 切换本地开发分支并管理远端分支 git checkout -b topic // 创建并切换到topic新分支，相当于git branch topic 和git checkout topic 组合 git push origin topic:topic // 关联本地topic分支和远端topic分支 （没有将自动创建topic分支并关联） 2、git 常用命令 开发四部曲。 git add . git commit -m “commit” git pull origin master git push origin master 代码冲突。 （推荐使用可视化工具解决冲突） 解决冲突 git add . git rebase –continue （或者再次git commit） git push origin master git 分支管理 git fetch （-p） // branch在服务器上的最新状态 git branch (-a) // 查看所有branch git branch newBranch // 本地创建branch git checkout branch // 切换branch git checkout -b topic // 创建并切换到topic新分支 git push origin topic:topic // 关联本地topic分支和远端topic分支 git branch –set-upstream-to=origin/topic topic //设置本地topic的上游及远端分支（设置之后git pull将默认从远端topic分支可拉取代码，git push将默认推送代码到远端topic分支） git版本管理 git reset –hard HEAD^ // 回退上一个版本 git reset –hard HEAD~3 // 回退上三个版本 git reset –hard 版本号 // 回退指定版本 git远端版本回退 git checkout target_branch // 切换到需要回滚的分支 git pull //更新代码 git branch target_branch_copy //备份一下这个分支当前的情况 git reset –hard target_commit_id //把target_branch本地回滚到target_commit_id git push origin :target_branch //删除远程 target_branch git push origin target_branch //用回滚后的本地分支重新建立远程分支 git push origin :target_branch_copy //如果前面都成功了，删除这个备份分支 重命名 git mv oldName newName git status 可以看到rename的提示，此时正常提交即可。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express框架简单使用]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fexpress%20%E8%84%9A%E6%89%8B%E6%9E%B6%20%E8%BF%9E%E6%8E%A5mysql%2F</url>
    <content type="text"><![CDATA[express npm的express文档 切换不同的路由，就进入不同的逻辑，也就是浏览器输入不同路径，页面就有不同的返回结果12345678910111213var express = require('express')var app = express() app.get('/', function (req, res) &#123; res.send('Hello World')&#125;)app.get('/home', function (req, res) &#123; res.send('home页面')&#125;) app.listen(3000)// “/”后是不同的页面不同的路由，（index.php,login.php ....） express的脚手架全局安装12npm install -g express-generator@4//npm init 生成package.json文件 安装时候-S--dev保存安装依赖 在一个文件夹里面用express命令创建应用架构12express testcd test 进入test文件夹安装依赖，推荐cnpm安装所有依赖1npm install 启动应用12SET DEBUG=test:*npm start 访问在浏览器3000端口号1http://localhost:3000 创建路由进入到test目录的routes文件夹,然后复制users.js 你可以改变/home这里的路径123456var express = require('express');var router = express.Router();router.get('/home', function(req, res, next) &#123; res.send('hello world');&#125;);module.exports = router; 在app.js添加以下两条，该路由就完成了123456var homeRouter = require('./routes/home');//codeapp.use('/test', homeRouter);此处第二个参数需要和命名一致“/test”为虚拟路径访问方法: http://localhost:3000/test/home 访问该路径1http://localhost:3000/test/home mysql连接数据库 12345678910111213141516//select * from students where username = var mysql = require('mysql');var connection = mysql.createConnection(&#123; host: 'localhost', user: 'lemon', password: '123456', database: '1806'&#125;);connection.query('INSERT INTO students SET ?', [&#123; username: req.body.username, password: req.body.password&#125;], function(error, results, fields) &#123; if(error) throw error; res.send("success");&#125;);connection.end(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//封装上述代码//db.js var mysql = require('mysql');//引入模块 var config = require("./config.js") function query(sql, params, callback) &#123; var connection = mysql.createConnection(&#123; host: config.host, user: config.user, password: config.password, database: config.database &#125;); connection.connect(); connection.query(sql, params, function(error, results, fields) &#123; if(error) throw error; callback(results); connection.end(); &#125;); &#125; module.exports = &#123; query: query &#125;//config.js 文件夹下 module.exports = &#123; host: 'localhost', user: 'lemon', password: '123456', database: '1806' &#125;//用法var db = require("./db.js");console.log(db)db.query("SELECT * FROM students where ?",[&#123; username:'qq'&#125;],function(data)&#123; console.log(data)&#125;)=====================================================================var db = require("./db.js");console.log(db)db.query("SELECT * FROM students",[],function(data)&#123; console.log(data)&#125;)]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>nodeJS</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express框架multer文件上传模块]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2Fexpress%20multer%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A8%A1%E5%9D%97%20mongidb%2F</url>
    <content type="text"><![CDATA[express参考文档 multer模块 multer npm官方文档 上传单文件项目安装multer模块123456789101112131415161718// 上传配置的必须的参数var multer = require('multer');var storage = multer.diskStorage(&#123; //设置上传后文件路径，uploads文件夹会自动创建。 destination: function(req, file, cb) &#123; cb(null, './uploads') &#125;, //给上传文件重命名，获取添加后缀名 filename: function(req, file, cb) &#123; var fileFormat = (file.originalname).split("."); //给图片加上时间戳格式防止重名名 //比如把 abc.jpg图片切割为数组[abc,jpg],然后用数组长度-1来获取后缀名 cb(null, file.fieldname + '-' + Date.now() + "." + fileFormat[fileFormat.length - 1]); &#125;&#125;);var upload = multer(&#123; storage: storage&#125;); mongodbnosql数据库，不需要sql语句的数据库，里面一切都是类似于JSON文件 mongodb教程 安装 双击安装mongodb.msi文件 找回安装完mongodb文件夹bin的路径1C:\Program Files\MongoDB\Server\3.2\bin 里面有多个exe文件 在bin该目录下，打开cmd命令行，执行以下命令，该目录有数据连接此数据库，该目录没库就是创建数据库成功， 1mongod --dbpath [文件夹的路径] 安装robo3t的可视化软件来管理mongodb数据库，没有表的概念，只有集合(类似于mysql的表)) 配合node来使用mongodb数据库,在项目目录下用cmd安装 1npm install mongodb 新建server.js,执行以下代码 12345678910111213141516const MongoClient = require('mongodb').MongoClient;const assert = require('assert'); // Connection URLconst url = 'mongodb://localhost:27017'; // Database Nameconst dbName = '1806'; // Use connect method to connect to the serverMongoClient.connect(url, function(err, client) &#123; assert.equal(null, err); console.log("Connected successfully to server"); const db = client.db(dbName); client.close();&#125;); 查看数据 12345678910111213141516171819202122232425const MongoClient = require('mongodb').MongoClient;const assert = require('assert');// Connection URLconst url = 'mongodb://localhost:27017';// Database Nameconst dbName = '1806';// Use connect method to connect to the serverMongoClient.connect(url, function (err, client) &#123; assert.equal(null, err); console.log("Connected successfully to server"); //选择库 const db = client.db(dbName); //选择表 集合 db.collection('students').find(&#123; age: 18 &#125;).toArray(function (err, docs) &#123; assert.equal(err, null); console.log("Found the following records"); console.log(docs) &#125;); client.close();&#125;);]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>nodeJS</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts]]></title>
    <url>%2F2019%2F05%2F19%2Fframe%2FEcharts%E7%9A%84%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Echarts+layui+jq数据可视化大屏展示Echarts结合vue1npm install echarts Echarts结合layui(1)下载layui echarts(2)可以直接script标签引入，也可以用layui的模块化方案引入(如果要使用地图.js直接script标签引入更直接),修改echarts.js 添加 window.layui &amp;&amp; layui.define ? layui.define(function(exports){exports(‘echarts’,factory(exports))}) :12345678(function (global, factory) &#123; typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' &amp;&amp; define.amd ? define(['exports'], factory) : window.layui &amp;&amp; layui.define ? layui.define(function(exports)&#123;exports('echarts',factory(exports))&#125;) : (factory((global.echarts = &#123;&#125;)));&#125;(this, (function (exports) &#123; 'use strict';.....&#125; layui的模块化方案layui可以自定义一个模块并引入 123456789101112131415161718192021222324252627282930313233343536/** @Author: yangjialin @Time: 2019-1 @Tittle: moban @Description: 模板管理 *///此模块使用了jq先引入jq在进行面向对象编程最后导出模块//此文件定义在非layui目录下 文件夹命名 /modules/ //以下是自定义模块示例layui.define([ 'jquery',], function (exports) &#123; var $ = layui.jquery; var moban = &#123; //在此写功能函数 layout: function (layoutName)&#123; ... &#125; // 导出模块 exports('moban', moban)&#125;);//将修改后的echarts.js也丢进此 /modules/文件夹 //使用的时候规定好目录layui.config(&#123; base: '/modules/'&#125;).use(['jquery', 'http', "moban","echarts"], function () &#123; var $ = layui.jquery, http = layui.http, moban = layui.moban, echarts=layui.echarts; console.log(moban.layout) console.log(echarts) ｝ Echarts其实就是堆配置项，官方文档的实例也可以复制修改，并没有什么特殊的，只是说大屏的自适应来说echarts在某些特定情况下需要用一些特殊的手段。在layui的框架下基于jq开发的大屏项目使用的是iframe标签将图表引入，布局使用的是百分比+rem+flex布局.（iframe不建议使用但是我就是用了）Echarts需要实现自适应大小需要在窗口变化的时候resize1234// 图像自适应 window.onresize = function () &#123; myChart.resize(); &#125; 除此之外echarts的字体也需要变化因为默认的是px所以需要在窗口变化的时候讲字体也变小1234567891011121314//和rem原理差不多同样是借助了html的根字体大小来改变因为使用的是iframe所以图表都是自己在一个htmlfunction setFontSize() &#123; htmlSize = $("html").css("font-size"); htmlSize = htmlSize.substring(0, htmlSize.indexOf("p")); fontSize = htmlSize * 0.13;//字体大小 根据需求自己调整 labelLineLen = fontSize / 0.13 * 0.2;//线的大小 根据需求自己调整 //series(各个系列的的字体大小、线大小、长度)根据配置项及需求自己调整 option.series[0].labelLine.normal.length = labelLineLen; option.series[0].itemStyle.normal.label.textStyle.fontSize = fontSize; option.series[1].label.normal.textStyle.fontSize = fontSize; option.tooltip.textStyle.fontSize = fontSize; //最后set一下 myChart.setOption(option); &#125; Echarts引入地图有两种引入方式JavaScript 引入示例1234567891011&lt;script src="echarts.js"&gt;&lt;/script&gt;&lt;script src="map/js/china.js"&gt;&lt;/script&gt;&lt;script&gt;var chart = echarts.init(document.getElementById('main'));chart.setOption(&#123; series: [&#123; type: 'map', map: 'china' &#125;]&#125;);&lt;/script&gt; JSON 引入示例（ECharts 使用 geoJSON 格式的数据作为地图的轮廓，除了上述数据，你也可以通过其它手段获取地图的 geoJSON 数据注册到 ECharts 中，在其他geoJSON工具中画好地图生成json引入也可以生成地图） 1234567891011$.get('map/json/china.json', function (chinaJson) &#123; //JavaScript 方式引入地图，地图已经自动注册 ，json的话需要手动注册 echarts.registerMap('china', chinaJson); var chart = echarts.init(document.getElementById('main')); chart.setOption(&#123; series: [&#123; type: 'map', map: 'china' &#125;] &#125;);&#125;); 我的项目是以JavaScript方式引入地图首先为了方便操作先获取地图的各省份经纬度123456789var geoCoordMap = &#123;&#125;;var mapFeatures = echarts.getMap('china').geoJson.features; mapFeatures.forEach(function (v) &#123; // 地区名称 var name = v.properties.name; // 地区经纬度 geoCoordMap[name] = v.properties.cp; &#125;); 基本思路是将请求回来的数据进行处理 再以省份获取对应地图省份的经纬度从而改变数据 在set一遍 让其重绘123456789101112131415161718192021//以省份名字去查询对应经纬度 返回一个数组可以直接替换 series（系列里的）data//将需呈现在地图上的散点或者系列图省份传入var convertData = function (data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; //geoCoordMap表示上面echarts地图的经纬度集合 判定是否存在此城市的经纬度 var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) &#123; //传出的数组 res.push(&#123; //名字 name: data[i].name, //地图经纬度 value: geoCoord.concat(data[i].value), //提示框里的数量 serviceCompanyNum: data[i].serviceCompanyNum &#125;); &#125; &#125; return res; &#125;; 上述地图option 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247var option = &#123; color: "#fff", //此为左下角的图例 （图上没截到） legend: &#123; orient: 'vertical', y: '74%', x: '2%', data: ['业务已覆盖区域', '服务项目主要集中地域', '2019将大力拓展区域'], textStyle: &#123; color: '#fff', fontSize: 12, padding: 6 &#125; &#125;, //提示框组件 tooltip: &#123; trigger: 'item', formatter: function (res) &#123; // console.log(res) if(res.data.name==undefined)&#123;return ``&#125; //data里的名字 和数量 var str = res.data.name + ":" + res.data.serviceCompanyNum + "家"; return str &#125;, &#125;, grid: &#123; top: "0%", bottom: "50%", letf: "0%", right: "0%", containLabel: false, &#125;, //此处以geo地理坐标系组件直接用为地图不使用 series type：map //series将作为三个散点图 geo: &#123; map: 'china', label: &#123; emphasis: &#123; show: false &#125; &#125;, //初始放大倍数 zoom: 1.1, //是否允许放大缩小拖拉 roam: true, //地图样式 itemStyle: &#123; //默认 normal: &#123; areaColor: '#4F89C1', borderColor: '#0B152D', borderWidth: 1, &#125;, //高亮 emphasis: &#123; areaColor: '#7AC8FF' &#125; &#125;, //这个是改变地图上某个省份的颜色 regions: [], &#125;, series: [&#123; name: '1', //type: effectScatter 涟漪特效动画的散点（气泡）图 type: 'effectScatter', //coordinateSystem 该系列使用的坐标系 coordinateSystem: 'geo', // 暂时为空 将请求回来的数据处理后一并设置 data: [], symbolSize: function (val) &#123; console.log(val); return val[0] / 5; &#125;, showEffectOn: 'render', //涟漪的模式 period周期 scale大小层数 brushType 模式 rippleEffect: &#123; period: 4, scale: 3, brushType: 'fill' &#125;, //鼠标移动上去的动画 hoverAnimation: true, //省份显示 show :false 不显示 label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125; &#125;, //itemStyle 每个散点的样式 itemStyle: &#123; //默认样式 normal: &#123; //颜色渐变 color: &#123; type: 'radial', x: 0.5, y: 0.5, r: 0.5, colorStops: [&#123; offset: 0, color: '#e75050' // 0% 处的颜色 &#125;, &#123; offset: 1, color: '#e75050' // 100% 处的颜色 &#125; ], global: false, // 缺省为 false, &#125;, &#125; &#125;, &#125;, &#123; name: '2', type: 'effectScatter', coordinateSystem: 'geo', data: [], symbolSize: function (val) &#123; console.log(val); return val[0] / 5; &#125;, showEffectOn: 'render', rippleEffect: &#123; period: 4, scale: 3, brushType: 'fill' &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125; &#125;, itemStyle: &#123; normal: &#123; color: &#123; type: 'radial', x: 0.5, y: 0.5, r: 0.5, colorStops: [&#123; offset: 0, color: '#00e14a' // 0% 处的颜色 &#125;, &#123; offset: 1, color: '#00e14a' // 100% 处的颜色 &#125; ], global: false, // 缺省为 false, &#125;, &#125; &#125;, &#125;, &#123; name: '3', type: 'effectScatter', coordinateSystem: 'geo', data: [], symbolSize: function (val) &#123; console.log(val); return val[0] / 5; &#125;, showEffectOn: 'render', rippleEffect: &#123; period: 4, scale: 3, brushType: 'fill' &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125; &#125;, itemStyle: &#123; normal: &#123; color: &#123; type: 'radial', x: 0.5, y: 0.5, r: 0.5, colorStops: [&#123; offset: 0, color: '#e19605' // 0% 处的颜色 &#125;, &#123; offset: 1, color: '#e19605' // 100% 处的颜色 &#125; ], global: false, // 缺省为 false, &#125;, &#125; &#125;, &#125;, ] &#125;var sinessData,projectData,expandData=[]/* id: 1 serviceArea: "山东"//echarts的省市是不带省的 如山东省 echarts里数据为 山东 serviceCompanyNum: 1055 serviceTime: "2019-01-28" serviceType: 1 //表示第一系列*/ for (var i = 0; i &lt; data.length; i++) &#123; var dataName = data[i].name; if (dataName) &#123; if (data[i].serviceType == 1) &#123;//一系列 sinessData.push(&#123; //省份 'name': dataName, //数量 (以下相同 存这个数量是为了做提示框) "serviceCompanyNum": data[i].serviceCompanyNum &#125;) &#125; else if (data[i].serviceType == 2) &#123;//二系列 projectData.push(&#123; 'name': dataName, "serviceCompanyNum": data[i].serviceCompanyNum &#125;) &#125; else if (data[i].serviceType == 3) &#123;//三系列 expandData.push(&#123; 'name': dataName, "serviceCompanyNum": data[i].serviceCompanyNum &#125;) &#125; &#125; &#125;//运行函数设置各系列data option.series[0].data = convertData(sinessData) option.series[1].data = convertData(projectData) option.series[2].data = convertData(expandData)//需要什么效果从echarts官网上找实例复制然后并入就可以了 有时候图表会需要一个长链接来更新数据那么就需要利用WebSocket123456789101112131415161718192021222324252627282930313233var socket; if (typeof (WebSocket) == "undefined") &#123; console.log("您的浏览器不支持WebSocket"); &#125; else &#123; console.log("您的浏览器支持WebSocket"); //实现化WebSocket对象，指定要连接的服务器地址与端口 建立连接 //等同于socket = new WebSocket("ws://localhost:8083/checkcentersys/websocket/20"); socket = new WebSocket("ws://" + window.location.host +"/screen/websocket/后端的端口链接"); //打开事件 socket.onopen = function () &#123; console.log("Socket 已打开"); //socket.send("这是来自客户端的消息" + location.href + new Date()); &#125;; //获得消息事件 socket.onmessage = function (msg) &#123; //发现消息进入 开始处理前端触发逻辑 &#125;; //关闭事件 socket.onclose = function () &#123; console.log("Socket已关闭"); &#125;; //发生了错误事件 socket.onerror = function () &#123; console.log("Socket发生了错误"); //此时可以尝试刷新页面 &#125; //离开页面时，关闭socket //jquery1.8中已经被废弃，3.0中已经移除 // $(window).unload(function()&#123; // socket.close(); //&#125;); &#125; 根据WebSocket返回的数据重新set图表（当然使用定时器也可以） 图表不止这点但是做法都差不多，配置项官网上也有就不挂了]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(模块化开发简介与理解)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F21.%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[模块化开发[个人的项目与团队项目]项目中的js管理，以前我们可能会这样做代码分工：一个js文件下包含多个模块 1234//modules.js ----var moduleA = &#123;......&#125;var moduleB = &#123;......&#125;var moduleC = &#123;......&#125; 引入如下： 1&lt;script src=&quot;modules.js&quot;&gt;&lt;/script&gt; 不管这个页面用到了几个模块，你都要把整个文件加载进来，于是我们就想，随着代码越来越多，维护就变得特别困难（特别在团队项目中），于是我们就把每个模块单独分开，于是就变成了这样： 12345678//moduleA.js ---- var moduleA = &#123;......&#125; //moduleB.js ---- var moduleB = &#123;......&#125;//moduleC.js ----var moduleC = &#123;......&#125; 但是，js文件加载是同步的，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长，而且如果各个模块之间存在相互引用的依赖关系，我们还得考虑加载的顺序，所以我们这样引入JS： 1234&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;moduleB.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;moduleC.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;moduleA.js&quot;&gt;&lt;/script&gt; 假设A依赖C（A引用了C中的方法），而C依赖B，ABC里面都用到了common.js，你必须小心翼翼的确保它们的加载顺序是正确的，这样的文件越多维护起来非常麻烦，于是require.js出现了 requirejsRequireJS的目标是鼓励代码的模块化，它使用在js中加载js文件的方式代替传统的script加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化 requirejs的出现主要解决两个问题： 实现js文件的异步加载，避免网页失去响应； 管理模块之间的依赖性，便于代码的编写和维护。 官网：http://requirejs.org/中文网：http://www.requirejs.cn/ 使用按照requireJS当中的规范要求，你只需加载一个文件就可以而，并指定页面主模块main.js，由于requirejs默认的文件后缀名是js，所以可以把main.js简写成main 1&lt;script src =&quot;require.js&quot; data-main =&quot;main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块，main.js文件如下 12345//main.js-----requirejs([&apos;common&apos;,&apos;moduleA&apos;,&apos;moduleB&apos;,&apos;moduleC&apos;],function(jq)&#123; //这里的代码等common，moduleA，moduleB，moduleC模块都加载完成后执行 //但不保证以上模块的加载顺序&#125;); 基础路径baseUrl 任何文件的加载都是基于此路径 默认值是加载require.js的HTML文件所在的路径 但如果用了data-main属性，则主模块所在的目录就变成baseUrl 常用方法 配置参数：requirejs.config/require.config 加载模块：requirejs/require 定义模块：define 配置config这个require.js你可以从官网下载，这个config.js你必须自己完成。不用担心，它写起来非常简单: 1234567//config.js-----requirejs.config(&#123; baseUrl : &quot;js&quot;, paths : &#123; &quot;jquery&quot;: &quot;lib/jquery.1.11.3&quot; &#125;&#125;); baseUrl：指定基础路径 paths：path映射那些不直接放置于baseUrl下的模块名。设置path时起始位置是相对于baseUrl的 以上配置路径 “jquery”: “lib/jquery.1.11.3” 冒号左边jquery模块名称，右边则是文件路径，注意文件没有后缀名，因为在require看来所有的模块都是JS文件 真实路径为：js/lib/jquery.1.11.3.js shim配置(了解)严格意义上来说，requirejs必须加载由define()函数定义的模块，但有一些插件，本身未return任何对象或函数，只是对某个框架的扩展，例如 jquery.scroll.js 该怎么实现模块化加载，答案是shim配置 12345678910111213requirejs.config(&#123; baseUrl: &quot;js&quot;, paths: &#123; &quot;jquery&quot; : &quot;lib/jquery.1.11.3&quot;, &quot;jquery.scroll&quot; : &quot;lib/jquery.scroll&quot; &#125;, shim: &#123; &quot;jquery.scroll&quot;: &#123; deps: [&quot;jquery&quot;],//设置依赖 exports: &quot;jQuery.fn.scroll&quot;//暴露接口以便在回调函数中调用 &#125; &#125;&#125;); 加载模块以上配置好后，就可以加载模块了，requireJS把一个js文件当作一个模块，如加载jquery只需如下代码 123requirejs([&apos;jquery&apos;],function(jq)&#123; //这里的jq就是jquery，原理请看模块的定义&#125;); 定义模块define 使用define方法定义模块必须符合require的规范要求，格式如下： 12345678//把commonjs定义成模块//在引入模块时，回调函数中得到什么取决于定义模块时返回了什么define(function()&#123; return &#123; getStyle : function()&#123; ........ &#125;, randomColor : function()&#123; ......... &#125; &#125;&#125;); 如果定义的模块需依赖其他模块，格式如下，这种模块加载方式称为：预加载 12345678910//本模块依赖jquery//第一个参数为依赖模块，可以是多个，这里的路径同样基于baseUrl或pathdefine([&quot;jquery&quot;],function(jq)&#123; return &#123; start: function()&#123; jq(&quot;#box&quot;).show(1000); console.log(&quot;模块提供的start方法&quot;); &#125; &#125;&#125;); 如果需要在define内部依赖其他模块，则写法如下，这种模块加载方式称为：延迟加载 123define([&quot;require&quot;,&quot;jquery&quot;],function(require)&#123; var a = require(&apos;./js/a&apos;);&#125;); ES6 module 在ES6前， 前端就使用RequireJS或者seaJS实现模块化，ES原生支持模块化 export 格式：export{接口} export 输出：可输出对象、函数、类、变量 default 匿名输出，导入时可使用任意变量 123456//lib.jslet myname = laoxie;export default myname; //导入import nickname from &apos;./lib&apos;; import *: 导入所有接口 as: 重命名，避免命名冲突 1234567//lib.jslet getData = (data)=&gt;&#123;console.log(data)&#125;//导出重命名export getData as get; //导入重命名import get as g from &apos;./lib&apos;; 模块化开发的优点讲了这么多，requirejs所倡导的模块化开发，好处在哪里呢？ 避免命名冲突你有没有发现，整个项目当中，再也没有出现一个全局变量？即使两个框架名字冲突了也没关系 更好的依赖处理你有没有发现，你再也没有考虑过加载顺序的问题？ 按需加载更好的代码组织方式，而且你肯定没有发现，所有的JS文件的加载过程，已经变成了异步 面向对象编程最后，你还发现，用了requireJS，你的代码想不写成面相对象都难 模块化规范与框架1.commonJS：通用的模块规范（同步）；模块化框架：nodejs 2.AMD：异步模块定义规范（预加载）；模块化框架：requirejs 3.CMD：通用模块定义规范（延迟加载）。模块化框架：seajs官网：http://seajs.org五分钟上手教程：http://seajs.org/docs/#quick-start [练习] 把之前封装的common.js定义成模块]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(版本管理之Git)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F20.git%2F</url>
    <content type="text"><![CDATA[GitGit是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理 安装与配置 下载与安装下载地址：https://git-for-windows.github.io 配置个人信息（名字与邮箱）使用Git的第一件事就是设置你的名字和email,这些就是你在提交commit时的签名 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 查看是否配置成功，用命名git config -l git的使用（命令行）创建本地仓库 git init：把当前目录变成一个git仓库，并自动创建master分支 以上命令会在当前目录下创建了一个.git 隐藏目录，它就是所谓的Git 仓库。生成仓库后的目录就不是普通的文档目录了，我们将其称为工作区，所以工作区中都包含一个git仓库，而一个git仓库中又包含一个暂存区和一个版本库 工作区与版本库概念 工作区（Working Directory）：电脑中的目录 仓库：工作区有一个隐藏目录.git，这个不算工作区，而是Git仓库。 暂存区（stage/index）：一个临时的存储区域 版本库 （Repository） 添加文件到版本库的步骤（重点） 创建（修改）文件往工作区中添加/修改文件 添加到暂存区： 1git add &lt;file&gt; 把修改存放到暂存区 git add 文件夹：把文件夹下的所有修改添加到暂存区 1git add . ：添加所有修改到暂存区 如果想过滤部分文件，请查看 过滤清单 提交到版本库： 1git commit -m &quot;备注&quot; 使用git commit 命令可将暂存区的内容提交至版本库中，这个过程称为提交，每一次提交都意味着版本在进行一次更新（会自动生成一个commit id） PS：如果不写-m回车会进入vim编辑界面，退出方法： 进入编辑状态：i 退出编辑状态：ESC 同时按下Shift和冒号（:），接着输入输入：q（退出不保存），wq（保存并退出） 其他辅助命令 查看仓库变更状态：git status用status查看仓库会有几种状态：untracked、unstaged、uncommitted git远程仓库注册登录 github(国外):https://github.com/ coding(国内):https://coding.net 关联本地仓库与远程仓库 有两种方式关联：ssh和https两种协议，https比较简单，但提交时每次都分输入用户名和密码，如使用https协议，直接跳过以下第1、第2步 创建SSH Key：ssh-keygen -t rsa -C &#39;email地址&#39;以上命令会在当前window用户的目录里创建.ssh目录，里面有id_rsa（私钥）和id_rsa.pub（公钥）两个文件 将公钥写到github的ssh keys 上 添加SSH Key到Git服务器添加完成后测试线路是否连通：ssh -T git@github.com 建立本地仓库与远程仓库的连接 方式1：适用于先有本地仓库，后有远程仓库的情况 格式： 1git remote add 远程仓库名 远程仓库地址 1git remote add origin git@github.com:xxx/view.git 测试是否成功git remote -v PS：删除远程仓库连接：git remote remove 远程仓库名 方式2：克隆（适用于先有远程库，后有本地仓库的情况） 格式： 1git clone 远程仓库地址 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 推送到远程仓库（重点） git push 格式： 1git push 远程仓库名 本地分支名:远程分支名 把本地分支内容推送到远程分支（远程分支名省略表示推送到与本地分支相同的分支） 1git push origin master 拉取与合并（重点）同步本地与远程仓库 git pull 格式： 1git pull 远程仓库名 远程分支名:本地分支名 拉取远程分支内容到本地并与本地分支进行合并（本地分支名省略表示合并到与远程分支名相同的分支） 1git pull origin master git fetch拉取远程分支内容 git merge合并分支内容 12345git pull origin master//以上命令相当与以下命令等效git fetch origin mastergit merge origin/master **push和pull后的分支顺序格式：&lt;来源地&gt;:&lt;目的地&gt; 模拟解决冲突问题 版本回退 回退命令：git reset 回退到上一个版本git reset --hard HEAD^ 回退到指定版本：git reset --hard [commit id] 版本号没必要写全，前几位就可以了，Git会自动去找。 回退指定文件git reset --hard [commit id] &lt;file&gt; 参数说明 –hard:工作区、暂存区、版本库的文件同时回退 –mixed：暂存区、版本库的文件回退（默认） –soft：仅仅回退版本库中的文件 当前版本：HEAD上一个版本：HEAD^上上个版本：HEAD^^… 依此类推前100个版本：HEAD~100 显示从最近到最远的提交日志：git log –pretty=oneline（显示简要信息id+备注） –graph（图形显示版本走向） –abbrev-commit（显示简写的id） 一大串类似3628164…882e1e0的是commit id（版本号） 查看命令历史：git reflog 撤销文件修改 git checkout -- &lt;file&gt;：放弃工作区的修改 git rm --cache &lt;file&gt;：撤销暂存区的修改 git reset HEAD &lt;file&gt;：撤销暂存区的修改 对比文件：git diff &lt;file&gt; git过滤配置(过滤清单)一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。 12345678910111213#过滤node_modules根目录下的文件（不过滤其他目录下的node_modules文件夹）/node_modules#过滤所有mtk文件夹mtk/ #过滤所有.zip文件*.zip *.mp3*.mp4#过滤某个具体文件/mtk/do.c #为注释 很简单吧，被过滤掉的文件就不会出现在你的GitHub库中了，当然本地库中还有，只是push的时候不会上传。 演示sass遗留的依赖包问题：npm init创建package.js，npm install根据package.js下载包 分支操作（了解） 创建分支：git branch 分支名 切换分支：git checkout 分支名 以上两步合并为：git checkout -b 分支名 查看分支：git branch列出所有分支，当前分支前面会标一个*号 合并分支： 1git merge 分支名 git merge dev：把dev分支合并到当前分支 Fast-forward：快速合并 禁用快速合并： –no-ff （保持分支信息） 合并要创建一个新的commit，所以加上-m参数，把commit描述写进去 删除分支：git branch -d 分支名强行删除，需要使用命令git branch -D feature-vulcan 获取远程分支 先获取（git fetch） 然后在本地创建一个同名分支,并将远程分支映射到此分支（git branch dev origin/dev） 在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样 http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(Sass基础)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F19.Sass%2F</url>
    <content type="text"><![CDATA[SassSASS是一个成熟、稳定、强大的 CSS 扩展语言解析器，提供变量、嵌套、混合、继承等特性，大大节省了设计者的时间，使得CSS的开发变得简单和可维护 语法 注释sass有两种注释方式（与js相同） 多行注释/ / 单行注释// 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 变量sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样）。 全局变量与局部变量定义在任何选择器之外的变量被认为是全局变量，定义在选择器内的变量称之为局部变量。 但启用了global后，即使写在局部也能覆盖全局变量（sass 3.4版本后可用） 1$color:#fff !global; 默认变量：sass的默认变量仅需要在值后面加上!default即可。 1$fontSize:12 !default; 覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可（一般用于文件引用）: 12$fontSize:16;$fontSize:12 !default;//此行代码是另一个文件中的代码（查看@import） 变量特殊用法，一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用 12345$borderDirection:top !default;//应用于class和属性.border-#&#123;$borderDirection&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125; 多值变量，多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象。 12345678910111213//list类型$pd: 5px 10px 20px 30px;//使用.content&#123;padding:$pd;&#125;.btop&#123;border-top:nth($pd,1);&#125;//map类型$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);//使用h1&#123;map-get($headings,h1)&#125; 嵌套(Nesting)css中重复写选择器是非常恼人的。如果要写一大串指向页面中同一块的样式时，往往需要 一遍又一遍地写同一个ID 123#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; sass写法： 1234567#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125; 在嵌套中用&amp;表示父元素选择器 混合器(了解)变量可以实现简单样式的重用（如color,width等），但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，可以通过sass的混合器实现重用 sass中使用@mixin声明混合，通过@include来调用 无参数mixin 有参数mixin：参数名以$符号开始 多个参数mixin：多个参数以逗号分开 @content：多用于媒体查询的封装 123456789@mixin max-screen($res)&#123; @media only screen and ( max-width: $res ) &#123; @content; &#125;&#125;@include max-screen(480px) &#123; body &#123; color: red &#125;&#125; PS：@mixin通过@include调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从3.2.0版本以后，建议传递参数的用@mixin，而非传递参数类的使用下面的继承%。 继承使用选择器的继承，要使用关键词@extend 继承一般样式@extend h1 占位选择器% 12345678//占位符编译后不存在css样式中 %ir&#123; color: transparent; text-shadow: none; background-color: transparent; border: 0; &#125; @extend %ir; 函数Sass中的数字函数提要针对数字方面提供一系列的函数功能： 常用函数： percentage($value)：将一个不带单位的数转换成百分比值； round($value)：将数值四舍五入，转换成一个最接近的整数； ceil($value)：将大于自己的小数转换成下一位整数； floor($value)：将一个数去除他的小数部分； abs($value)：返回一个数的绝对值； min($numbers…)：找出几个数值之间的最小值； max($numbers…)：找出几个数值之间的最大值。 lighten($color,$percent) $color颜色值，$percent百分比 darken($color,$num) $num:0-100 自定义函数 格式：@fuction 函数名 12345678910$oneWidth: 10px; $twoWidth: 40px; @function widthFn($n) &#123; @return $n * $twoWidth + ($n - 1) * $oneWidth; &#125; .leng &#123; width: widthFn($n : 5); &#125; 运算sass具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错。 条件判断及循环 @if判断@if可一个条件单独使用，也可以和@else结合多条件使用 1234567@if $type == ocean &#123; color: blue;&#125; @else if $type == matador &#123; color: red;&#125; @else &#123; color: black;&#125; for循环 12@for $var from &lt;start&gt; through &lt;end&gt;（包含end值）@for $var from &lt;start&gt; to &lt;end&gt;（不包含en值） 导入sass中导入其他sass文件，最后编译为一个css文件，优于纯css的@import 1@import &apos;reset&apos;; 编译 gulp-sass 参数outputStyle： nested(默认） expanded：展开 compact：单行 compressed：压缩 12345678910gulp.task(&apos;sass&apos;, function () &#123; return gulp.src(&apos;./sass/**/*.scss&apos;) .pipe(sass(&#123;outputStyle: &apos;compressed&apos;&#125;).on(&apos;error&apos;, sass.logError)) .pipe(gulp.dest(&apos;./css&apos;));&#125;);//文件监听（文件有修改自动编译）gulp.task(&apos;sassWatch&apos;,function()&#123; gulp.watch(&apos;./src/sass/*.scss&apos;,[&apos;sass&apos;]);&#125;); 文件名以_开头的sass文件不会被编译成css文件 [练习] 使用Sass改造项目中的CSS文件]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(gulp基础)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F19.gulp%2F</url>
    <content type="text"><![CDATA[gulpgulp是当下最流行的自动化工具 ，可以自动化完成我们开发过程中大量的重复工作。如： 编译： less-&gt;css sass-&gt;css coffeescript-&gt;js es6-&gt;es5(兼容)合并: css, js压缩 ：css, js, html优化：图片优化 官网：http://gulpjs.com/ 中文网：http://www.gulpjs.com.cn/ gulp的安装及运行1.全局安装 gulp：1npm install --global gulp //全局安装gulp目的是为了通过它执行gulp任务 2.本地安装gulp：作为项目的开发依赖（devDependencies）安装： 1npm install --save-dev gulp //本地安装gulp是为了调用gulp插件的功能 –save-dev 保存配置信息至 package.json 的 devDependencies 节点 这步操作前先新建package.json文件（npm init） 这步完成后就可以安装各种gulp插件了 3.安装gulp插件大部分插件都可以在http://www.npmjs.com找到，任何插件的使用都要经历以下三步： 安装插件：npmnpm install gulp-htmlmin PS：可一次性安装多个插件，插件间用空格隔开 常用gulp插件 html压缩：gulp-htmlmin css压缩：gulp-clean-css js压缩：gulp-uglify 合并文件：gulp-concat 文件重命名：gulp-rename 编译Sass: gulp-sass 编译 Less：gulp-less 其他常用插件 浏览器同步测试：browser-sync 创建node服务器：http-server npm install -g http-server 4.创建gulpfile.js文件（gulp任务） ！！！项目根目录下 创建 gulp项目的配置文件，内容如下： 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;任务名&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 5.运行 gulp：在命令行执行以下命名，如果不写任务名称，则自动运行default任务（如果有） 1gulp &lt;任务名称&gt; 演示：编译scss文件为css文件//1.安装gulp-sass插件 //2.gulpfile.js: //(1)引包：require()：返回对象或者函数 let gulp = require(&apos;gulp&apos;);//得到对象 let sass = require(&apos;gulp-sass&apos;);//得到函数 //(2)创建任务 gulp.task(&apos;compileSass&apos;,function(){ // （3）执行gulp工作流程 gulp.src(&apos;./src/sass/*.scss&apos;) // 返回文件流（液体，文件在内存中的状态） .pipe(sass({outputStyle:&apos;expanded&apos;}).on(&apos;error&apos;, sass.logError)) .pipe(gulp.dest(&apos;./src/css/&apos;)) }); outputStyle参数（gulp-sass）： nested(默认） expanded：展开 compact：单行 compressed：压缩 on(&apos;error&apos;, sass.logError)：忽略错误，继续编译 gulp工作流程 选通过gulp.src(globs) 方法获取到想要处理的文件，并返回文件流 然后文件流通过 pipe 方法导入到 gulp 的插件中 经过插件处理后的文件流，再通过pipe方法导入到 gulp.dest() 方法中 最后通过gulp.dest() 方法把流中的内容写入到文件中 PS：文件流=&gt;文件在内存中的状态 5.监听文件修改，并执行相应任务gulp.watch(glob,[‘任务名’]) 演示：监听scss文件修改，自动编译123gulp.task(&apos;jtSass&apos;,function()&#123; gulp.watch(&apos;./src/sass/*.scss&apos;,[&apos;compileSass&apos;])&#125;) globs语法globs需要处理的源文件匹配符路径，语法如下 匹配单个文件：gulp.src(&#39;src/js/index.js&#39;) 匹配多个文件：gulp.src([&#39;src/js/index.js&#39;,&#39;src/js/detail.js&#39;]) //多个文件以数组形式传入 匹配所有文件gulp.src(&#39;src/js/*.js&#39;) 匹配符：!：排除文件， 1gulp.src([&quot;./src/sass/**/*.scss&quot;,&quot;!./src/sass/var.scss&quot;]) *：匹配所有文件，**：匹配0个或多个子文件夹，{}：匹配多个属性 备注：若想实现某个文件不受匹配控制，在文件名前面加_ SassSASS是一个成熟、稳定、强大的 CSS 扩展语言解析器，提供变量、嵌套、混合、继承等特性，大大节省了设计者的时间，使得CSS的开发变得简单和可维护 . 了解工具：css转scss嵌套(Nesting)css中重复写选择器是非常恼人的。如果要写一大串指向页面中同一块的样式时，需要一遍又一遍地写同一个ID。 123#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; sass写法： 1234567#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125; 在嵌套中用&amp;表示父元素选择器 注释1234body &#123; color: #333; // 单行注释：不会出现在生成的css文件中 padding: 0; /* 多行注释：内容会出现在生成的css文件中 */&#125; 变量sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样）。 演示：变量写法12345678// 主颜色$mainColor:#5b8c58;// 高亮颜色$highlight:#fc0;// 内边距$padding:5px 10px;//使用变量a:hover&#123;color:$mainColor;&#125; 全局变量与局部变量定义在任何选择器之外的变量被认为是全局变量，定义在选择器内的变量称之为局部变量。 但启用了global后，即使写在局部也能覆盖全局变量（sass 3.4版本后可用） 1$color:#fff !global; 默认变量sass的默认变量仅需要在值后面加上!default即可。 1$fontSize:12 !default; 变量特殊用法一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用 12345$direction:top !default;//应用于class和属性.border-#&#123;$direction&#125;&#123; border-#&#123;$direction&#125;:1px solid #ccc;&#125; 多值变量多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象。 12345678910//list类型$pd: 5px 10px 20px 30px;//使用.content&#123;padding:$pd;&#125;.btop&#123;border-top:nth($pd,1);&#125;//map类型$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);//使用h1&#123;map-get($headings,h1)&#125; 运算sass具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错。 条件判断及循环@if判断@if可一个条件单独使用，也可以和@else结合多条件使用 1234567@if $type == ocean &#123; color: blue;&#125; @else if $type == matador &#123; color: red;&#125; @else &#123; color: black;&#125; @for循环12@for $var from &lt;start&gt; through &lt;end&gt;（包含end值）@for $var from &lt;start&gt; to &lt;end&gt;（不包含end值） 演示:for循环12345@for $i from 1 through 6&#123; h#&#123;$i&#125;&#123; font-size:36px/($i/2); &#125;&#125; 函数Sass中的数字函数提要针对数字方面提供一系列的函数功能： 常用函数： percentage($value)：将一个不带单位的数转换成百分比值；round($value)：将数值四舍五入，转换成一个最接近的整数；ceil($value)：将大于自己的小数转换成下一位整数；floor($value)：将一个数去除他的小数部分；abs($value)：返回一个数的绝对值；min($numbers…)：找出几个数值之间的最小值；max($numbers…)：找出几个数值之间的最大值。lighten($color,$num) $color颜色值，$num:0-100darken($color,$num) $num:0-100 12演示：函数的使用background-color:lighter($mainColor,percentage($i/10)) 自定义函数格式：@fuction 函数名 12345678$oneWidth: 10px; $twoWidth: 40px; @function widthFn($n) &#123; @return $n * $twoWidth + ($n - 1) * $oneWidth; &#125; .leng &#123; width: widthFn($n : 5); //！！传参格式注意&#125; 继承使用选择器的继承，要使用关键词@extend 继承一般样式@extend h1 占位选择器% 1234567891011121314151617// % 无实际样式，不会被编译出来%pop&#123; width:600px;height:300px;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);&#125;.box&#123; width:800px; color:#ccc; background-color:#000;&#125;.container&#123; @extend .box; margin:10px;&#125;.login&#123; @extend %pop; background-color:$mainColor*2;&#125; 导入 @importsass中导入其他sass文件，最后编译为一个css文件，优于纯css的@import 1@import &apos;reset&apos;; 演示：同时编译多个scss文件为css，演示_文件名不会编译效果。演示bootstrap源码123456789101112//var.scss:$mainColor: #58bc58;$container: 800px;$padding:5px 10px 15px 20px;//list.scss:.box&#123; width:$container; color:$mainColor; padding:$padding; background-color:#fff; border:1px soild $mainColor;&#125; gulp插件的使用js压缩及合并、重命名// js压缩 let uglify = require(&apos;gulp-uglify&apos;); let pump = require(&apos;pump&apos;); let concat = require(&apos;gulp-concat&apos;); let rename = require(&apos;gulp-rename&apos;); gulp.task(&apos;compressJs&apos;,function(cb){ pump([ gulp.src(&apos;./src/js/*.js&apos;), // 合并 concat(&apos;index.js&apos;), gulp.dest(&apos;./dist/js/&apos;), // 压缩 uglify(), // 重命名 rename({ suffix:&apos;.min&apos; }), gulp.dest(&apos;dist/js/&apos;) ],cb ); }); browser-syncvar browserSync = require(&quot;browser-sync&quot;); // 静态服务器 gulp.task(&apos;server&apos;,()=&gt;{ browserSync({ // 服务器路径 // server:&apos;./src/&apos;, // 代理服务器，必须绑定到当前服务器路径一致 proxy:&apos;http://localhost:1806&apos;, // 端口 port:666, // 监听文件修改，自动刷新 files:[&apos;./src/**/*.html&apos;,&apos;./src/css/*.css&apos;,&apos;./src/api/*.php&apos;] }); // 监听sass文件修改，并自动编译 gulp.watch(&apos;./src/sass/*.scss&apos;,[&apos;compileSass&apos;]) }） //监听的文件修改，页面html对应修改。通过brower-sync服务只能看到页面修改 静态服务器：开启服务，不能识别后端语言. wampserver:php解析器]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(jQuery基础应用)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F18.JQ%2F</url>
    <content type="text"><![CDATA[jQuery了解jQueryJQuery是一个兼容多浏览器的javascript类库，核心理念是write less,do more(写得更少,做得更多)。是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。在2006年1月由美国人John Resig在纽约的barcamp发布。作者：John Resig官方网站：http://jquery.com/ jQuery版本 1.x.x 兼容低版本浏览器IE8- 代码过于庞杂，性能不高 最新版本1.12 2.x.x 已经不支持IE低版本浏览器IE8- 最新版本2.2 3.x.x 3.0 版本是从 2.0 版本分支出来的，但由于改动过大，因此更新了主版本号 不支持IE低版本浏览器 性能大幅度提高（推荐使用） ..* (主版本-次版本-补丁) 下载与安装 官网下载http://jquery.com/download/ CDN https://code.jquery.com/jquery-3.0.0.js https://code.jquery.com/jquery-3.0.0.min.js jQuery实现原理 jQuery构造函数 jQuery实例对象 1jQuery(&apos;#box&apos;);//得到jquery对象（实例） jquery对象只能用jquery的方法 jQuery实例属性 length: 返回jQuery对象中匹配元素的个数 jquery: 当前jquery类库版本号（一般用于判断是否jquery对象） 下标（索引）: DOM节点 jQuery的别名：$ 延迟代码执行：jQuery(document).ready(fn) 此方法传入一个匿名函数; 页面DOM渲染完成时执行; 简写方式:jQuery(function(){}); 安全使用$:jQuery(function($){}); 编写jquery代码只需两步 \1. 选择元素 \2. 操作元素 123456var $box = $(&quot;.box&quot;);// $box.css(&quot;border&quot;,&quot;5px solid #58bc58&quot;);$box.css(&#123;&apos;border&apos;:&apos;5px solid #58bc58&apos;,padding:&apos;20rem&apos;&#125;)//获取$box下面的button//let btns = $(&apos;button&apos;,$box);let btns = $(&apos;button&apos;,&apos;.box&apos;); 选择器 选择页面中的元素，得到jQuery实例对象 ID选择器$(“#save”) 类选择器$(“.class”) 标签选择器$(“div”) 复合选择器 $(“div,span,p.myClass”) 属性选择器$(‘[id=box]’) $(‘li[data-index]’):获取有data-index属性的所有元素 $(‘li[data-index!=10]’):data-index属性不等于10的元素,css目前未支持 $(‘li[data-index^=10]’):data-index属性以10开头的元素 $(‘li[data-index$=10]’):data-index属性以10结尾的元素 $(‘li[data-index*=10]’):data-index属性包含10的元素 表单选择器$(‘:input’) :radio //匹配所有单选按钮 :checkbox //匹配所有复选按钮 :selected //获取已选择的option元素 :checked //匹配所有被选中的元素(复选框、单选框等，select中的option) :submit //匹配所有提交按钮 :reset //匹配所有重置按钮 :button //匹配所有按钮 :text //匹配所有的单行文本框 :password //匹配所有密码框 可见性:hidden //匹配所有不可见元素(display:none)，或者type为hidden的元素:visible //匹配所有可见元素 以上两个选择器配合is()方法通常用于判断，返回布尔值 1234&gt; if(box.is(&apos;:visible&apos;))&#123;&gt; box.css(&apos;display&apos;,&apos;none&apos;);&gt; &#125;&gt; 常用操作 jquery对象与原生对象的转换 jquery转原生: get(0)/[0]获取集合中第一个DOM节点 get()不传参得到集合中所有的dom节点 原生转jquery: $(dom); 判断是否为jquery对象 1234var box = $(&apos;#box&apos;);if(box.jquery)&#123;&#125; 判断一个jquery对象是否存在(是否能获取到元素) length 转成原生对象再判断 筛选 利用选择器得到得结果不一定是我们想要得最终结果，有时需要进一步筛选 基本筛选 :odd/:even,:gt(n)/:lt(n) 筛选范围（索引支持负数） :contains(奥巴马) 筛选出包含“奥巴马”这三个字的元素 筛选方法 first()/last(): 获取集合中第一个/最后一个元素 eq(index|-index): 获取第N个元素,n支持负数（表示从后面查找） filter(expr|obj|ele|fn): 筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配* 的范围。用逗号分隔多个表达式 map(fn): 将一组元素转换成其他数组（不论是否是元素数组） slice(start,[end]): 选取一个从start到end(不包括end)匹配的子集 has(expr|ele): 保留包含特定后代的元素，去掉那些不含有指定后代的元素。 not(expr|ele|fn): 删除与指定表达式匹配的元素 查找 利用当前元素去查找其他元素 查找子元素 find(expr|obj|ele): 查找后代元素 children([expr]): 取得匹配元素的所有子元素。(原生js:children) 查找父级元素 parent([expr]): 获取父元素 parents([expr]): 取得所有父级元素 closest(expr|obj|ele): 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的元素 offsetParent(): 返回第一个有定位属性(absolute,relative,fixed)* 的父元素,如果没有定位父级，则返回html元素 查找兄弟元素 next([expr]): 返回下一个同辈元素 ==&gt; nextElementSibling prev([expr]): 获取前一个同辈元素 ==&gt; previousElementSibling nextAll([expr]): 获取当前元素之后所有的同辈元素 prevAll([expr]) 获取当前元素之前所有的同辈元素 siblings([expr]) 获取当前元素的所有兄弟元素（除自身以外的所有兄弟元素 = * prevAll + nextAll） jQuery动画基本动画效果 显示隐藏：show()/hide() hide(duration)通过改变元素的高度、宽度、和不透明度，直到这三个属性值到0 show(duration)通过改变元素的高度、宽度、和不透明度，直至内容完全可见 滑动（通过改变高度） slideDown([speed,callback])： 显示元素 不断改变高度，直到样式内设定的值 slideUp([speed,callback])： 不断改变高度，直到0 隐藏元素 slideToggle([speed,callback])当元素隐藏时调用slideDown()，当元素显示时调用slideUp() 淡入淡出（通过改变不透明度） fadeIn:1)显示元素2)不断改变透明度直到1 fadeOut:1)不断改变透明度直到02)隐藏元素 fadeToggle([speed,callback]) fadeTo([[speed],opacity,[fn]]) 不断改变透明度opacity，直到设定的值，并在动画完成后可选地触发一个回调函数。 PS：jQuery动画由三种预设速度slow,normal,fast（600，400，200） 自定义动画 animate (params,[speed],[fn]) :animated获取正在执行动画的元素，一般与is()方法配合使用，用于判断元素是否处于动画状态 动画队列 一个元素上的动画： 当animate中存在多个属性时，动画同时发生 当同一个元素链式调用animate时，动画是按顺序发生(队列) 不同元素上的动画： 默认情况下，动画同时发生 回调函数内的动画等到当前动画执行完后才接着执行 stop([clearQueue],[jumpToEnd])不加参数：停止当前元素所有《正在运行》的动画。 clearQueue:值为true时，清除队列 jumpToEnd:值为true时，跳到当前动画的最后一帧 delay(duration)设置一个延时来推迟执行队列中之后的动画。 duration:延迟的时间 [案例]\1. 手风琴效果\2. 自动轮播图效果 DOM节点操作增删改 创建jquery对象 12$(&apos;&lt;div/&gt;&apos;);$(&apos;&lt;div&gt;生成一个div&lt;/div&gt;&apos;); 元素添加 内部添加（添加为子元素） append(content|obj|ele|fn): 在元素内部最后面追加内容（后置） prepend: 向元素内部增加内容（前置） appendTo,prependTo 外部插入内容（添加为兄弟元素） after: 在元素后面插入内容 before: 在元素前面插入内容 insertAfter,insertBefore 如果页面上已经存在了要添加的元素，append,prepend,after,before会把元素移动到页面相应的位置 元素删除 remove(); 删除元素, 虽然元素从文档中删除了，但js内部依然保留对它引用 empty(); 清空内容 元素复制 clone([Event[,deepEvent]]) Event：（true 或 false）是否复制元素的行为，默认为false deepEvent: （true 或 false）是否复制子元素的行为，默认为Even的值 盒模型属性 .offset():获取匹配元素相对于根元素的偏移量返回一个对象，包含当前元素的top,left值 position():获取匹配元素相对(有定位属性)父元素的偏移量，如果没有定位父级，则相对于根元素(html)，返回一个对象，包含当前元素的top,left值。 width(v) = width; //取值/赋值,当传入v时，相当于css(‘width’,v); innerWidth() = width + padding; &lt;==&gt; clientWidth outerWidth() = width + padding + border; &lt;==&gt; offsetWidth outerWidth(true) = width + padding + border + margin; 事件常用事件方法 鼠标事件 click([[data],fn]) //点击时触发 click = mousedown + mouseup dblclick([[data],fn]) //双击事件 dblclick = 2*click mousedown([[data],fn]) mouseup([[data],fn]) mousemove([[data],fn]) mouseout([[data],fn]) mouseover([[data],fn]) mouseenter([[data],fn]) //事件不会冒泡 mouseleave([[data],fn]) ) //事件不会冒泡 键盘事件 keydown([[data],fn]) //键盘按下时触发 keypress([[data],fn])//字符按键 keyup([[data],fn]) //键盘弹起时触发 表单事件 blur([[data],fn]) //失去焦点时触发 focus([[data],fn]) //获得焦点 change([[data],fn]) //值改变并失去焦点时触发 submit([[data],fn]) 其他事件 resize([[data],fn]) //元素大小改变时触发 scroll([[data],fn]) //滚动时触发 jquery事件绑定与移除 on(type,[selector],fn) selector: 把本来绑定给selector的事件委托给它的父级 事件命名空间, 自定义事件（对事件加以细分）格式：事件类型.自定名字 一次性绑定多个事件，事件之间以空格隔开 支持自定义事件的绑定$(ele).on(&#39;laowang&#39;,function(){})触发自定义事件：$(ele).trigger(‘laowang’); off: 清除绑定事件 off(‘click’);//清除当前元素的点击事件 off();//清除当前元素所有事件 off(‘click mouseover’) 一次性清除多个事件，事件之间以空格隔开 off(‘click.output’) 清除命名空间事件 其他事件方法 hover(enter[,leave]) enter:鼠标移入时执行 leave:鼠标移出时执行 hover方法内部使用mouseenter + mouseleave来实现效果 trigger(type): 手动触发事件（即使事件没有发生，也能执行事件处理函数） triggerHandler(type): 这个方法会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认行为，也不会产生事件冒泡 阻止浏览器默认行为event.preventDefault(); 阻止事件传播event.stopPropagation(); 两者一起阻止：return false; ajaxjQuery的ajax方法 $.ajax(settings) type:请求类型，默认GET url:数据请求地址（API地址） data:发送到服务器的数据对象，格式：{Key:value}。 success:请求成功时回调函数。 dataType:设定返回数据的格式，json, jsonp, text(默认), html, xml, script async：是否为异步请求，默认true $.get(url,[data],[fn],[dataType]) // type:’get’ $.post(url,[data],[fn],[dataType]) // type:’post’ $.getJSON(url,[data],[fn]) // type:’get’, dataType:’json’ $.getScript(url,[callback]) // type:’get’, dataType:’script’ load(url,[data],[callback]) 载入远程 HTML 文件代码并插入页面中。 [案例] 加载html文件 滚动加载（懒加载） 插件了解插件 什么是插件插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过js文件的方式引用。 插件分类UI类、表单及验证类、输入类、特效类、Ajax类、滑动类、图形图像类、导航类、综合工具类、动画类等等 常用插件： jqueryUI //官方插件，功能多且全面，官网：www.jqueryui.com jquery.validation //表单验证插件,官网：https://jqueryvalidation.org/ jquery.easyUI //是一组基于jQuery的UI插件集合,Demo：http://www.jeasyui.net/ bootstrap //是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目，官网：http://v3.bootcss.com/ highcharts https://www.hcharts.cn 使用插件 引入插件的步骤 引入jquery.js文件，必须在所有插件之前引入 引入插件 引入插件相关文件，比如样式、语言包等 [案例]jqueryUI[案例]jquery.validation 编写jquery插件 插件形式分为3类： 封装对象方法插件，扩展原型对象方法 封装全局函数插件（静态方法），如$.each,$.map,$.makeArray… 选择器插件(类似于.find()) 自定义插件的规范（降低各种插件之间的冲突，减少错误机率） 命名规范：jquery.插件名.js 插件中的this应该指向jQuery实例 使用this.each()迭代元素,为了实现多个调用 插件内部必须返回jQuery实例(this)，便于链式调用 所有的对象法附加在jQuery.fn对象(jQuery.prototype)上面，所有静态附加在jQuery上 所有的方法或插件必须用分号结尾，避免出问题,为了保证插件的安全性，也可以在插件开始的地方加分号 避免插件内部的$冲突，请传递jQuery($并不是总等于jQuery，另外其他js框架也可能使用$) 1最终格式：;(function($)&#123;$.fn.插件名=function()&#123;&#125;&#125;)(jQuery); 编写插件常用方法 $.extend([d],target,obj1,obj2,…,[objN]) //扩展对象或jQuery对象本身。用来扩展jQuery全局函数 用obj1-objN对象来扩展target对象 只有一个参数时，用来扩展jQuery全局函数：$.extend({‘hobby’:’撸串’})$.ajax,$.map,$.each d:是否深拷贝,布尔类型（true,false） $.fn.extend() //扩展 jQuery元素集合提供新的方法（扩展jQuery原型对象，通常用来制作插件）。 1234567$.fn.extend(&#123; xPopover()&#123;&#125;, xAjax()&#123;&#125;, xAjax()&#123;&#125;, xAjax()&#123;&#125;, xAjax()&#123;&#125;&#125;) [作业] 编写轮播图插件，要求如下： 是否自动轮播 是否显示小图 是否显示左右按钮 可设置轮播间隔时间 轮播类型: fade:淡入淡出, vertial:垂直滚动, horizontal:水平滚动, show:幻灯片 默认显示第几张图片 常用jQuery原型对象的方法 写在jQuery原型对象中的方法，通过jQuery实例调用 css(attr[,val]): 获取/改变元素style属性（内联样式） 取值：css(attr),css([‘color’,’text-align’]) &lt;==&gt; getComputedStyle[attr] 赋值：css(attr,val),css({attr:val}); val(v): 获取/设置匹配表单元素的值（等同于原生js中的value属性） 取值：input.val() 赋值： 1input.val(v) v:字符串 v:数组（一般用于单选/复选框的勾选） v:函数function(idx,val){ return 值}//函数内部一定要返回值 html(): （等同于原生js中的innerHTML）取值div.html()：取得第一个匹配元素的html内容赋值div.html(‘:’)：设置匹配元素的内容 text(): 取得所有匹配元素的文本内容。 addClass()/removeClass(): 添加/删除类,支持多个类同时添加或删除 toggleClass(): 如果存在（不存在）就删除（添加）类。 hasClass(‘con’): 判断当前元素是否包含con这个类，返回布尔值（不支持多个类进行判断） eq(n) 获取第N个jquery对象（元素）,n支持负数（表示从后面查找） index():获取当前元素在同辈元素中的索引值 1$(this).index(); 显示/隐藏 show()：显示元素 hide()：隐藏元素 带参数：同时改变width,height,opacity的动画 is(expr|obj|ele|fn) 根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，其中如果有一个元素符合这个给定的选择器表达式就返回true。如果没有元素符合，或者表达式无效，都返回false。 attr(name[,val]) 设置/获取html标签属性 prop(attr[,val]) 获取/设置DOM节点属性（一般修改布尔类型属性） 获取：获取在匹配的元素集中的第一个元素的属性值。 赋值：给集合中所有元素属性赋值 val为函数 123$(&apos;:checkbox&apos;).prop(&apos;checked&apos;,function(idx,oldVal)&#123; return !oldVal;&#125; each(function(idx,ele){}) //用于遍历jquery对象 return true;// 跳过当前循环，进入下一个循环（等效原生js中得continue） return false;// 退出整个each循环（等效原生js中得break） jquery大部分方法的共性： 无参数时为取值，带参数时为赋值 取值：取得第一个匹配元素的值 赋值：设置所有匹配元素的值 隐式迭代（隐式遍历）：看不见的遍历，大部分的jquery方法都支持隐式迭代 常用jQuery静态方法 $.each(arr|obj,callback)：通用遍历方法，用于遍历对象和数组。 callback(idx,item) $.map(arr|obj,callback)：根据现有数组生成一个新的数组，新数组的元素为callback内return的值 callback(item,idx) $.type(n)：检测参数n的数据类型 $.makeArray(obj) //将类数组对象转换为数组。 $.parseJSON(json) //接受一个JSON字符串，返回解析后的对象。类似原生js中的JSON.parse $.inArray(value,array,[fromIndex]) //确定value在数组array中的位置，从0开始计数(如果没有找到则返回 -1 )，一般用于判断数组中是否包含某一字符。 serialize()/serializeArray() : 只能在form表单中使用，并且表单元素必须有name属性 [练习] 无限级菜单 名单过滤 选项卡 楼梯 jquery实现表单验证 根据数据生成表单 购买商品飞入购物车效果 水平手风琴效果 模拟QQ发送消息 自动居中弹窗 编写放大镜插件 [扩展] 可编辑表格 上下左右方向键定位单元格 回车编辑单元格 失去焦点保存数据 复制行 删除行]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(插件封装解析)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F17.%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[弹窗插件function Popover(options){ //1.设置默认值，与传进来的对下那个进行合并 var defaults = { width:600, height:&apos;auto&apos;,//可以是数值 position:&apos;center&apos;,//可以传进来对象{x,y} title:&apos;弹窗标题&apos;, content:&apos;&apos;, draggable:true, overlay:0.3 //数字：有遮罩层，false：无遮罩层 } var opt = Object.assign({},defaults,options); this.position = opt.position; this.init(opt); } Popover.prototype = { init(opt){ //2.初始化方法： //（1）创建弹窗this.ele，设置宽高 this.ele = document.createElement(&apos;div&apos;); this.ele.className = &apos;popover&apos;; this.ele.style.width = opt.width + &apos;px&apos;; if(typeof opt.height === &apos;number&apos;){ this.ele.style.height = opt.height + &apos;px&apos;; } //（2）标题和内容（设置类名title、content） var title = document.createElement(&apos;div&apos;); title.className = &apos;title&apos;; title.innerHTML = opt.title; this.ele.appendChild(title); var content = document.createElement(&apos;div&apos;); content.className = &apos;content&apos;; content.innerHTML = opt.content; this.ele.appendChild(content); // (3)遮罩层(判断overlay是数字则为透明度，为false则不设置遮罩层)（类名、透明度） if(opt.overlay !== false){ this.bg = document.createElement(&apos;div&apos;); this.bg.className = &apos;overlay&apos;; this.bg.style.opacity = opt.overlay; document.body.appendChild(this.bg); } // （4）删除按钮（类名、内容） var btnClose = document.createElement(&apos;span&apos;); btnClose.className = &apos;btn-close&apos;; btnClose.innerHTML = &apos;&amp;times;&apos;; this.ele.appendChild(btnClose); // （5）弹窗写入页面，并显示弹窗 document.body.appendChild(this.ele); this.show(); // （6）设置关闭事件 btnClose.onclick = function(){ this.close(); }.bind(this); //（7）拖拽 if(opt.draggable){ this.drag(); } }, //3.1显示：设置成块，同时调用定位方法 show(){ this.ele.style.display = &apos;block&apos;; if(this.bg){ this.bg.style.display = &apos;block&apos;; } this.setPosition(); }, //3.2隐藏： close(){ this.ele.style.display = &apos;none&apos;; if(this.bg){ this.bg.style.display = &apos;none&apos;; } }, //4.定位：判断是否传参 //（1）若没有参数，即x值为undefined，则判断this.postion的值为center还是对象，设置x、y值 //（2）给元素设置样式 setPosition(x,y){ if(x===undefined){ // 如果元素没有添加(并显示)到页面，获取不到宽高 if(this.position === &apos;center&apos;){ x = (window.innerWidth - this.ele.offsetWidth)/2; y = (window.innerHeight - this.ele.offsetHeight)/2; }else if(typeof this.position === &apos;object&apos;){ x = this.position.x; y = this.position.y; } } this.ele.style.left = x + &apos;px&apos;; this.ele.style.top = y + &apos;px&apos;; }, //5.拖拽 drag(){ var self = this; var pop = self.ele; pop.onmousedown = e=&gt;{ var ox = e.clientX - pop.offsetLeft; var oy = e.clientY - pop.offsetTop; // 只能在标题位置拖拽 if(oy&gt;pop.children[0].offsetHeight){ return; } document.onmousemove = function(evt){ var x = evt.clientX - ox; var y = evt.clientY - oy; self.setPosition(x,y); evt.preventDefault(); } } document.onmouseup = function(){ document.onmousemove = null; } } 弹窗继承//确认对话框 function Confirm(options){ var defaults = { width:300, title:false, content:&apos;你确定这个操作吗&apos;, overlay:false, confirm:function(){}, cancel:function(){} } var opt = Object.assign({},defaults,options); //1.借用构造函数，拿到弹窗对象属性this.ele及this.position Popover.call(this,opt); } // 2.继承Popover的方法 Confirm.prototype = Object.create(Popover.prototype); //3.添加/重置方法 Confirm.prototype.init = function(opt){ //3.1把你需要的部分复制下来 //3.2添加确认取消按钮 this.confirmBtn = document.createElement(&apos;button&apos;); this.confirmBtn.className = &apos;btn-confirm&apos;; this.confirmBtn.innerText = &apos;确认&apos;; this.cancelBtn = document.createElement(&apos;button&apos;); this.cancelBtn.className = &apos;btn-cancel&apos;; this.cancelBtn.innerText = &apos;取消&apos;; this.ele.appendChild(this.confirmBtn); this.ele.appendChild(this.cancelBtn); // 3.3点击确认取消按钮，执行方法 this.confirmBtn.onclick = ()=&gt;{ opt.confirm(); this.close(); } this.cancelBtn.onclick = ()=&gt;{ opt.cancel(); this.close(); } 时间格式化1234567891011121314151617181920212223242526if(!Date.prototype.format)&#123; Date.prototype.format = function(fmt)&#123; //fmt格式：“YYYY-MM-DD hh:mm:ss” var o = &#123; &quot;M+&quot; : this.getMonth()+1, &quot;D+&quot; : this.getDate(), &quot;h+&quot; : this.getHours(), &quot;m+&quot; : this.getMinutes(), &quot;s+&quot; : this.getSeconds() &#125;; if(/(Y+)/.test(fmt))&#123; var res = String(this.getFullYear()).substr(4-RegExp.$1.length); fmt = fmt.replace(RegExp.$1,res); &#125; for(var str in o)&#123; var reg = new RegExp(&apos;(&apos;+str+&apos;)&apos;); if(reg.test(fmt))&#123; var res = RegExp.$1.lenth&gt;1? (&quot;00&quot;+o[str]).substr(String(o[str]).length) : o[str]; //9===&gt;009.substr(1) //0012===&gt;0012.substr(2) fmt = fmt.replace(RegExp.$1,res); &#125; &#125; return fmt; &#125;&#125; 1234567var str = &quot;X98Y87Z65&quot;;// 三个数字部分加了小括号，表示子表达式var reg = /^X(\d+)Y(\d+)Z(\d+)$/;reg.test(str); // 此处使用exec()等其他正则表达式的匹配方法也可，下同document.writeln(RegExp.$1); // 98document.writeln(RegExp.$2); // 87document.writeln(RegExp.$3); // 65 简化DOM节点操作12345678910* 面向对象的DOM操作* show()：显示* hide()：隐藏* on()：事件绑定* css()：获取/设置Css样式* addClass()：添加类名* removeClass()：移除类名* attr():获取/设置html属性值* html()：设置/获取html内容* text()：设置/获取文本内容 class xJquery{ // 1.this.ele获取初始化 constructor(selector){ // 1.1若不是传入字符串，则可能传入DOM节点（判断选择器的标签名是否存在）或类数组Array。 // this.ele得到值，退出该函数 if(typeof selector != &apos;string&apos;){ if(selector.tagName){ this.ele = [selector]; }else{ this.ele = selector; } return; } //1.2若传入的是选择器 try{ this.ele = document.querySelectorAll(selector);//Nodelist }catch(error){ var selectorName = selector.slice(1); if(/^#/.test(selector)){ //变成数组为的是后面的遍历 this.ele = [document.getElementById(selectorName)];//Array }else if(/^\./.test(selector)){ try{ this.ele = document.getElementsByClassName(selectorName);//HTMLCollection }catch(err){ this.ele = []; var res = document.getElementByTagName(&apos;*&apos;); for(var i=0;i&lt;res.length;i++){ var className = res[i].className.split(&apos; &apos;); if(className.indexOf(selectorName)&gt;=0){ this.ele.push(res[i]); } } } }else{ //getElementsByTagName this.ele = document.getElementsByTagName(selector); } } } //2.显示隐藏方法 show(){ Array.prototype.forEach.call(this.ele,function(ele){ ele.style.display = &apos;block&apos;; }); // 方便链式调用 return this; } hide(){ Array.prototype.forEach.call(this.ele,function(ele){ ele.style.display = &apos;none&apos;; }); return this; } // 3.事件绑定 on(type,handler,isCapture){ Array.prototype.forEach.call(this.ele,function(ele){ try{ ele.addEventListener(type,handler,isCapture) }catch(error){ try{ ele.attachEvent(&apos;on&apos; + type,handler); }catch(err){ ele[&apos;on&apos;+type] = handler; } } }); return this; } // 4.获取/设置Css样式 css(key,value){ // 若没有传入value，则代表获取值，只获取第一个元素的值 if(value === undefined){ if(window.getComputedStyle){ return getComputedStyle(this.ele[0])[key] }else if(this.ele[0].currentStyle){ return this.ele[0].currentStyle[key] }else{ return this.ele[0].style[key] } } // 设置，则设置所有元素的值 Array.prototype.forEach.call(this.ele,function(ele){ ele.style[key] = value; }) return this; } // 5.给所有元素添加类名 addClass(name){ Array.prototype.forEach.call(this.ele,function(ele){ try{ ele.classList.add(name); }catch(error){ var className = ele.className.split(&apos; &apos;); if(className.indexOf(name) == -1){ className.push(name); } ele.className = className.join(&apos; &apos;); } }) } // 6.移除所有元素的该类名 removeClass(name){ Array.prototype.forEach.call(this.ele,function(ele){ ele.classList.remove(name) }); } // 7.设置/获取html内容 html(html){ // 获取第一个元素的html内容 if(html === undefined){ return this.ele[0].innerHTML } // 设置所有元素的html内容 Array.prototype.forEach.call(this.ele,function(ele){ ele.innerHTML = html; }); return this; } // 设置/获取文本内容 text(txt){} } //执行$(selector)，返回实例对象 let $ = function(selector){ return new xJquery(selector); }]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(版本管理之SVN)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F16.SVN%2F</url>
    <content type="text"><![CDATA[版本管理版本的概念版本管理的好处及种类 RCS（Revision Control System）即程序改版控制系统，主要功能是用来管理文件的版本，可以节省空间和时间。这样就不需要在每个程序开发到某一个阶段就将数据拷贝到其他的地方备份起来了。 CVS（Concurrent Version System）现代管理里工具始祖 SVN（Subversion）集中式管理工具的集大成者 GIT分布式版本管理工具（后面讲解） SVNSVN是Subversion的简称，是一个集中式代码管理版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。 集中式：\1. 需要中心服务器\2. 需要联网 服务器安装下载：https://www.visualsvn.com/downloads/ 客户端安装下载：https://tortoisesvn.net/downloads.zh.html 使用基本操作 迁出（SVN Checkout）：获取远程仓库(服务器)内容 必须在非svn目录中操作 拿到服务器仓库地址（URL of repository） 获得用户名密码 更新（SVN Update）：同步文件 当迁出相应目录后，如果他人对服务器上此目录内容进行了修改，则需要再次获取改动内容到本地目录的过程称为更新 提交(SVN Commit)：把本地修改提交到服务器 每次提交前，都要先Update一下，确保更新到服务器最新版本后再提交 填写关于本次更新的日志（log message），这是必填项，否则commit会失败 每成功提交一次，SVN版本号自动加1 其他操作 增加文件(Add) 检查更新（Check for modifications） 删除文件（Delete） 撤销更改（Revert） 锁定和解锁（Get lock and Release lock）当项目需要时可以在本地硬盘中将迁出的内容进行锁定，选中要被锁定的文件右键选择“Tortoise SVN”的“Get lock…”项进行锁定（锁定后他人将无法修改此文件），系统弹出锁定信息框。 当文本文件锁定后，需要通过解锁他人才能继续对文件进行修改。 重命名文件（Rename） 获取历史文件（Show log） 利用SVN管理代码一天的工作流程： 从服务器下载项目组最新代码。 然后进行工作，每隔一段时间向服务器自己的分支提交一次代码。 下班时间快到了，把自己的代码合并到服务器上，一天的工作完成。 利用svn管理微信飞机大战游戏版的本术语 Revision (修订版本)－－文件历史记录中的被开发者提交的变化。一个修订版本就是一个时常变化的项目的 snapshot (瞬态图)。 Repository (源代码库)－－CVS 存储所有修订版本历史记录的地方。每个项目都有自己的一个确定的源代码库。 Working copy (工作拷贝)－－开发者对文件作出修改时文件所在的拷贝。 Check out (检验)－－从源代码库中申请一份工作拷贝。该工作拷贝反映的是取出时项目的瞬时状态。当开发者对拷贝作出修改时，必须运用 commit (提交)和 update (更新) 命令来 “发布”变化和查看其他开发者所作的修改。 Commit (提交)－－将工作拷贝中的变化输入中央源代码库。 Log message (日志信息)－－提交修订版本的时候，附带描述变化的注解。通过查阅记录信息，人们可以获得一个当前项目进程的总结。 Update (更新)－－从源代码库中取出别人的修改数据，将其输入自己的工作拷贝，并显示自己的工作拷贝是否有未提交的修改。注意，不要和 commit (提交)混淆，更新和提交是一对互补的指令。记住： Update 将使工作拷贝和源代码库拷贝保持同步更新。 Conflicts (冲突)－－两个开发者对同一个区域所做的改动都提交给主版本时出现的情况，在 CVS 觉察并指出这个冲突后，开发者必须解决该冲突。]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(面向对象简介)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象了解面向对象面向对象是利用对象进行编程的一种思想（Object-oriented programming,缩写:OOP） javascript两种开发模式 面向过程 面向对象 面向对象和面向过程的区别 小狗觅食（闻一闻smell、舔一舔lick、咬一咬bite） 分别采用面向过程和面向对象来分析 面向过程（主角是小狗） : 先闻一闻, 然后再舔一舔, 最后再咬一咬 面向对象（主角是我）: 我首先要有一只小狗, 它可以闻一闻食物, 可以舔一舔食物, 可以咬一咬食物。 然后我对小狗说：旺财去闻一闻，旺财去舔一舔，旺财去咬一口 (指挥小狗) 对象的组成 属性(变量)： 对象有什么 方法(函数)： 对象能做什么 练习如何描述一个对象 描述一个人 描述购物车 QQ聊天窗口 如何创建对象 字面量var student = {id:10,name:&#39;小明&#39;,age:18} 构造函数 1234var student = new Object()student.id = 10;student.name = &apos;王铁锤&apos;;student.age = 18; 以上两种方式的缺点：使用同一个接口创建很多对象，会产生大量的重复代码 封装工厂函数为了减少重复代码，对上述代码进行封装 缺点: 无法识别对象是由谁生成的 自定义构造函数（重点）12345678function Student(name, age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;&#125;var s1 = new Student(&quot;王铁锤&quot;, 18); new调用构造函数时经历以下4步（重要）： 创建一个Object对象 将构造函数的this指向这个对象 执行构造函数中的代码 返回Object对象 实例 用new关键字生成的对象称为实例 实例包含一个内部属性[[prototype]]，指向原型对象 构造函数与普通函数的区别 唯一区别：调用方式不同 任何函数，只要通过new操作符来调用，它就可以作为构造函数； 而任何构造函数，如果不通过new 操作符来调用，那它跟普通函数无区别。 约定：构造函数名首字母大写 this函数中的this作为JS的关键字，有特殊的含义，代表了当前对象，而当前对象是谁，由函数执行时所处的环境来决定 this好比一句话, 出自不同人之口, 代表的人就不一样如A和B吵架：A对B说: “老子要弄死你! ” , 这里的老子指AB对A说: “好怕怕，你吓死老子了 ”, 这里的老子指B 用new关键字调用：this指向生成的实例对象 普通函数调用：this指向调用函数的对象 实际应用构造函数方法很好用，但是单独使用存在一个浪费内存的问题（所有的属性/方法都写入实例中）。这样既不环保，也缺乏效率。 解决方案:构造函数+原型对象 构造函数中添加属性 原型对象中添加方法 实例中的属性减少了，原型对象中的方法又能被所有的实例共享，最大限度的节省了内存 原型对象 constructor：指向构造函数 原型对象中的属性和方法可以让所有对象实例共享 属性的访问规则 如何获取原型对象 通过构造函数：prototype 通过实例 FF,Chrome：__proto__； ES5方式：Object.getPrototypeOf(实例)； [构造函数、原型对象和实例的关系图] 判断 判断原型和实例的关系（返回布尔值） constructor: 一般用于判断该实例是否由某一构造函数生成实例.constructor == Student //true instanceof: 检测某个对象是不是某一构造函数的实例 12实例 instanceof Student //true实例 instanceof Object //true isPrototypeOf: 判断当前对象是否为实例的原型原型对象.isPrototypeOf(实例) //true 总结：面向对象其实只做两件事情 创建并描述对象 添加属性 添加方法 添加方法遵循单一原则：一个方法只做一件事情 操作对象指挥对象实现某种效果 匿名函数 匿名函数与具名函数的区别 匿名函数自动执行 123(function()&#123; alert(&quot;abc&quot;);&#125;)(); 使用()将匿名函数包围，然后再调用,这叫做匿名函数的自运行 匿名函数传参 [案例] 烟花效果 弹幕效果 [练习] 采用面相对象改造轮播图 [作业] 面向对象的弹窗 是否可拖拽 自定义宽高 自定义标题、内容 可关闭弹窗 [扩展] 面向对象放大镜效果 ES5对象扩展(了解) 属性特性 Object.create(prototype)以指定的原型创建对象 Object.defineProperty(object, propertyname, descriptor)对指定的对象的一个属性设置属性特性 值属性 configurable可配置性，控制着其描述的属性的修改，表示能否修改属性的特性 enumerable可枚举性，表示能否通过for-in遍历得到属性 writable可写性，表示能否修改属性的值 value数据属性，表示属性的值。默认值为undefined 访问器属性 configurable enumerable get在读取属性时调用的函数。只指定get则表示属性为只读属性。默认值为undefined set在写入属性时调用的函数。只指定set则表示属性为只写属性。默认值为undefined Object.defineProperties(object, descriptors)对指定的对象的一组属性设置属性特性 Object.getOwnPropertyDescriptor(object, propertyname)返回属性特性 Object.keys(object)返回对象所有可枚举属性的名称 Object.getOwnPropertyNames(object)返回所有属性的名称（哪怕说是不能枚举的属性） 下节预习 PHP]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(继承)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F15.%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型链实例与Object原型对象之间的链条称为原型链 原型模式的访问机制（原型搜索机制） 读取实例对象的属性时，先从实例对象本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值； 如果没有找到，则继续搜索实例的原型对象，如果在原型对象中找到了这个属性，则返回该属性的值 如果还是没找到，则向原型对象的原型对象查找，依此类推，直到Object的原型对象（最顶层对象）； 如果再Object的原型对象中还搜索不到，则抛出错误； 演示：画图讲解原型链继承继承继承是面向对象中一个非常重要的特征。指的是：子类继承父类的属性和方法。 我们可以通过继承的方式, 在父类的属性和方法基础上, 让子类也拥有这些属性和方法, 并可以扩展。 继承的好处: 子类拥有父类所有的属性和方法（代码复用）； 子类可以扩展自己的属性和方法（更灵活）； 子类可以重写父类的方法 继承方式原型链继承 核心：拿父类实例来充当子类原型对象 缺点： 无法操作父类构造函数的属性 123456789101112131415161718function Person(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender; &#125;Person.prototype = &#123; say()&#123;console.log(`大家好，我叫$&#123;this.name&#125;，欢迎跟大家交朋友`)&#125; &#125;Object.defineProperty(Person.prototype,&apos;constructor&apos;,&#123; configurable:true, value:Person&#125;);let lemon = new Person(&apos;lemon&apos;,32,&apos;女&apos;);//===============原型链继承==========function Man(name,age)&#123;&#125;Man.prototype = new Person();let laoxie = new Man(&apos;laoxie&apos;,18); 借用构造函数核心：借父类的构造函数来增强子类实例，相当于把父类的实例属性复制一份给子类实例 call： 格式：父类构造函数.call(子类实例,参数1,参数2,参数3…) apply： 格式：父类构造函数.apply(子类实例,[参数1,参数2,参数3…])call与apply的唯一区别：传参方式不同，call多个参数，apply只有两个参数，第二个参数为数组 123//aplly用法：借用方法var arr = [20,2,40,33,21,8,22,46,32]Math.max.apply(null,arr) 组合继承由于以上继承方法的缺点，实际开发中不可能单纯的只使用一种继承方法，而是利用它们的优点，规避它们的缺点，所以就有了组合继承法 继承属性：借用构造函数 只在构造函数中定义属性 继承方法：原型链继承 把所有的方法写入原型对象 组合继承是最常用的继承模式。 缺点（原型链继承法的缺点）： 在原型对象中生成多余的属性 多次执行父类构造函数 1234//原型链继承基础上补充借用构造函数function Man(name,age)&#123; Person.call(this,name,age,&apos;男&apos;);&#125; 原型式继承 核心：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例 解决原型链继承法的缺点：生成多余的属性 123456function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;Man.prototype = object(Person.prototype); ES5版本的原型式继承：Object.create() 寄生组合继承法完美的继承方法 核心： 继承属性：借用构造函数 继承方法：原型式继承 ES6继承Class定义类 写在类里面的方法实际是给Person.prototype添加方法 constructor方法是类的默认方法，相当于在构造函数内生成属性 extends继承 子类继承了父类，在子类构造函数中必须调用super方法。 子类的constructor方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。 静态方法如果在一个方法前，加上static关键字，这就称为“静态方法” 静态方法方法不会被实例继承，而是直接通过类来调用Person.getInfo() 父类的静态方法，可以被子类继承Man.getInfo() 1234567891011121314151617181920class Person&#123; constructor(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender; &#125; // 此处的方法写入原型对象中 say()&#123;console.log(大家好,我叫$&#123;this.name&#125;)&#125;； static eat()&#123;console.log(&apos;我是吃货&apos;);&#125;&#125;let lemon = new Person(&apos;lemon&apos;,32,&apos;女&apos;);// 继承方法class Man extends Person&#123; constructor(name,age)&#123; // 继承属性 super(name,age,&apos;男&apos;); this.hobby = [&apos;吃&apos;,&apos;喝&apos;]; &#125;&#125;let laoxie = new Man(&apos;laoxie&apos;,18); call和apply的使用1234567* 求数组中最大数和最小数 * Math.max() * Math.min()* 类数组使用map* 判断数据类型 * typeof * Object.prototype.toString()]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(闭包与继承)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F15.%E9%97%AD%E5%8C%85Closure%26Inherit%2F</url>
    <content type="text"><![CDATA[闭包闭包是这样一种机制: 函数嵌套函数, 内部函数可以引用外部函数的参数和变量,参数和变量不会被垃圾回收机制所收回. 这里涉及到几个概念: 函数嵌套函数 作用域(全局变量和局部变量)变量的访问规则 垃圾回收机制(garbage collection)js内部不断扫描内存,并清理无引用对象(自动完成); 123456789101112131415161718function aa()&#123; var num=10; function bb()&#123; num++ console.log(num); &#125; return bb;&#125;//bb(); //无法直接访问函数内部的函数aa()();//11aa()();//11aa()();//11var closure = aa();closure();//11closure();//12closure();//13 闭包的好处 可以让一个变量长期驻扎在内存当中不被释放 避免全局变量的污染, 和全局变量不同, 闭包中的变量无法被外部使用 私有成员的存在, 无法被外部调用, 只可以自己内部使用 结论： 闭包是指有权访问另一函数作用域中的变量的函数 闭包，可以访问函数内部的局部变量，并让其长期驻留内存 由于闭包会携带包含它的作用域(运行环境)，因此会比其他函数占用更多内存，过度使用闭包可能会造成性能问题。 [案例] 点击按钮打印当前索引值 tab标签切换 原型链实例与Object原型对象之间的链条称为原型链 原型模式的访问机制（原型搜索机制） 读取实例对象的属性时，先从实例对象本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值； 如果没有找到，则继续搜索实例的原型对象，如果在原型对象中找到了这个属性，则返回该属性的值 如果还是没找到，则向原型对象的原型对象查找，依此类推，直到Object的原型对象（最顶层对象）； 如果再Object的原型对象中还搜索不到，则抛出错误； 重置原型对象重置原型对象，可以一次性给原型对象添加多个方法，但切断了与原来原型对象的联系 12345function Popover()&#123;&#125;Popover.prototype = &#123; show:function()&#123;&#125;, hide:function()&#123;&#125;&#125; 注意覆盖问题 注意识别问题 内置原型对象使用内置原型可以给已有构造函数添加方法 数组/字符串/数字等方法调用原理 扩展内置方法 对象属性的遍历与判断 for…in：遍历对象中的所有可枚举属性, 无论该属性存在于实例中还是原型中 in：只要通过对象能够访问到属性就返回true, 无论该属性存在于实例中还是原型中 123if(name in s1)&#123;&#125; 对象.hasOwnProperty(属性)：检测一个 1属性 是存在于 1对象 本身中 返回true，说明属性存在对象中 返回false，说明属性不存在或在原型中 检测一个属性是否存在于原型中：!obj.hasOwnProperty(name) &amp;&amp; (name in obj) 继承继承是面向对象中一个非常重要的特征。指的是：子类继承父类的属性和方法。 我们可以通过继承的方式, 在父类的属性和方法基础上, 让子类也拥有这些属性和方法, 并可以扩展。 继承的好处: 子类拥有父类所有的属性和方法（代码复用）； 子类可以扩展自己的属性和方法（更灵活）； 子类可以重写父类的方法 继承方式原型链继承 核心：拿父类实例来充当子类原型对象 缺点： 无法继承构造函数中的属性 创建子类实例时，无法向父类构造函数传参 原型对象中存在多余的属性 借用构造函数 核心：借父类的构造函数来增强子类实例，相当于把父类的实例属性复制一份给子类实例 call：格式：父类构造函数.call(子类实例,参数1,参数2,参数3...) apply： 格式： 1父类构造函数.apply(子类实例,[参数1,参数2,参数3...]) call与apply的唯一区别：传参方式不同，call多个参数，apply只有两个参数，第二个参数为数组 123//aplly用法：借用方法var arr = [20,2,40,33,21,8,22,46,32]Math.max.apply(null,arr) 缺点： 无法实现函数复用 函数太多就会影响性能，占用更多内存 组合继承由于以上继承方法的缺点，实际开发中不可能单纯的只使用一种继承方法，而是利用它们的优点，规避它们的缺点，所以就有了组合继承法 继承属性：借用构造函数 只在构造函数中定义属性 继承方法：原型链继承 把所有的方法写入原型对象 组合继承是最常用的继承模式。 缺点（原型链继承法的缺点）： 在原型对象中生成多余的属性 多次执行父类构造函数 原型式继承 核心：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例 解决原型链继承法的缺点：生成多余的属性 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; ES5版本的原型式继承：Object.create() 寄生组合继承法 完美的继承方法 核心： 继承属性：借用构造函数 继承方法：原型式继承 ES6中的继承Class定义类ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类 12345678910//定义类class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; getInfo() &#123; return `我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`;; &#125;&#125; 写在类里面的方法实际是给Person.prototype添加方法 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。如果没有constructor方法，则得使用默认的constractor方法 extends继承1234567891011121314class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125;&#125;class Man extends Person &#123; constructor(name, age, gender) &#123; //this.gender = gender; // 报错 super(name, age); this.gender = gender; // 正确 &#125;&#125; 子类继承了父类，在子类构造函数中必须调用super方法。 子类的constructor方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。 静态方法如果在一个方法前，加上static关键字，这就称为“静态方法” 12345678910111213class Person &#123; constructor()&#123; this.name = &apos;laoxie&apos;, this.age = 18; &#125; static getInfo()&#123; return this.name &#125; say()&#123; console.log(`Hello everyone, my name is $&#123;this.name&#125;, I&apos;m $&#123;this.age&#125; years old`) &#125;&#125;class Man extends Person &#123;&#125; 静态方法方法不会被实例继承，而是直接通过类来调用Person.getInfo() 父类的静态方法，可以被子类继承Man.getInfo() [案例] 扩展原生js方法 兼容字符串trim方法 获取ascii码的方法 反编译ascii码的方法]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(Animation动画方法)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F14.Animation%2F</url>
    <content type="text"><![CDATA[Animation（一）运动原理不断改变对象的属性产生动画的效果 （二）动画分类匀速运动速度保持不变的运动 案例：飞翔的小鸟123456789101112131415//1.获取元素及初始化速度变量let bird = document.querySelector(&apos;img&apos;);let speed = 7;//2.设置定时器let timer = setInterval(()=&gt;&#123; //2.1 获取元素当前位置 let left = bird.offsetLeft; //2.3 边界处理 if(left &gt;= window.innerWidth - bird.offsetWidth)&#123; left = window.innerWidth - bird.offsetWidth -speed; clearInterval(timer); &#125; //2.2 将当前位置+速度变量值，更新赋值给当前元素的位置样式 bird.style.left = left + speed + &apos;px&apos;;&#125;,20); 案例：圆周运动//1.获取太阳、地球半径 var sun_r = 155; var earth_r = 15; //2.设置太阳居中,太阳左上角的定位 sun.style.left = (window.innerWidth-sun.offsetWidth)/2 +&apos;px&apos;; sun.style.top = (window.innerHeight-sun.offsetHeight)/2 +&apos;px&apos;; //3.设置地球初始角度 var deg = 0; getPos(deg); //4.设置定时器，实现角度改变 setInterval(function(){ deg +=5; getPos(deg); },30) //设置地球左上角的位置 function getPos(deg){ var rad = toRad(deg); var a = sun_r*Math.sin(rad); var b = sun_r*Math.cos(rad); var x = window.innerWidth/2+a-earth_r; var y = window.innerHeight/2-b-earth_r; earth.style.left = x +&apos;px&apos;; earth.style.top = y +&apos;px&apos;; } //角度转弧度 function toRad(deg){ return deg*Math.PI/180; } 加速运动速度不断增加的运动 案例：自由落体123456789101112131415161718//其实就是比匀速运动多了速度变量更新而已！！！//1.获取元素及初始化速度变量 let ball = document.querySelector(&quot;.ball&quot;);let speed = 1; //2.设置定时器let timer = setInterval(()=&gt;&#123; //2.1 获取元素当前位置 let top = ball.offsetTop; //2.2 更新速度变量 speed++; //2.4 边界处理 if(top &gt;= window.innerHeight-ball.offsetHeight)&#123; top = window.innerHeight - ball.offsetHeight-speed; clearInterval(timer); &#125; //2.3 将当前位置+速度变量值，更新赋值给当前元素的位置样式 ball.style.top = top + speed + &apos;px&apos;;&#125;, 20) 减速运动速度不断减小的运动 案例：刹车运动123456789101112131415161718//减速运动边界处理时，更多判断的是速度！！！//1.获取元素及初始化速度变量var car = document.querySelector(&apos;.car&apos;);var speed = 60;//2. 设置定时器var timer = setInterval(()=&gt;&#123; //2.1 获取元素当前位置 var left = car.offsetLeft; //2.2 更新速度变量 speed -= 3; //2.3 速度边界处理 if(speed&lt;=0)&#123; speed = 0; clearInterval(timer); &#125; //2.4 将位置更新赋值给当前元素的样式 car.style.left = left + speed + &apos;px&apos;;&#125;,50); 抛物线运动水平方向速度不断减小，垂直方向速度不断增加 案例: 抛球不反弹12345678910111213141516171819202122232425//垂直方向加速与水平方向减速的结合//1.获取元素及初始化速度变量var basketball = document.querySelector(&apos;.basketball&apos;);var xspeed = 20;var yspeed = 0;//2. 设置定时器var timer = setInterval(()=&gt;&#123; //2.1 获取元素当前位置 var left = basketball.offsetLeft; var top = basketball.offsetTop; //2.2 更新速度变量 yspeed++; xspeed -= 0.01; //2.3 边界判断 if(top &gt;= window.innerHeight - basketball.offsetHeight)&#123; top = window.innerHeight - basketball.offsetHeight - yspeed; clearInterval(timer); &#125; if(xspeed &lt;= 0)&#123; xspeed = 0; &#125; //2.4 将位置更新赋值给当前元素的样式 basketball.style.left = left + xspeed + &apos;px&apos;; basketball.style.top = top + yspeed + &apos;px&apos;;&#125;,30); 案例:抛物线的重力回弹缓冲运动一开始速度很快，然后慢下来，直到停止 缓冲运动的关键：动态计算速度（一般都跟目标值-当前值相关） 案例：点击返回顶部1234567891011121314151617181920//1.window.onscroll事件，实现当window.scrollY的值大于一定的值时，出现点击返回顶部按钮window.onscroll = ()=&gt;&#123;&#125;//2.给按钮绑定点击事件（事件触发定时器，一般都要先清除上一次的定时器）totop.onclick = ()=&gt;&#123; clearInterval(timer); //2.2 开启定时器 var timer = setInterval(()=&gt;&#123; //2.2.1 获取元素当前位置 var scrollTop = window.scrollY; //2.2.2 根据当前位置，更新速度变量值 var speed = parseInt(scrollTop/10); // 2.2.3 边界判断 if(speed&lt;=10)&#123; speed = 10; clearInterval(timer); &#125; //2.2.4 滚动到位置更新的位置 window.scrollBy(0,-speed); &#125;,30);&#125; 案例：图片展示上移效果for(let i=0;i&lt;cols.length;i++){ cols[i].onmouseenter = function(){ clearInterval(this.timer); // 1.获取当前a标签及设置目标值 let link = this.children[1]; let target = 0; //2.鼠标移入（不想冒泡就用enter）,设置定时器拿到当前top及设置缓冲速度。 this.timer = setInterval(()=&gt;{ let current = link.offsetTop; let speed = Math.ceil((current-target)/10); current -= speed; if(current &lt;= target){ clearInterval(this.timer); current = target; } link.style.top = current + &apos;px&apos;; },30); } } //鼠标移出，回复原来的位置。 透明度变换案例：图片的淡入淡出box.onmouseover = function(){ //4.多次进入事件，清楚上一次的定时器 clearInterval(timer); timer = setInterval(function(){ //1.鼠标移入，设置定时器，获取当前透明度*100. var cur = getComputedStyle(img).opacity*100; //2.具体的change看你想做什么运动。缓冲运动 var change = Math.ceil((100-cur)/10); cur += change; //3.当获取到的当前透明度+change值&gt;=100时，设置当前透明度的值。清除定时器 if(cur &gt;= 100){ cur = 100; clearInterval(timer); } //3.透明度改变的值除于100，给元素赋值样式 img.style.opacity = cur/100; },100) } //鼠标移出，回复半透明效果。 （三）动画的封装// 缓冲运动原理，利用(target-current)/10得到速度 function animate(ele,attr,target){ clearInterval(ele.timer); if(attr == &quot;opacity&quot;){target *= 100;} //1.定时器: //(1)获取ele的attr属性值，可能存在px、deg、target获取单位及数值 //(2)设置缓冲速度 //(3)设置当前属性值，判断达到目标值，清除定时器 //(4)设置给元素作为样式 //2.考虑透明度 //3.函数一进来，先清除定时器，避免事件触发重复添加 ele.timer = setInterval(function(){ var current = getComputedStyle(ele)[attr]; var unit = current.match(/[a-z]+$/i); unit = unit ? unit[0]: &quot;&quot;; current = parseFloat(current); if(attr == &quot;opacity&quot;){current *= 100;} var speed = (target-current)/10; speed = speed&gt;0? Math.ceil(speed) : Math.floor(speed); current += speed; if(current == target){ clearInterval(ele.timer); } if(attr == &quot;opacity&quot;){current /= 100;} ele.style[attr] = current + unit; },100) }]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(ES6方法)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F13.ES6%2F</url>
    <content type="text"><![CDATA[ES6变量声明let: 声明变量1）变量声明不会提前2）let不允许相同作用域内多次声明同一变量3）块级作用域 {} 演示：let声明变量的特点1234let num = 666;//报错，不允许在同一作用域声明已存在的变量，其次变量声明不会提前var num = 100;var num = 10;console.log(num); 案例：输出按钮索引值//ES5方法 //相当于var i； for(var i=0;i&lt;btns.length;i++){ btn[i].idx = i; btns[i].onclick = function(){ setTimeout(function(){ console.log(this.idx); }.bind(this),2000) } } //ES6方法： for(let i=0;i&lt;btns.length;i++){ //相当于let i； btns[i].onclick = function(){ setTimeout(function(){ console.log(i); },2000) } } //考察知识点： //1.变量的访问规则 //2.let的块级作用域{} const:声明常量1）变量声明不会提前2）块级作用域3）const不允许相同作用域内多次声明同一变量4）声明后无法修改值 演示：const MY_NAME = &apos;laoxie&apos;; // 报错：无法修改常量的值 MY_NAME = &apos;LEMONE&apos;; //演示：PI、Number()内置的一些常量属性 const常用于引用第三方库的声明 解构声明变量时，从数组和对象中提取值，对变量进行赋值，这被叫做“解构” 。 数组解构var [a,b] = [1,2]; console.log(a,b);//var a=1，b=2； var [a,...b] = [1,2,3,4]; //...表示获取剩余参数 console.log(a,b); //var a=1，b=[2,3,4]； //(1)解构失败，得到undefined var[a,b,c,d] = [10,20,30]； console.log(a,b,c,d);//d解构失败：数组arr中无对应索引值 var [a] = 1；//a解构失败，对应的右边不是数组，无法解构 //（2）指定默认值： var [a=true]= 1; //当a解构失败的话，拿到默认值 对象解构12345678910var obj = &#123;name:&quot;lemon&quot;,age:18&#125;;var &#123;name,age&#125; = obj; // var name=&quot;lemon&quot;,age=18；//(1)解构失败，得到undefinedvar &#123;username,age&#125; = obj;//username解构失败，变量必须与对象属性名相同，否则为undefined//(2)如果变量名与属性名不相同，则必须写成以下格式才能取到值var &#123;name:username,age&#125; = obj; //声明的变量为username，解构obj中的name属性 //相当于：var username=&quot;lemon&quot;,age=18;//(3)指定默认值：var &#123;a=10&#125; = &#123;&#125;;//当a解构失败的话，拿到默认值 应用 交换变量值var [x,y] = [y,x]; 123var x = 10;var y = 20;var[x,y] = [y,x]; //相当于var x = 20；var y = 10； 函数返回多个值 12345678910//数组：function example()&#123; return [1,2,3]&#125;var [x,y,z] = example();//对象：function example()&#123; return &#123;name:&quot;lemon&quot;,age:18&#125;;&#125;var &#123;name,age&#125; = example(); 定义函数形参（重点） 123456789101112131415161718192021222324//数组：function test([x,y,z])&#123; //相当于 var [x,y,z] = [1,2,3];&#125;test([1,2,3]);//对象：function test(&#123;name,age&#125;)&#123; //相当于 var &#123;name,age&#125; = &#123;name:&quot;lemon&quot;,age:18&#125;;&#125;test(&#123;name:&quot;lemon&quot;,age:18&#125;);//常规操作：参数可以设置默认值fuction test(&#123;x=0,y=0,z=0&#125;)&#123; //相当于var &#123;x=0,y=0,z=0&#125; = &#123;x:10&#125; //为避免没有实参值传入，给形参默认值&#125;test(&#123;x:10&#125;);//扩展：若形参是基本数据类型，函数也可以对形参进行设置默认值的操作。var func1 = function(x=1,y=2)&#123;return x+y&#125;；func1(); // 得到 3//同样，也可以用...表示获取剩余参数var func2 = (x, ...args) =&gt; &#123; console.log(args) &#125;;func2(1,2,3); // 输出 [2,3] 字符串扩展字符串方法includes​ 判断是否包含某个字符，返回布尔值 1&apos;html5&apos;.includes(&apos;html&apos;);//true startsWith/endsWith​ 是否以某一字符或某一字符串开头/结尾 123let str=&apos;google&apos;;str.startsWith(&apos;goo&apos;); //truestr.endsWith(&apos;e&apos;); //true repeat(n)​ 得到字符串重复n次后的结果，n可以为小数，但不能为负数 1&apos;laoxie&apos;.repeat(2);//laoxielaoxie 字符串模板template string (重点) 使用反引号表示，你可以通过一种更加美观、更加方便的方式向字符串中插入变量 格式：${变量|函数}， 1`你好，我的名字叫$&#123;username&#125;,接下来是我的自我介绍：$&#123;introduce()&#125;` 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 案例：根据数据生成一个商品列表箭头函数arrow function（重点）基本操作 格式：标识符=&gt;表达式 省略了function、return关键字、圆括号、花括号 //（一）函数内只有一句return代码，可省略{}及return。 // 1. 零个参数用 () 表示 var sum = function(){return 10 + 10;} // 箭头函数： var sum = () =&gt; 10+10; // 2. 函数只有一个参数（可省略括号） var test = function(x){return x+2;} // 箭头函数: var test = x=&gt;x+2; // 3. 函数有多个参数,用(参数)表示 var test = function(x,y){return x+y;} // 箭头函数: var test =(x,y)=&gt;x+y; //（二）函数中包含多行代码时用代码块括起来 //ES6中的规则是，紧随箭头的{}被解析为块的开始，而不是对象的开始 // ES5 btn.onclick = function (e) { e = e || window.event; var keCode = e.which || e.keyCode; console.log(keyCode); }; // ES6 btn.onclick = e=&gt;{ e = e || window.event; var keyCode = e.which || e.keyCode; console.log(keyCode); }; //（三）当使用箭头函数返回一个普通对象时，需要将对象包裹在小括号里 //传统写法 var createPerson = function(){ return {name:&apos;laoxie&apos;,age:18}; } // ES6 var createPerson = ()=&gt;{name:&apos;laoxie&apos;,age:18}; // 这样写会报Bug！ var createPerson = ()=&gt;({name:&apos;laoxie&apos;,age:18}); 箭头函数中的this值箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。 生成器函数 Generators function和函数名之间有一个*号 yield ：暂停代码执行 return：终止函数 next() ： 执行后得到一个对象，有两个属性如下： value：暂停时返回的值（yield） done：表示函数是否执行完毕 123456789101112function* sum(x)&#123; console.log(1); yield 50; console.log(2); yield 100; console.log(3); // return 150; console.log(&apos;end&apos;);&#125;var res = sum();//得到一个状态为suspended的对象&#123;next()&#125;// res.next();//得到一个对象：&#123;value:xx,done:false&#125;console.log(res); Set集合 Set集合，类似于数组，但是成员的值都是唯一的，可自动去重。 去重的前提是两个值恒等于。 set的方法 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示Set集合中是否存在该值。 clear()：清除所有成员，没有返回值。 12345678let imgs = new Set(); //创建一个set集合imgs.add(1); imgs.add(1);imgs.add(5);imgs.add(&quot;5&quot;); imgs.add(&#123;name:&quot;lemon&quot;&#125;); imgs.add(&#123;name:&quot;lemon&quot;&#125;);//打印的结果： 1 5 &apos;5&apos; &#123;name:&quot;lemon&quot;&#125; &#123;name:&quot;lemon&quot;&#125; 利用set去重数组1234var arr = [1, 2, 3, 4, 5, 5, 5, 5]；let items = new Set(arr);//去重后将set集合重新转成数组arr = Array.from(items)； 遍历set集合 forEach() for…of 12345678set.forEach((item,idx)=&gt;&#123; console.log(item,idx);&#125;)var imgs = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]); //根据KEY遍历 for(let item of imgs)&#123; console.log(item); &#125; for…of 这是最简洁、最直接的遍历数组元素的语法 这个方法避开了for-in循环的所有缺陷 for…of跟for-in的区别很明显，就是直接取值，而不再取下标了 与forEach()不同的是，它可以正确响应break、continue和return语句 1234var arr = [10,12,18,30];for (var value of arr) &#123; console.log(value);&#125; 只要有[迭代器Symbol(Symbol.iterator) ]就可以用for…of遍历 Array DOM Set/Map集合 String 不支持普通对象 对象扩展（重点）对象合并方法Object.assign(obj1,obj2,…objN); 合并对象到obj1，返回obj1 1234567var obj1 = &#123;a:1&#125;；var newObj1 = Object.assign(obj1,&#123;b:2&#125;);//1.合并对象到obj1,所以obj1 = &#123;a:1,b:2&#125;//2.返回obj1，传递给newObj1，所以newObj1 = &#123;a:1,b:2&#125;var newObj2 = Object.assign(obj1,&#123;b:2&#125;,&#123;b:4,c:3&#125;);//若存在相同属性，后面的覆盖前面的。//newObj=obj1=&#123;a:1,b:4,c:3&#125; 扩展：对象的传递与复制 123456789101112131415161718var obj = &#123; name:&quot;laoxie&quot;, hobby:[&apos;大保健&apos;,&apos;money&apos;]&#125;//1.对象的传递：var newObj = obj; //此时修改obj的任意属性，也会同时影响newObj//2.对象的复制//（1）for...in遍历复制for(var key in obj)&#123; newObj2[key] = obj[key];&#125;//（2）利用assign（）var newObj3 = Object.assign(&#123;&#125;,obj);//注意：以上两种复制方式，都只支持浅拷贝（对于引用类型，只拷贝引用）obj.hobby.push(&apos;羽毛球&apos;);//此时也会影响newObj2与newObj3//（3）深拷贝var newObj3 = JSON.parse(JSON.stringify(person))； 对象简写 ES6允许在对象之中直接写变量，如 12345678910111213//1. 属性简写var myName = &apos;laoxie&apos;;var obj = &#123;myName&#125;;//等效于var obj = &#123;myName:&apos;laoxie&apos;&#125;。变量名作为属性名，变量值作为属性值。//2.使用变量值作为属性名var obj = &#123; [myName]:18 //等效于 laoxie:18&#125;//3.方法简写var obj = &#123; coding()&#123;&#125; //等效于 coding:function()&#123;&#125;&#125; Map集合js对象（Object）只能用字符串当作键(属性名)。这让它的使用有了很大的限制。所以ES6推出了一种类似于对象的数据集合：Map集合，它能让所有类型的数据作为键 常用方法 设置set(key, value) 获取get(key) has(key) delete(key) clear() 123456789101112//创建：let map = new Map(); //设置：map.set(&apos;name&apos;,&apos;laoxie&apos;);map.set(6,666);// 把数组作为键var arr = [10,20,30];map.set(arr,&apos;数组&apos;);//获取：map.get(arr); //[10,20,30] 遍历方法 keys() 获取所有键，可以用Array.from()转成数组 values() 获取所有值，可以用Array.from()转成数组 entries() 获取所有键值对，可以用Array.from()转成数组 循环遍历，配合解构赋值 for…of 1234567for(var item of map)&#123; console.log(item); //每个item得到的都是一个数组，索引0为键，索引1为值&#125; //解构写法：for(var [key,value] of map)&#123; console.log(key,value);&#125; Symbol数据类型ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，一旦创建后就不可更改，是一种类似于字符串的数据类型，但Symbol 值不能与其他类型的值进行运算，否则报错。 symbol的创建123456789101112// 没有参数的情况var s1 = Symbol();var s2 = Symbol();s1 === s2 // false//Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了标识和区分，对调式非常有用// 有参数的情况var s1 = Symbol(&quot;foo&quot;);var s2 = Symbol(&quot;foo&quot;);s1 === s2 // false//Symbol值不能与其他类型的值进行运算 symbol的用途 给对象创建私有属性 给现有的对象添加属性，可能会产生命名冲突，Symbol的出现解决这个问题 12345678910111213var attr = Symbol();// 第一种写法,不用加引号var a = &#123;&#125;;a[attr] = &apos;Nani&apos;;// 第二种写法（注意加方括号，否则回被当作普通属性）var a = &#123; [attr]: &apos;Nani&apos;;&#125;;// 以上写法都得到同样结果a[attr] // &quot;Nani&quot; Symbol.for() 登记symbol,会先查找当前Symbol是否存在 1234// 存在：则引用，不存在：则创建登记var s11 = Symbol.for(&apos;laoxie&apos;);//创建一个Symbolvar s12 = Symbol.for(&apos;laoxie&apos;);//引用一个Symbol//注意：直接使用Symbol()创建的Symbol值的键不会被登记，所以也就获取不到]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(ES5方法)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F12.ES5%2F</url>
    <content type="text"><![CDATA[ES5支持ES5的浏览器 Opera 11.60+ Internet Explorer 9+ (IE9不支持严格模式) Firefox 4+ Safari 5.1+ Chrome 13+ 页面加载事件DOM文档加载的步骤为 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 DOM树构建完成。//DOMContentLoaded 加载图片等外部文件。 页面加载完毕。//window.onload 页面加载事件 12345678* readystatechange事件（准备阶段状态改变，两个状态） * interactive ：DOM树完成执行 * complete ：类似window.onload,但比window.onload先执行* DOMContentLoaded事件 * DOM树完成执行 * 必须使用事件监听器绑定document事件* PS:以上事件用以取代window.onload事件（实际开发不常用） 演示：通过控制台打印查看执行顺序document.onreadystatechange = function(){ if(document.readyState === &apos;interactive&apos;){ console.log(iteration); } if(document.readyState === &apos;complete&apos;){ console.log(&apos;complete&apos;); } } document.addEventListener(&quot;DOMContentLoaded&quot;,function(){ console.log(&quot;DOMContentLoaded&quot;); }) document.onload = function(){ console.log(&quot;onload); } ES5的严格模式 除了正常模式，ES5添加了第二种运行模式：“严格模式(strict mode)”。顾名思义，这种模式使得javascript在更严格的条件下运行(更可靠，更安全)。目前，除了IE6-9，其它浏览器均已支持ES5严格模式。 为什么要用严格模式 消除javascript语法的一些不合理，不严谨的地方，减少一些怪异行为； 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的javascript做好铺垫； 举例子：123456function sum()&#123; a = 10; //在普通模式下，若在函数内不使用var声明变量，会默认变成全局变量 //为了改变现状，出现ES4版本，然而变动太大，未被使用 //出现ES5作为过渡阶段，存在两种模式&#125; 如何使用ES5 在头部写入 “use strict” 全局：针对整个js文件将”use strict”放在js文件的第一行 局部：针对单个函数将”use strict”放在函数体的第一行 1234function strict()&#123; &quot;use strict&quot;; return &quot;这是严格模式&quot;;&#125; 执行限制 不使用var声明变量严格模式中将不通过 删除系统内置的属性会报错 不能删除var声明的全局变量（会自动成为window的属性） 对象有重名的属性将报错 var obj={name:”小王”,name:’王大锤’} 函数有重名的形参将报错 function sum(a,a,b){} arguments严格定义为参数 不允许对arguments赋值 禁止使用arguments.callee 函数必须声明在顶层，不能写在条件判断语句或for循环语句中 var arr = [10,2,3,50]; if(arr.length&gt;3){ function sum(){//报错} } 获取元素节点 querySelector(selector)获取匹配选择器的第一个元素节点，返回DOM节点 querySelectorAll(selector)获取匹配选择器的所有元素，返回数组 对比用getElementsByClassName()等方法获取到的类数组，querySelectorAll()可以使用forEach()方法。 （学会查看控制台！！！） Function方法bind() 用于将当前函数和指定对象绑定(改变this指向)，返回一个新的函数 应用 1234567891011var btns = document.querySelectorAll(&apos;.btn&apos;);for(var i=0;i&lt;btns.length;i++)&#123; btns[i].onclick = function()&#123; //方式1(1)：var self = this; setTimeout(function()&#123; //(2)console.log(self.innerHTML); //方式2.bind()改变this的指向 console.log(this.innerHTML); &#125;.bind(this),1000); &#125;;&#125; 获取class的属性classList 类数组，包含了所有类名 length : class类名的个数 add() : 添加class方法 remove() : 删除class方法 toggle() : 切换class方法 contains():是否含有某个类,返回布尔值 data自定义属性dataset 对象//1.符合W3C标准自定义属性：data-* &lt;div id=&quot;box&quot; data-name=&quot;laoxie&quot; data-age=&quot;18&quot; data-first-name=&quot;xiexie&quot;&gt;&lt;/div&gt; //2.dataset：存放所有data自定义属性的对象。 //(1)获取 dataset.age;//获取data-age的属性值 dataset.firstName;//获取data-first-name的属性值 //(2)设置 dataset.gender=&quot;girl&quot;；//设置data自定义属性，在html结构会多出[data-gender=&quot;girl&quot;] //回顾：操作任意自定义属性（可以是非标准的） //setAttibutte（） //getAttibute（）]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(正则基础)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F11.%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[正则表达式了解正则表达式 什么是正则表达式正则表达式(regular expression)是一个描述字符模式的对象。 为什么要使用正则表达式正则表达式能够进行强大的“模式匹配”和“文本检索与替换”功能。前端往往有大量的表单数据校验的工作，采用正则表达式会使得数据校验的工作量大大减轻 创建正则表达式使用RegExp构造函数， 第一个参数就是我们的模式“字符串” 1234var reg= new RegExp(&apos;study&apos;);//使用特殊字符var reg= new RegExp(&apos;\\d\\w+&apos;);\d\w+ 第二个参数可选，模式修饰符 i: case-insensitive，表示忽略大小写 g: global，表示全局匹配 m: multiline，表示多行匹配 1var reg = new RegExp(&apos;study&apos;, &apos;ig&apos;); 还可以用字面量方式直接声明1var reg = /study/gi; 直接量是字符匹配，不支持变量 使用正则表达式支持正则表达式的字符串方法 search返回第一次匹配时所在的索引值,如果匹配不到则返回-1 match 默认匹配字符串，返回一个数组 0:所匹配的字符 index:匹配第一个字符所在的索引 input:对字符串的引用 全局匹配(g)，返回一个匹配所有字符串数组 如果匹配不到则返回null replace替换字符串 split&#39;a,b ,c , d, e&#39;.split(/\s*,\s* /); 正则表达式的属性和方法 测试正则表达式用test方法,返回布尔值 格式：正则表达式.test(字符串) 用&lt;正则表达式&gt;测试&lt;字符串&gt;是否匹配,返回true/false 测试正则表达式exec方法 1/xx/.exec(字符串) 匹配规则 所有字母和数字都是按照字面量进行匹配,和字符串匹配等效/good/gi 字符类（只记小写字母即可） . : 除换行以外的字符 \w : 代表数字或字母或下划线 \W : 非数字字母和下划线字符 \d : 数字 \D : 非数字 \s : 代表一个空格 \S : 空格以外的字符 \b : 匹配一个单词边界，也就是指单词和空格间的位置 \B : 匹配非单词边界。 PS:以上所有字符类都只是匹配“一个”字符 特殊符号 ^ $ . * + ? = ! : | \ / () [] {} []: 代表任意“单个字符” ,里面的内容表示“或”的关系 -: 代表范围 ^: 代表非 (): 表示分组（n是以最左边括号出现的顺序排列） $1: 表示第一个分组 $n: 表示第n个分组（不能写在正则表达式里） \n: 在正则分组后面使用，表示对第n个分组的引用(一定要写在正则表达式里) PS: 编写的正则分组数量越少越好 |: 表示或者！！！！ 锚点定位 ^: 表示以什么开头 $: 表示以什么结尾 表示数量，对前一个字符计数， *: 代表0个或0个以上 &lt;===&gt;{0,} +: 代表1个或1个以上 &lt;===&gt;{1,} ?: 代表0个或1个 &lt;===&gt;{0,1} {}: 123\d&#123;5&#125;: 匹配5个数字\d&#123;5,10&#125;: 匹配5个到10个数字\d&#123;5,&#125;: 匹配5个或5个以上的数字 PS:1）数量词*,+,{5,}，会尽可能多的去匹配结果（贪婪）2）在后面加一个?表示尽可能少的去匹配结果（非贪婪）google,goooogle ==&gt; /go+/ [案例] 快速替换html标签 去除首尾空格 提取手机号码 表单验证 验证账号 不能为空， 不能使用特殊字符（数字、字母、下划线、横杠）， 必须以字母开头， 长度6-20 昵称只能输入中文 Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/ 电子邮件 1234jinrong.xie@qq.comx@qq.comx@163.comx@a-r.com.cn 密码 长度小于20 不能包含空格 身份证 18/15位 12445655 19900707 2165445655 19900707 211x 手机号码 生日 1231999/05/081999-5-819990508]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(cookie基础)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F10.cookie%2F</url>
    <content type="text"><![CDATA[网络知识（了解）通信协议通信规则，设备与设备之间通信时共同遵守的规则 TCP/UDP/IPIP： Internet Protocol（网络之间互连的协议），规定了计算机在因特网上进行通信时应当遵守的规则 IP地址：4个字节, 一共32位 ，用来标识设备在网络中的位置 TCP：Transmission Control Protocol（传输控制协议） TCP面向连接的协议（通信之前必须先建立连接） TCP相对可靠，它建立连接的过程称为3次握手 经历3次握手，才能建立连接 所有的消息传送，需要对方确认送达 //正常通信A：”土豆，土豆，我是茄子，收到请回答”B：”茄子，茄子，我是土豆，收到消息，有什么指示？”A：”没事，没事，我以为你挂了呢”A：”开始传送消息…” //如果对方没回应，则不断重复发送当前消息，直至对方收到回应为止。A：”茄子，茄子，我是土豆，我被人油炸了，现在改名叫薯片，收到请回答”…………A：”茄子，茄子，我是土豆，我被人油炸了，现在改名叫薯片，收到请回答，第2遍”…………A：”茄子，茄子，我是土豆，我被人油炸了，现在改名叫薯片，收到请回答，第3遍”…………B：”薯片，薯片，我收到消息”因此可以确保数据的准确送达 UDP:面向数据报的协议 (不可靠的协议)，如果TCP比作是打电话，那么UDP就是在发短信 无需建立连接，发送消息也无需对方确认 无法保证数据的发送顺序，以及准确率 UDP通常用于视频、语音等通信（丢掉了一帧画面是无所谓的） http/https超文本传输协议HyperText Transfer Protocol，基于TCP协议的一种高级协议, 用于客户端和服务器直接的通信. http的特点是，请求完成后就立即断开与服务器的连接 缺点:通信使用明文（不加密），内容可能会被窃听不适用特定的Web服务器，如：聊天室，消息广播 socket是一种通信模式，客户端与服务端一直保持着连接，用于随时传输数据 cookiecookie的概念cookie 是客户端与服务器端进行通讯使用的一个能够在浏览器本地化存储的技术 PS：chrome不支持本地文件的cookie读写 演示：利用sublimeserver开启服务器，演示cookie的设置与获取（了解协议域名端口）cookie的基本设置及获取1234设置:document.cookie = &apos;name=value&apos; * 一次只能写入一个cookie读取:document.cookie * 一次性读取所有cookie 案例：保存图片拖拽位置12345678910111213// 1.鼠标松开，保存图片位置。即设置cookie：保存left,topdocument.cookie = &apos;left=&apos; + girl.style.left;//100pxdocument.cookie = &apos;top=&apos; + girl.style.top;//100px// 2.页面加载，获取cookie：获取top,leftvar cookies = document.cookie;//得到所有cookiecookies = cookies.split(&apos;; &apos;);//3. 遍历数组，找出top,left,给图片设置位置cookies.forEach(function(cookie)&#123; var arr = cookie.split(&apos;=&apos;); if(arr[0] === &apos;left&apos; || arr[0] === &apos;top&apos;)&#123; girl.style[arr[0]] = arr[1]; &#125;&#125;); 案例:七天免登陆btnSubmit.onclick = function(){ // 5.表单submit按下即提交，不管满不满足条件。所以阻止默认行为 e.preventDefault(); // 1.获取用户名密码 var _username = username.value.trim(); var _password = password.value; //2.若用户名长度为0，退出函数。 if(_username.length===0){ alert(&apos;用户名不能为空&apos;); return; } //3.判断是否勾选&quot;7天内免登陆&quot;选项。若勾选保存cookie if(checkbox.checked){ var d = new Date(); d.setDate(d.getDate()+7);//d此时是一个UTC时间对象，转成字符串格式 document.cookie = &apos;username=&apos; + _username + &apos;;expires=&apos;+d.toUTCString(); } //4.不管有没有勾选，点击提交，显示跳转页面 location.href = &apos;http://www.baidu.com&apos;; } // 6.下一次访问：判断页面是否存在cookie，是否存在username的cookie，若存在自动登录，即自动跳转到百度 var cookies = document.cookie; //（1）判断页面是否存在cookie，即cookie长度不为0 if(cookies.length&gt;0){ cookies = cookies.split(&apos;; &apos;); cookies.forEach(function(item){ var arr = item.split(&apos;=&apos;); //（2）是否存在username的cookie if(arr[0] === &apos;username&apos;){ location.href = &apos;http://www.baidu.com&apos;; } }); } cookie的组成部分123456789101112格式：&apos;name=value[;expires=xx][;path=/][;domain=xxx]&apos;参数： expires：有效期 默认Session：临时cookie（关闭浏览器会被清除） 格式：&apos;expires=&apos; + d.toUTCString path：保存cookie的位置 默认当前html所在目录 格式：&apos;path=/&apos; domain：域名 默认：当前域名读取：document.cookie（读取当前能访问的所有cookie） 当前目录-&gt;根目录 封装cookie的操作var Cookie = { get:function(key){ // 1.先获取所有cookie，若cookie没有值，返回空字符串 var cookies = document.cookie; if(cookies.length === 0){ return &apos;&apos;; } // 2.拆分每一个cookie cookies = cookies.split(&apos;; &apos;); for(var i=0;i&lt;cookies.length;i++){ var arr = cookies[i].split(&apos;=&apos;); if(arr[0] === key){ return arr[1]; } } }, set:function(key,value,date,path){ //拼接字符串 var str = key + &apos;=&apos; + value; if(date){ str += &apos;;expires=&apos; + date.toUTCString(); } if(path){ str += &apos;;path=&apos;+path; } document.cookie = str; }, remove:function(key,path){ //获取过期的日期，重新设置cookie var d = new Date(); d.setDate(d.getDate()-1); this.set(key,&apos;x&apos;,d,path); }, // 清空cookie clear:function(){ } } cookie的限制 数量50个（不同浏览器值不同） 大小2m（不同浏览器值不同） 只能写入字符串 JSON1234567891011121314* 转换 * 对象/数组 -&gt; json字符串：JSON.stringify() * json字符串 -&gt; 对象/数组：JSON.parse()* 格式： * 属性名和字符串必须使用双引号 * 不能有注释 * 不能存在多余逗号* 属性值必须为以下类型 * String * Number * Boolean * Object * Array * Null 案例：将商品添加到购物车列表// 3.每次刷新，拿到上一次的存放值。第一次是为空数组 // * 若已经存在值，默认为JSON字符串，要转回数组 var goodslist = Cookie.get(&apos;goodslist&apos;) || []; if(typeof goodslist === &apos;string&apos;){ goodslist = JSON.parse(goodslist); } // 1.利用事件委托实现添加到购物车的效果 goods.onclick = function(e){ e = e || window.event; var target = e.target || e.srcElement; if(target.parentNode.className === &apos;add2cart&apos;){ // 2.若当前为按钮被点击 // （1）生成一个商品信息对象{guid，name，imgurl，price，qty（商品数量）} // （2）推入数组，将数组添加到cookie里面 // （3）考虑如果商品信息已经添加过，则应该增加数组里面的该商品数量 // * 第一步:判断当前的guid是否在数组存在。 // * 第二步:若存在，拿到该商品信息在数组中的索引，利用索引将qty++ var currentLi = target.parentNode.parentNode; var guid = currentLi.getAttribute(&apos;data-guid&apos;); var idx; var has = goodslist.some(function(g,i){ idx = i; return g.guid === guid; }); if(has){ goodslist[idx].qty++; }else{ var goods = { guid:guid, name:currentLi.children[1].innerText, imgurl:currentLi.children[0].src, price:currentLi.children[2].innerText, // 商品数量 qty:1 } goodslist.push(goods); } document.cookie = &apos;goodslist=&apos;+ JSON.stringify(goodslist); } 案例：显示购物车列表//1.获取goodslist的cookie，根据cookie数据生成html结构 //2.遍历时同时计算总价给subPrice元素赋值 var goodslist; render(); function render(){ goodslist = Cookie.getCookie(&apos;goodslist&apos;) || []; if(typeof goodslist === &apos;string&apos;){ goodslist = JSON.parse(goodslist); } //2.遍历时，同时计算商品金额 var total = 0; var ul = document.createElement(&apos;ul&apos;); ul.innerHTML = goodslist.map(function(goods){ total += goods.price * goods.qty; return &apos;&lt;li data-guid=&quot;&apos;+goods.guid+&apos;&quot;&gt;&apos; + &apos;&lt;img src=&quot;&apos;+goods.imgurl+&apos;&quot;&gt;&apos; + &apos;&lt;h4&gt;&apos;+goods.name+&apos;&lt;/h4&gt;&apos; + &apos;&lt;p class=&quot;price&quot;&gt;价格：&lt;span&gt;&apos;+goods.price+&apos;&amp;times;&apos;+goods.qty+&apos;&lt;/span&gt;&lt;/p&gt;&apos; + &apos;&lt;span class=&quot;btn-close&quot;&gt;&amp;times;&lt;/span&gt;&apos; + &apos;&lt;/li&gt;&apos;； }).join(&apos;&apos;); carList.innerHTML = &apos;&apos;; carList.appendChild(ul); subPrice.innerHTML = total.toFixed(2); } // 3.点击按钮，移除cookie数据，重新渲染商品列表。同时阻止浏览器默认行为 btnClear.onclick = function(){ Cookie.remove(&apos;goodslist&apos;); render(); return false; } //4.当点击某个商品的删除时 //（1）获取到当前商品的guid，遍历数组goodslist，根据guid值相同，找到被删除的元素在数组中的索引。 //（2）通过索引，删除goodslist的中的某个商品。之后推出循环 //（3）重新生成cookie后，渲染 carList.onclick = function(e){ e = e || window.event; var target = e.target || e.srcElement; if(target.className === &apos;btn-close&apos;){ var currentLi = target.parentNode; var guid = currentLi.getAttribute(&apos;data-guid&apos;); for(var i=0;i&lt;goodslist.length;i++){ if(goodslist[i].guid === guid){ goodslist.splice(i,1); break; } } Cookie.set(&apos;goodslist&apos;,JSON.stringify(goodslist)); render(); } }]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(Event事件)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F09.Event%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Event事件事件是可以被JavaScript侦测到的行为。网页中的每个元素都可以产生某些可以触发JavaScript函数的事件. 事件是一瞬间触发。 事件绑定方式DOM节点绑定（格式）：节点.on+事件名 = 事件处理函数; 123456789//（1）DOM节点绑定// *同名事件会被覆盖// *事件处理函数只能冒泡阶段执行div.onclick = function()&#123;&#125;//（2）作为html属性//&lt;div onclick=&quot;sum()&quot;&gt;&lt;/div&gt; 不常用，不实用。//（3）事件监听器// *同名事件不会被覆盖// *事件处理函数默认冒泡阶段执行 常用事件鼠标事件onclick 当用户点击某个对象时调用的事件。ondblclick 当用户双击某个对象时调用的事件。onmousedown 鼠标按钮被按下。onmouseup 鼠标按键被松开。onmouseover 鼠标移到某元素之上。onmouseout 鼠标从某元素移开。onmousemove 鼠标被移动时触发。onmouseenter 在鼠标光标从元素外部移动到元素范围之内时触发。这个事件不冒泡onmouseleave 在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡oncontextmenu 鼠标右键菜单展开时触发。PS：click = mousedown + mouseup, dblclick = click*2(短时间内两次单击);执行顺序：mouseover=&gt;mouseenter; mouseout =&gt; mouseleave 键盘事件onkeydown 某个键盘按键被按下。onkeyup 某个键盘按键被松开。onkeypress 键盘&lt;字符键&gt;被按下触发,而且如果按住不放的话，会重复触发此事件。 UI事件onload 页面元素（包括图片多媒体等）加载完成后onscroll 滚动时触发。onresize 窗口或框架被重新调整大小。 表单事件onselect 输入框文本被选中。onblur 元素失去焦点时触发。onfocus 元素获得焦点时触发。onchange 元素内容被改变，且失去焦点时触发。onreset 重置按钮被点击。onsubmit 确认按钮被点击。oninput 输入字符时触发 演示：常用事件123456789鼠标事件* onclick* onmousedown * onmouseup* onmouover* onmouseout* onmousemove结论：click = mousedown + mouseupdblclick = click*2 Event对象什么是event对象事件执行过程中的状态，用来保存当前事件的信息对象 如何获取event对象123ele.事件 = function(e)&#123; e = e || window.event;//获取event对象的兼容写法。IE8-：window.event&#125; 鼠标event对象的属性1.鼠标按键 button 返回当事件被触发时，哪个鼠标按钮被点击。 W3C标准0: 代表鼠标按下了左键1: 代表按下了滚轮2: 代表按下了右键 IE8-（IE8以下的浏览器）1鼠标左键， 2鼠标右键， 3左右同时按， 4滚轮， 5左键加滚轮， 6右键加滚轮， 7三个同时 演示：检测鼠标按键12345678910111213box.onmousedown = function(event)&#123; switch(event.button)&#123; case 0: box.innerText = &apos;射击&apos;; break; case 1: box.innerText = &apos;换枪&apos;; break; case 2: box.innerText = &apos;开镜&apos;; break; &#125;&#125; 2.光标位置信息1234567clientX /clientY 光标相对于浏览器可视区域的位置，也就是浏览器坐标。screenX/screenY 光标指针相对于电脑屏幕的水平/垂直坐标。pageX/pageY:鼠标相对于文档的位置。 * 包括滚动条滚动的距离，即：e.clientX+window.scrollX * IE8-不支持offsetX,offsetY: 光标相对于事件源对象的相对偏移量。 * 事件源对象：触发事件的对象 演示:检测光标位置案例：新闻提示信息//1.给所有新闻绑定鼠标移入移出移动事件 for(var i=0;i&lt;links.length;i++){ links[i].onmouseover = function(){ //2.移入事件： //2.1将title属性值作为details元素的内容 //2.2显示details元素 //2.3为了不让title默认行为影响，去除title属性 this.bak = this.title; // 2.3.1移除前备份title内容,下一次移入才不会没有没有内容 this.removeAttribute(&apos;title&apos;); // 2.3.2去除title属性 } links[i].onmouseout = function(){ //3.移出事件：隐藏details。重置title属性值 } links[i].onmousemove = function(e){ //4.移动事件，设置定位 } } 键盘event对象的属性 which/keyCode 对于keypress事件，该属性声明了被敲击的键生成的 Unicode 字符码(ascii码) 对于keydown和keyup事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。 altKey 当事件被触发时，ALT 键是否被按下。返回值为布尔值。 ctrlKey 当事件被触发时，CTRL 键是否被按下。 shiftKey 当事件被触发时，Shift 键是否被按下。 案例：愤怒的小鸟//键盘按下，根据上下左右移动小鸟 document.onkeydown = function(e){ // 1.获取小鸟当前位置 var top = bird.offsetTop; var left = bird.offsetLeft; //2.初始化速度及类名变量 var speed = 10; var className = &apos;&apos;; // 3.判断按下上下左右方向键,设置left值及类名变量值 switch(e.keyCode){ case 37: left -= speed; className = &apos;&apos;; break; //同理其他方向 } // 4.通过变量值，设置bird的位置，及类名 bird.style.left = left + &apos;px&apos;; bird.style.top = top + &apos;px&apos;; bird.className = className; } 事件冒泡什么是事件冒泡： 在一个对象上触发某类事件（如onclick事件），那么click事件就会沿着DOM树向这个对象的父级传播，从里到外，直至它被处理程序处理，或者事件到达了最顶层（document/window） 演示：从里到外的元素添加相同的事件，查看事件冒泡12345首先纠正你一个重要的概念：事件是被动触发的，并不是你能主动“加”上去的。换句话说，元素只要符合某种事件的触发条件（比如鼠标点击），事件就必定会触发，而你所谓的“加”上去的是js对事件的处理过程（没有加的话就不会对事件做任何处理，但并不等于说事件就没有触发）。对事件冒泡的正确理解是这样的：当div1内包含div2时，用户把鼠标移到div2上，会触发div2的onmouseover，然后，div2又会把这个事件冒泡（也可以理解为上报）给自己的父元素div1，这样div1的onmouseover事件也会被触发（如果div1上面还有上级元素也会被触发，直到顶级元素html）。这时候就要看所有被触发onmouseover事件的元素有没有添加对事件的处理程序，有就会按由内到外的顺序逐级处理，没有就会像什么也没发生一样。所以，我最后再强调一遍，能不能理解就看你造化了：div1.onmouseover=function()&#123;...&#125;并不是说你加了这段代码div1就会触发onmouseover事件，而是说当div1触发onmouseover事件时就会执行function内的代码！ 1）不是所有的事件都能冒泡。 以下事件不冒泡：blur、focus、load、unload…。 【onmouseover与onmouseenter的区别】 2）冒泡到最顶层的目标不同。大部分浏览器到window对象，IE8-到document对象 停止事件的传播12345678标准：event.stopPropagation(); IE8-：event.cancelBubble = true; // 阻止事件冒泡兼容写法：if(e.stopPropagation)&#123; e.stopPropagation();&#125;else&#123;e.cancelBubble = true;&#125; 事件委托利用事件冒泡原理，把本来绑定给某个元素的事件委托给它的父级（已经存在页面元素）处理。 事件源对象：触发事件的元素标准：event.targetIE8-：event.srcElement 案例：表格删除当前行1234567891011121314151617//影响页面性能的三大操作： //* 事件数量 //* dom节点操作次数 //* 请求次数output.onclick = function(e)&#123; //兼容性问题 e = e || window.event; var target = e.target || e.srcElement; if(target.className === &apos;btnDel&apos;)&#123; //this指的是谁? var currentTr = target.parentNode.parentNode; currentTr.parentNode.removeChild(currentTr); &#125;else if(target.className === &apos;btnCopy&apos;)&#123; var currentTr = target.parentNode.parentNode; currentTr.parentNode.appendChild(currentTr.cloneNode(true)); &#125;&#125; 阻止浏览器默认行为 链接跳转 表单提交 右键菜单… 文本的选择 标准：event.preventDefault(); IE8-：event.returnValue = false; 案例：自定义右键菜单document.oncontextmenu = function(e){ e = e || window.event; //获取鼠标在文档中的位置 e.pageX = e.pageX || e.clientX + window.scrollX; e.pageY = e.pageY || e.clientY + window.scrollY; //给菜单框添加位置样式 contextMenu.style.left = e.pageX + &apos;px&apos;; contextMenu.style.top = e.pageY + &apos;px&apos;; contextMenu.style.display = &apos;block&apos;; //阻止浏览器的默认行为 e.preventDefault ? e.preventDefault() : returnValue = false; } // 点击空白地方关闭右键菜单 document.onclick = function(){ contextMenu.style.display = &apos;none&apos;; } contextMenu.onclick = function(e){ e = e || window.event; //禁止事件冒泡 e.stopPropagation ? e.stopPropagation() : e.cancelBubble=true; } 事件捕获(反冒泡)1234事件的传播：（1）事件冒泡：从下往上 （2）事件捕获：从上往下 *监听器 演示：事件捕获的效果事件监听器1234//标准浏览器：元素.addEventListener(事件名,事件处理函数,是否捕获（默认false，为冒泡）)target.addEventListener(&quot;click&quot;, fn, false);//IE8-：元素.attachEvent(on+事件名,事件处理函数)target.attachEvent(&quot;onclick&quot;,fun); 可以绑定多个处理函数在一个对象上, 执行顺序按照绑定的顺序来(标准) 不同元素事件执行顺序跟html结构有关 相同元素事件执行顺序跟绑定先后有关 可以绑定多个函数在一个对象上, 执行顺序按照绑定的反序（ie8-） 12345678btn4.addEventListener(``&quot;click&quot;``,hello1);btn4.addEventListener(``&quot;click&quot;``,hello2);function` `hello1()&#123; ``alert(``&quot;hello 1&quot;``);&#125;function` `hello2()&#123; ``alert(``&quot;hello 2&quot;``);&#125; 演示:绑定事件的两种方式的区别 封装：绑定事件，兼容浏览器12345678910111213function bind(ele,type,handler,isCapture)&#123; // 优先使用事件监听器 if(ele.addEventListerner)&#123; // 标准浏览器 ele.addEventListerner(type,handler,isCapture); &#125;else if(ele.attachEvent)&#123; // IE8- ele.attachEvent(&apos;on&apos; + type,handler); &#125;else&#123; // DOM节点绑定方式 ele[&apos;on&apos; + type] = handler &#125;&#125; 事件的移除DOM绑定事件的移除ele.on+事件 = null； 事件监听器移除 标准：removeEventListener(type,fn, true)传入的参数fn要跟添加时一样(同一个函数)，否则不能移除事件 IE8-：detachEvent(‘on’+type,fun)，传入的参数fun要跟添加时一样，否则不能移除事件 注意：页面事件绑定数量越多，越影响性能（速度越慢） 拖拽效果拖拽的原理鼠标按下且移动鼠标时，改变当前元素的top,left值 拖拽思路及案例演示//给目标元素添加onmousedown事件 //- 拖拽的前提是目标元素设置css定位 //- 记录按下鼠标位置与元素左上角的偏移量offsetX，offsetY box.onmousedown = function(e){ var ox = e.offsetX; var oy = e.offsetY; //当onmousedown发生以后，此刻给document添加onmousemove事件 // - 意味着此刻鼠标在网页的移动都将改变目标元素的位置 // - 目标元素的left = 鼠标的pageX – ox // - 目标元素的top = 鼠标的pageY– oy document.onmousemove = function(e){ box.style.left = e.pageX - ox + &apos;px&apos;; box.style.top = e.pageY - oy + &apos;px&apos;; } } //给目标元素或者document（效果有差异）添加onmouseup事件，清空document的onmousemove事件 document.onmouseup = function(){ document.onmousemove = null; } 案例：给图片实现拖拽案例：实现复杂的拖拽效果1.按拖拽原套路实现拖拽效果，唯一不同的在于初始鼠标位置与大盒子左上角初始偏移量获取 2.用数组记录mousedown、mouseover时的大盒子的定位坐标 3.mousedown，状态值改成true；mouseup，状态值改成false 4.mousemove过程，改变坐标元素的值：dragTop.innerText h2.onmousedown = function(e){ dragStatus.innerText = &apos;true&apos;; pos.push({x:box.offsetLeft,y:box.offsetTop}) //注意点1： var ox = e.clientX - box.offsetLeft; var oy = e.clientY - box.offsetTop; document.onmousemove = function(evt){ var left = evt.clientX - ox; var top = evt.clientY - oy; box.style.left = left + &apos;px&apos;; box.style.top = top + &apos;px&apos;; // 注意点2：取消文字选择 evt.preventDefault(); pos.push({x:left,y:top}); dragTop.innerText = top; dragLeft.innerText = left; } } document.onmouseup = function(){ document.onmousemove = null; dragStatus.innerText = &apos;false&apos;; } //5.点击轨迹回放，定时器拿到数组的每个索引的值，赋值给box的样式。 //索引到达最后一个值的时候，清空定时器及数组 box.onclick = function(e){ e = e || window.event; var target = e.target || e.srcElement; if(target.tagName.toLowerCase() === &apos;a&apos;){ var i=pos.length; var timer = setInterval(function(){ i--; box.style.left = pos[i].x + &apos;px&apos;; box.style.top = pos[i].y + &apos;px&apos;; dragTop.innerText = pos[i].y; dragLeft.innerText = pos[i].x; if(i&lt;=0){ clearInterval(timer); pos = []; } },50); }]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(DOM)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F08.DOM%2F</url>
    <content type="text"><![CDATA[DOM什么是DOMDOM是Document Object Model（文档对象模型）的缩写，它是W3C国际组织的一套Web标准。是针对HTML和XML文档的一个API，它定义了访问HTML文档对象的一套属性、方法和事件 节点类型 每个节点都有一个nodeType属性，用于表明节点的类型。 常用节点类型与对应nodeType值： 用于判断获取到的元素属于什么类型节点 元素节点 &lt;==&gt; 1 文本节点 &lt;==&gt; 3 属性节点 &lt;==&gt; 2 12//找出所有节点&lt;div class=&quot;content&quot; title=&quot;属性节点&quot;&gt;测试Div&lt;/div&gt; 节点获取获取元素节点方法 document.getElementById(id) 通过 ID获取元素的节点（速度最快） 必须通过document调用 返回DOM节点对象，如果id不存在返回null getElementsByTagName(tagname) 通过标签名获取元素节点列表 返回类数组，如果tagname不存在返回空数组[] getElementsByClassName() 通过class类名获取节点列表 返回类数组，如果类名不存在返回空数组[] document.getElementsByName() 通过name属性获取元素节点列表 必须通过document调用 返回类数组，如果name属性不存在返回空数组[] 注意: 如果确认元素存在, 但是返回null或[]，一定是代码执行顺序的问题 节点操作节点属性 nodeName 返回节点的名称，根据其类型。 nodeType 返回节点的类型。 nodeValue 返回节点的值（元素节点的nodeValue为null） 节点方法 创建： document.createElement(“元素名”) 创建一个元素节点 document.createTextNode() 创建一个文本节点 document.createAttribute() 创建一个属性节点（了解） 插入： parent.appendChild() 向节点的子节点列表的结尾添加新的子节点 parent.insertBefore(new,node) 在指定的子节点node前插入新的子节点new。 ele.setAttributeNode(attrNode) 在指定元素中插入一个属性节点（了解） 对页面已存在节点的处理 复制 cloneNode(boolean) 复制节点，为true是深复制。 删除： parent.removeChild(ele) 删除（并返回）当前节点parent的指定子节点ele。 判断： parent.hasChildNodes() 判断当前节点是否拥有子节点,返回布尔值 以上parent表示父级元素，ele表示元素 利用节点关系获取其他节点 获取父级节点 ele.parentNode 得到ele元素的父节点 获取子节点 ele.childNodes 得到ele元素的全部子节点列表（类数组） ele.firstChild 获得ele元素的第一个子节点 ele.lastChild 获得ele元素的最后一个子节点 获取兄弟节点 ele.nextSibling 获得ele元素的下一个兄弟节点 ele.previousSibling 得到ele元素的上一个兄弟节点 元素节点的操作常用属性(操作的是DOM节点属性) 可以通过点语法或方括号访问 .tagName 获取元素元素的标签名 .id 设置/获取元素id属性 .name 设置/获取元素name属性 .style 设置/获取元素的内联样式 .className 设置/获取元素的class属性 .innerHTML 设置/获取元素的内容（不包含html标签代码） .outerHTML 设置或获取元素及其内容（包含html代码） .innerText 设置或获取位于元素标签内的文本 .outerText 设置(包括标签)或获取(不包括标签)元素的文本 盒模型相关(操作的是html元素属性) offsetTop: 当前元素离&lt;最近的定位父级&gt;元素顶部的距离。 offsetLeft: 当前元素离&lt;最近的定位父级&gt;元素左边的距离。 以上两个属性如果没定位的父级，则相对于根元素html的距离 offsetWidth: 当前元素的宽度（border + padding + content） offsetHeight: 当前元素的高度（border + padding + content） 元素方法(适用所有的属性)(操作HTML结构属性) ele.getAttribute(attr) //获取元素的属性值（自定义属性获取） ele.setAttribute(attr,val); //设置元素的属性 ele.removeAttribute(attr) //删除属性attr ele.hasAttribute(attr) //判断是否存在属性attr 根据元素关系获取其他元素 parentElement 获取父级节点元素 children 获取元素的全部子元素 firstElementChild 获取第一个子元素 lastElementChild 获取最后一个子元素 previousElementSibling 获取前一个元素 nextElementSibling 获取下一个元素 获取css样式（非内联样式） 得到当前元素计算后的所有样式 getComputedStyle(ele,pseudo) （标准） ele:要获取样式的元素 pseudo:伪元素样式字符(可选)，可获取伪元素样式 ele.currentStyle （IE8-） //IE不能获取总属性 table对象(了解)table对象属性&amp;方法 rows 返回包含表格中所有行的一个数组 tBodies 返回包含表格中所有 tbody 的一个数组 insertRow(index) 在表格中插入一个新行。 deleteRow(index) 从表格删除一行。 tr对象属性&amp;方法 cells 返回包含表格中所有单元格的一个数组 rowIndex 返回该行在表中的位置 sectionRowIndex 返回在 tBody 、tHead 或 tFoot 中行的位置。 insertCell(index) 在一行中的指定位置插入一个空的列 deleteCell(index) 删除行中的指定的单元格 td/th对象属性&amp;方法 cellIndex 返回单元格在表格行的单元格集合中的位置。]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(BOM)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F07.BOM%2F</url>
    <content type="text"><![CDATA[BOMBOM的概念BOM 是Browser Object Model（浏览器对象模型）的缩写，提供与浏览器窗口进行交互的对象。JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C, 而BOM缺乏标准。这也是各种浏览器不兼容的根源所在 window对象window对象是BOM的核心, 是最顶层的对象，所有对象都是通过它延伸出来的，如图: 全局作用域 定义在全局环境下的变量都会成为window对象的属性 把变量定义在函数体里，可以有效减少全局环境下的变量冲突，避免污染全局环境 在函数内部不用var声明的变量会成为全局变量，即window对象的属性 window对象可以在代码中省略，如window.alert()可以写成alert(); 通过var在全局作用域下声明的变量用delete无法删除 1234var obj = &#123;name:&apos;xxx&apos;&#125;//删除对象的属性用delete：delete obj.name; window对象下的属性常用属性 浏览器窗口尺寸innerWidth/innerHeight, //表示浏览器窗口”可视区域”尺寸outerWidth/outerHeight //表示整个浏览器窗口的尺寸 滚动相关 scrollX/scrollY //获取浏览器窗口滚动条滚动过的距离 scrollTo(x,y) //设置浏览器滚动距离 scrollBy(xnum,ynum) //设置基于当前位置滚动的距离，可以为负数 常用方法(了解) 系统对话框 alert(msg)//弹出对话框 confirm(msg)//弹出警告框，返回布尔值 prompt(msg,default)//弹出输入框，返回消息或null 以上三个方法都会暂停代码的执行 1open(url,name,[options]) : 打开一个新窗口并返回新 window 对象 - name:不命名会每次打开新窗口，命名的第一次打开新窗口,之后在这个窗口中加载 - options为字符串：`&apos;width=400,height=400,top=200,left=200&apos;` - opener父窗口对象，通过open方法打开的窗口才有opener对象 close(): 关闭窗口 print(): 调出打印对话框 属性对象 document(核心): 文档对象，让我们可以在js脚本中直接访问页面元素(DOM) 在DOM章节详细讲解 history(重要): 历史对象,包含窗口的浏览历史，可以实现后退 属性： length 返回浏览器历史列表中的 URL 数量。 方法： back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go() 加载 history 列表中的某个具体页面，支持负数。 12history.go(2);//向前两个页面history.go(-2);//后退两个页面 location(重要):location是BOM最有用的对象之一，保存着当前窗口中加载文档的相关信息，还提供一些导航功能，它是个很特别的对象，既是window的属性，也是document的属性 属性： hash 设置或返回从井号 (#) 开始的 URL（锚）==&gt;哈希值。 href 设置或返回完整的 URL。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 12encodeURI();//转码decodeURI();//解码 PS：修改以上属性(hash除外)都会刷新当前页面，并生成历史纪录 方法： reload() 重新加载当前文档，带参数true表示不使用缓存刷新页面。 navigator（了解）:导航对象, 包含所有有关访问者浏览器的信息，通常用于检测浏览器类型 appName 浏览器名称 appVersion 浏览器版本 platform 操作系统 userAgent 用户代理信息，通过该属性可以获取浏览器及操作系统信息 geolocation 获取地理位置信息 window对象常用事件 onload //页面资源全部加载完成后触发这个事件 onscroll//窗口滚动条滚动时触发 onresize //窗口大小改变时触发]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(Math、date日期对象)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F06.Math%26Date%E6%97%A5%E6%9C%9FDate%2F</url>
    <content type="text"><![CDATA[Math对象方法一个保存数学公式和信息的对象，一般用于执行数学任务 属性 Math.PI //3.1415926 方法 round(3.6) //四舍五入取整 ceil(11.3) //12 向上取整 floor(11.8) //11 向下取整 random() //返回0-1之间的随机数（不包括1） max(num1, num2) //返回较大的数 min(num1, num2) //返回较小的数 abs(num) //绝对值 pow(x,y) //x的y次方 sqrt(num) //开平方根 相关数学知识 三角函数复习 sin(radian) cos(radian) tan(radian) 角度与弧度的转换 弧度=角度*Math.PI/180 勾股定理复习 在直角三角形中，斜边的平方等于直角边的平方和 曲线方程复习(一元二次方程) 日期Date了解时间 GMT：格林尼治标准时(Greenwich Mean Time)，俗称“天文学时间” UTC：协调世界时(Universal Time Coordinated)，“原子物理时间”，它更加精确,50亿年才误差1秒 时区：为了克服时间上的混乱，1884年在华盛顿召开的一次国际经度会议（又称国际子午线会议[1]）上，规定将全球划分为24个时区（东、西各12个时区）。规定英国（格林尼治天文台旧址）为中时区（零时区）、东1-12区，西1-12区。每个时区横跨经度15度，时间正好是1小时 闰年：四年一闰，百年不闰，四百年再闰 纪元时间(UNIX TIME)：1970-1-1零时 创建日期时间对象1234567891011构造函数 * 不带参数：得到的是代码执行时的时间（本地时间） * 带参数 * 字符串：指定日期 * 数字：指定毫秒数//1）创建当前时间的日期和时间var d = new Date();//2）创建指定日期的时间和日期var d = new Date(&quot;2015/08/22&quot;);var d = new Date(56521211021);//参数为距1970-1-1零时的毫秒数 日期时间对象的方法获取年月日getFullYear()/setFullYear(2014) set设置getMonth()/setMonth(8)注意：获取月份是从0开始的 set设置getDate()/setDate(25) set设置 获取星期getDay() 0-6:星期天-星期六 获取时分秒getHours()/setHours()getMinutes()/setMinutes()getSeconds()/setSeconds() 案例：将当前日期格式化输出为 “2018年08月24 星期五”格式var d = new Date(); // 1.获取年份、月份、日、星期 var year = d.getFullYear(); var month = d.getMonth()+1; var date = d.getDate(); var day = d.getDay();//0-6代表星期日到星期六 var week = &apos;天，一，二，三，四，五，六&apos;.split(&apos;，&apos;); output.innerHTML = &apos;当前时间为：&apos; + year + &apos;年&apos; + month + &apos;月&apos; + date + &apos;日 星期&apos; + week[day]; //2.使用定时器，每秒执行一次上面的代码（封装成函数）。setInterval(fn,1000); //3.一开始渲染页面时，要先执行一次函数。（因为定时器设置1秒的间隔） //4.优化：当时分秒小于10的时候，补0操作 案例：时间设置： 日期date的n天后的日期function afterDate(date,n){ // 指定日期创建对象 var d = new Date(date); d.setDate(d.getDate() + n); return d; } 日期处理 getTime()/setTime()：获取/修改某个日期自1970年1月1日0时以来的毫秒数 toLocaleDateString(); 以特定地区格式显示年、月、日 toUTCString(); 转换成UTC时间 案例：判断两个日期相差的天数1231.把开始时间和结束时间转成毫秒数2.两个毫秒数相减，得到时间差3.把时间差转成天数 ES5方法Date.parse(“2015-08-24”)//返回指定日期距1970-1-1零时的毫秒数 PS：转换格式默认支持2015-08-24或2015/08/24 Date.now();//返回执行这行代码时距1970-1-1零时的毫秒数 延迟与定时器 setTimeout(fn,200)：两百毫秒后执行fn这个函数（只执行一次）,返回一个id标识 clearTimeout(timeoutID)：清除指定id标识的延迟操作 setInterval(fn,30)：每隔30毫秒执行一次fn这个函数,返回一个id标识 clearInterval(intervalID)：清除指定id标识的定时器操作 123456var timer = setTimeout(function()&#123; //2s后执行这里的代码&#125;,2000);//清除clearTimeout(timer); 案例：实现进度条// 1.进度条变量初始宽度 var width = 0; // 2.进度条变量宽度每隔一段时间，递增一定的值 var timer = setInterval(function(){ width += 13; // 3.当进度条变量宽度大于浏览器可视区域宽度，停止定时器，赋值为浏览器可视区域的宽度 if(width &gt;= window.innerWidth){//333,366 width = window.innerWidth; clearInterval(timer) } // 4.将进度条变量的值，赋值给进度条样式 bar.style.width = width + &apos;px&apos;; },30); 案例：实现倒计时1234567891011121314151617181）指定结束时间var end = &apos;2018-3-1 14:50:40&apos;; 2）定时器，每秒拿当前时间跟结束时间对比，计算差值 var offset = Date.parse(end) - Date.now();3）把差值转换成《剩余时间》 offset = Math.floor(offset/1000); var sec = offset%60;//50,5 var min = Math.floor(offset/60)%60; var hour = Math.floor(offset/60/60)%24; var day = Math.floor(offset/60/60/24); // 补0操作4）拼接时间格式，写入页面5）倒计时结束时（应写在步骤3前面，不再呈现在页面上） if(offset &lt;= 0)&#123; // 停止定时器 // 替换购买按钮 // *隐藏倒计时 &#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(字符串)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F05.string%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串字符串就是一串字符，由双（单）引号括起来。 创建字符串123456//方式一：字面量（推荐）var str = &apos;城市套路深，我想回农村&apos;;//方式二：构造函数//PS：用new产生的变量都是引用类型的变量，也叫对象var str = new String(&apos;我不是黄蓉，我不会武功&apos;); 字符串的属性和方法属性 length: 表示字符串的长度，只读（只能读取） 获取值方法 charAt(3) //获取下标为3的字符 备注：es5可以通过索引获取字符，例如 str[3] 查找索引方法 indexOf/lastIndexOf(keyword [,startIndex]) 从开头/尾部向后查找字符串keyword第一次出现的位置,如果没找到返回-1 案例：输出所有1-100之间7的倍数和包含7的数字12345for(var num=1;num&lt;=100;num++)&#123; if(num%7===0 || String(num).indexOf(7)&gt;=0)&#123; document.write(num + &apos;, &apos;) &#125;&#125; 案例：16进制随机背景色var str = &apos;0123456789abcdef&apos;;//15 var res = &apos;#&apos;; var randomIdx； for(var i=0;i&lt;6;i++){ randomIdx = parseInt(Math.random()*str.length）； res += str[randomIdx]; } //封装成函数 字符串分割成数组方法 split(分割符)：根据分割字符，把字符串拆分成数组 字符串替换方法 replace(str|regExp,’‘) 替换字符串 字符串的替换只能执行一次，不能够进行全局匹配，如果需要全局匹配，则应使用正则表达式 案例：过滤不文明用语//1.获取元素 //2.点击按钮，获取输入信息，将输入信息添加到数组，渲染到页面上。 //3.定义敏感字符，用数组存放（可以先写成字符串，转成数组） //4.将输入信息添加到数组前，先替换不文明用语 arr_mingan.forEach(function(item){ //初级写法： _msg = _msg.replace(item,&apos;**&apos;); // * 不能过滤大小写 // * 不能过滤多个 // 解决办法：利用构造函数创建正则表达式 var reg = new RegExp(item,&apos;ig&apos;); _msg = _msg.replace(reg,&apos;**&apos;); }) 字符串的截取方法 substring(start[,end])：不包括end所在字符，end省略表示截取到最后 substr(start[,len])：支持负数，len为截取的数量 slice(start[,end]) ：截取start到end(不包括end)的字符串，支持负数 案例：获取url参数var url = &apos;https://www.baidu.com/s?name=laoxie&amp;age=18&amp;sex=male&amp;&apos;; //1. 查找?号所在的索引值 var idx = url.indexOf(&apos;?&apos;); //2.截取到参数字符串 var params = url.slice(idx+1,-1);//name=laoxie&amp;age=18&amp;sex=male //3.生成参数数组 params = params.split(&apos;&amp;&apos;);//[&apos;name=laoxie&apos;,&apos;age=18&apos;,&apos;sex=male&apos;] // 4.遍历数组，获取所有属性/属性值，并组成一个对象 var obj = {};//{key:value} params.forEach(function(kv){ var arr = kv.split(&apos;=&apos;); obj[arr[0]] = arr[1]； }); 字符串大小写转换 toLowerCase()：转换成小写 toUpperCase()：转换成大写 ECMAscript5新增 str[3]//通过下标获取 trim()：删除前后所有空格，返回新的字符串 ASCII码和字符集 字符串.charCodeAt(3) //获取下标为3的字符的编码 String.fromCharCode(94) //编码转换成字符 了解正则表达式(后面再深入了解)1234//创建方式：直接量var reg = //gi;//构造函数的方式var reg = new RegExp(&apos;&apos;); g:表示匹配所有 i:不区分大小写]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(数组ES5方法)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F04%E6%95%B0%E7%BB%84_es5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ECMAScript5(ES5)Array新增方法迭代（遍历）方法（1）迭代forEach(fn)forEach (function( item,idx,arr ){ }) *item 数组的每一项元素 *idx 数组的没一项索引 *arr 当前数组 遍历方法，for循环没有太大差别，比for循环方便 123arr.forEach(function(item)&#123; console.log(item)&#125;); （2）映射map(fn)返回一个数量相等的数组，内容是什么取决于在fn中返回的值 案例：把数组中的每一个数字都增加20%，并返回新的数组 案例：利用map()快速生成商品列表 （3）筛选filter(fn)返回一个数组，存放执行fn后返回true的数组元素，利用这个方法可对数组元素进行过滤筛选 案例：找出数组中小于10的元素，组成新数组 123var res = nums.filter(function(item)&#123; return item&lt;10;&#125;); （4）存在满足判断some(fn)如果该函数对任何一项返回 true，则返回true （5）全部满足判断every(fn)如果该函数每一项都返回 true，才返回true 以上方法都对数组中的每一项运行给定函数fn,，函数中有三个形参分别为- item：数组中的每一项,- index：遍历过程中对应的索引值,- array：对数组的引用 归并方法 这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。 （1）reduce(fn,initVal)（2）reduceRight(fn,initVal) fn(prev,cur,index,array): fn是每一项调用的函数，函数接受4个参数分别是 prev：函数上一次的返回值。（第一次的值参考initVal） cur：当前值， index：索引值， array：当前数组， 函数需要返回一个值，这个值会在下一次迭代中作为prev的值 initVal: 迭代初始值（可省略），如果缺省，prev的值为数组第一项 1234//对数组求和var res = arr.reduce(function(prev,current,idx,arr)&#123; return prev+current;&#125;,0); 静态方法Array.isArray()判断是否为数组，返回true/false 索引方法 区别就是一个从前往后找，一个从后往前找 indexOf/lastIndexOf(keyword [,startIndex]) keyword: 要查找的项， startIndex：查找起点位置的索引，该参数可选，默认0 方法返回keyword所在数组中的索引值，如果数组不存在keyword，则返回-1 *应用：判断数组中是否存在某个值123arr.indexOf(key) != -1 //(1)arr.indexOf(key) &gt;= 0 //(2)some() //(3) 案例： 随机生成一个五位验证码，然后输出该验证码，每位分别是什么 123456789101112//(1)用数组存放五位验证码var res = [];for(var i=0;i&lt;5;i++)&#123; var num = parseInt(Math.random()*10); res.push(num);&#125;console.log(&apos;该随机数是&apos;+res.join(&quot;&quot;));//(2)得出每位分别是什么var show = res.map(function(item,idx)&#123; return &apos;第&apos;+(idx+1)+&apos;位：&apos; + item;&#125;);console.log(show.join()); 2.以上数组的最大值，最小值和平均值，并输出他们的索引 //1. 最大值及对应索引，同理最小值 var maxIdx = 0; var max = arr[0]; arr.forEach(function(item,idx){ if(item&gt;max){ max = item; maxIdx = idx; } }); //2.归并获取总数，求平均值 var total = arr.reduce(function(prev,current){ return prev+current; },0); var avg = total/arr.length; 3.显示10条最新消息]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(数组)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F04.%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组一系列数据的集合，每一项可以保存任何类型的数据，称为数组的元素，每个元素之间用逗号隔开 数组格式：[1,2,3] 数组的声明（创建）1234567//1)字面量(推荐)var arr = [1,2,3];//2)使用构造函数创建var arr = new Array();//创建一个空数组var arr = new Array(7);//创建一个长度为7的数组（数组项都为undefined）var arr = new Array(&apos;王大锤&apos;,18 ,&apos;普通青年&apos;,&apos;广州&apos;);//创建数组并同时写入数据 数组操作(1)数组的读取与写入* 数组的索引 arr[index]index代表索引值，从0开始计数。 12345678var arr = [&apos;html5&apos;,&apos;css3&apos;,&apos;javascript&apos;];//读取arr[0]; //=&gt; &apos;html5&apos;arr[2]; //=&gt; &apos;javascript&apos;//写入arr[3] = &apos;web前端&apos;; (2)数组的遍历* 数组的长度 arr.length1234var arr = [&apos;html5&apos;,&apos;css3&apos;,&apos;javascript&apos;];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; *案例：创建一个数组，存放50个三位数的随机数。var arr = []; for(var i=0;i&lt;50;i++){ //三种写法： // arr[i] = randomNumber(100,999); // arr[arr.length] = randomNumber(100,999); // arr.push(randomNumber(100,999)); } 数组方法（1）增删改 push： 往数组尾部添加一个或多个元素，返回数组新的长度 all.push(all[i]); pop：删除数组最后一个元素，返回删除的元素 unshift：往数组开头添加一个或多个元素，返回数组新的长度 shift：删除数组第一个元素，返回删除的元素 splice(startIdx,deleteNum,…items)：在数组中插入、删除、替换的通用方法 *总结： 方法 返回值 增，例如push（）,unshift() 新数组的长度 删，改，例如pop(),shift(),splice() 被删除的元素 *案例1：找出小于10的元素并组成一个新的数组var arr = [10,15,2,32,5,4,20,8,48,54,6]; // 创建空数组，用于存放所有小于10的数 var res = []; for(var i=0;i&lt;arr.length;i++){ if(arr[i] &lt; 10){ //res[i] = arr[i];//稀疏数组：索引值不连续的数组 res.push(arr[i]); } } *案例2：随机点名//1.获取文本框及按钮 //2.生成数组，存放名字 var arr = [&quot;莫赛&quot;, &quot;何贵宇&quot;, &quot;陈裕&quot;, &quot;林宇鹏&quot;, &quot;卢进球&quot;, &quot;蔡景超&quot;, &quot;周育盛&quot;, &quot;莫钟达&quot;, &quot;邓伟良&quot;, &quot;黄巧玲&quot;, &quot;刘泳仪&quot;, &quot;吕运学&quot;, &quot;苏玉婷&quot;, &quot;黄世军&quot;, &quot;袁家建&quot;, &quot;许诚誉&quot;, &quot;苏媛&quot;, &quot;冯梓兴&quot;, &quot;彭永冬&quot;, &quot;王国健&quot;, &quot;吕志威&quot;, &quot;杨凯彬&quot;, &quot;曾晓添&quot;, &quot;陆世鸿&quot;, &quot;陈瑞敏&quot;, &quot;陈永杏&quot;, &quot;陈培林&quot;, &quot;杨富荣&quot;, &quot;郑幸新&quot;, &quot;肖蔚飞杨家林&quot;, &quot;陆鹏&quot;, &quot;李明钢&quot;, &quot;陈育婷&quot;, &quot;吴玮珏&quot;, &quot;李芸芸&quot;, &quot;周旗勇&quot;, &quot;周华成&quot;, &quot;赵福杰&quot;, &quot;翁旭东&quot;, &quot;甘玉婷&quot;, &quot;林莉&quot;, &quot;梁秋鸿&quot;, &quot;赵晨熙&quot;]; //3.声明函数，生成随机索引，获取数组中索引对应的值。 function getName(){ // 获取随机索引值 var idx = randomNumber(0,namelist.length-1); username.value = namelist[idx]; } //4.执行函数 getName(); btn.onclick = function(){ getName(); } （2）截取数组（原数组不变）slice(start[,end])：返回数组的片段或子数组，从start开始到end(不包括end所对应的元素) 如果省略end参数，则截取到数组的最后一项支持负数 * 可应用于复制一个数组为新数组,通过slice(0)（3）数组排序sort：将数组中的元素排序，并返回排序后的数组 默认以字符串的排列方式（转换成ASCII码进行对比） （4）数组倒序reverse：将数组中的元素颠倒顺序，返回逆序后的数组 （5）将数组拼接成字符串join(separator) 返回字符串值，其中包含了连接到一起的数组的所有元素 separator为分隔符，默认为逗号 （6）数组合并concat() 返回一个新数组，这个新数组是由调用这个方法的数组和参数组成 参数可以是多个 数组排序算法冒泡排序 遍历元素，跟其下一个元素对比 把最大的逐个往后排列 1234567891011var arr = [12,3,44,343,55,1,23];for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var current = arr[j]; arr[j] = arr[j+1]; arr[j+1] = current; &#125; &#125;&#125;console.log(arr); 选择排序法 把当前元素分别跟后面所有的元素对比 把最小的逐个往前排列 123456789101112var arr = [12,3,44,343,55,1,23];for(var i=0;i&lt;arr.length;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]&gt;arr[j])&#123; var current = arr[i]; arr[i] = arr[j]; arr[j] = current; &#125; console.log(&quot;666&quot;); &#125;&#125;console.log(arr); 快速排序法/* * 利用递归函数实现排序 * 每次获取数组中间元素cItem * 把大于和小于cItem的元素分别放置在arrGt和arrLt两个数组中, * 利用concat组合递归调用函数返回的值 * 直到数组的长度等于1时，直接返回元素调出递归 */ var arr = [10, 8, 20, 5, 6, 30, 11, 9]； function fastSort(arr){ //6. 递归退出条件 if(arr.length&lt;=1){ return arr; } //1. 找出数组中间位置元素 var cIdx = parseInt(arr.length/2); //2.删除中间元素，避免与自己本身进行对比而造成死循环 var cItem = arr.splice(cIdx,1);//[6],arr=[10, 8, 20, 5, 30, 11, 9] //3. 创建两个空数组用于保存大于或小于cItem的数字 var arrLt = [];//[5] var arrGt = [];//[10,8,20,30,11,9] // 4.遍历数组，分别与cItem进行对比 // 把小于cItem的数写入arrLt // 把大于cItem的数写入arrGt for(var i=0;i&lt;arr.length;i++){ if(arr[i]&lt;cItem[0]){ arrLt.push(arr[i]) }else{ arrGt.push(arr[i]); } } // 5.组合排序后的数组 return fastSort([5]).concat(cItem,fastSort(arrGt)); } console.log(fastSort(arr)); sort排序arr.sort(function(a,b){ // 在函数内通过返回值告诉sort方法如何排序 return a-b; }); 数组复制与传输如何复制数组123456var arr = [&apos;西施&apos;,&apos;貂蝉&apos;,&apos;张飞&apos;,&apos;关羽&apos;,&apos;刘备&apos;];var res = [];for(var i=0;i&lt;arr.length;i++)&#123; res.push(arr[i]);//方式1，此时res改变一，不影响arr&#125;//方式2：res = arr.slice(0); *案例：编写一个map(arr)函数，把数组中的每一个数字都增加20%，并返回新的数组数组作为参数传递具体详情请看基本数据类型与引用数据类型的区别 多维数组(数组里面包含数组)12var arr = [1,2,&apos;html5&apos;,[3,4,&apos;css3&apos;],[5,6,&apos;javascript&apos;]]arr[3][2]; //=&gt;&apos;css3&apos; 对象Object创建对象 字面量（推荐）：var obj = {name:&#39;小明&#39;,age:18} 构造函数：var obj = new Object(); 对象的操作键值对对象的组成部分 {键(属性)：值(属性值)，} 操作对象键对应的值12345//方式1：点语法 obj.键obj.sex;//方式2：通过obj[&quot;具体的键&quot;]obj[&quot;sex&quot;];//obj[key] //key为所有键的统称变量，记住变量不加引号。 (1)添加、修改属性12obj.sex = &apos;男&apos;;obj[&apos;weight&apos;] = 60； (2)删除属性123var obj = &#123;name:&apos;laoxie&apos;,age:18,gender:&apos;man&apos;&#125;//删除age属性delete obj.age; (3)读取属性值12obj.name;//==&gt;小明//如果读取一个不存在的属性，返回undefined (4)遍历对象for…in12345var obj = &#123;name:&apos;laoxie&apos;，age:18，gender:&apos;男&apos;&#125;； for(var key in obj)&#123; //遍历obj对象里面所有的键key,Obj[key]操作所有键对应的值。 document.write(obj[key]);//分别输出：&apos;laoxie&apos;,18,&apos;男&apos;&#125; 数组与对象的组合12345678910111213141516171819202122232425[&#123; id:&apos;001&apos;, name:&apos;iphone7 plugs&apos;, nickname:&apos;肾7&apos;, imgurl:&apos;img/ip7.jpg&apos;, price:5899.00, sale:5888.00, color:&apos;土豪金&apos; &#125;,&#123; id:&apos;002&apos;, name:&apos;Note7&apos;, nickname：&apos;爆炸7&apos;, imgurl:&apos;img/note7.jpg&apos;, price:3899.00, sale:998.00, color:&apos;黑色&apos; &#125;,&#123; id:&apos;003&apos;, name:&apos;荣耀7&apos;, nickname：&apos;牛x7&apos;, imgurl:&apos;img/honor7.jpg&apos;, price:1999.00, sale:1899.00, color:&apos;白色&apos; &#125;] *案例：根据数据生成一个商品列表]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(function)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F03.function%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数的定义及好处(1)函数就是把特定功能的代码抽取出并进行封装,用来重复执行一些功能。 (2)使用函数的好处: 函数可以重复某一部分代码（通过函数名调用） 使程序变得更简短而清晰 便于程序维护 函数的定义· 关键字function声明（声明式）：格式：function 函数名(){} · 函数表达式(赋值式)格式：var 函数名 = function(){} · Function构造函数（不推荐）var sum = new Function(‘num1’,’num2’,’return num1+num2’); 尽量避免与变量重名 函数的分类内置函数 alert（） 自定义函数 匿名函数 函数的执行声明提前：1.执行js代码前，会将所有的声明提前到当前作用域的最前面。 2.当声明提前完成后，才从上往下执行js代码。 备注：不能再赋值式声明函数前，先使用函数，这样会报错：is not a function（声明提前） 关键字 function声明的函数，可以在函数前后任意调用。 运算无法进行下去会进行隐性转换 、与数字运算无法进行输出NaN. 执行类型1.手动调用: sum(); 2.事件驱动: 格式：元素.事件 = 函数名(或者匿名函数); buton.onclick = sum; 常用事件· onclick：点击事件 · ondblclick：双击事件 · onmouseover：鼠标移入事件 · onmouseout:鼠标移开事件 · onchange：内容改变事件（一般用于表单元素） onkeyup：键盘按键弹起事件 作用域1.全局作用域：函数最外层。 2.局部作用域：函数内。 3.全局变量：声明在全局作用域中的变量，在任意位置使用。 4.局部变量：声明在局部作用域中的变量，只能在当前函数内使用。 变量的访问规则就近原则（如查找变量a）： * 使用变量a时先从当前函数查找，如果有则可以使用; * 如果当前函数无变量a,则往父级函数查找，如果找到则使用，并停止查找; * 如果在父级函数还是无法找到，则继续往上一层函数查找，以此类推; * 直到最顶层(全局作用域)，如果还是没找到，则报not defined错误; 作用域链当函数访问变量时，根据就近原则从内到外查询变量，这个路径称为作用域链。 函数的实参与形参函数的传参：传参的作用：将值传入函数内形参：函数声明时的参数（变量）形式参数 实参：函数执行时的参数 实际参数 注意:形参和实参的数量可以不同 argunments一个类数组，保存着实参的信息 arguments[n (从0开始)] 可以获取到实参的长度 argunments.length 获取实参的长度 函数返回值 return1. 传参是将值传进函数内，return是将值返回到函数外，需要用一个变量接收。 如果函数没有return,执行完后返回undefinedreturn终止函数的执行,即return后的代码不会执行 this 当前对象取决于谁调用了这个函数。 1。大多数情况下，执行函数的对象一般都是window 2。事件驱动执行函数，那么此时的this 指向执行函数的对象. 递归：自己执行自己*需要一个退出函数return条件，若不存在退出条件会死循环。 --num（先自减再返回值）num--（先返回值再自减） *递归前输出，正向输出 *递归后输出，按最后一次递归的值输出。 回调函数若想执行乙，但是需要甲的一个变量，选择在甲函数里面执行乙函数。 ！！！！函数作为参数！！！！！！ 数组Array:一个变量存储多个信息1.获取数组某个信息 索引从0开始计算。 2.属性length 数组的长度。 函数的传参（基本数据类型与引用数据类型的区别） （1）基本数据类型传参 （2）引用数据类型传参（其实传递的是地址，复制出去的数的值改变，会影响到原数组的值）]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(2)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F02.js%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[程序三大流程顺序执行：从上到下 分支执行：通过条件判断语句，执行相应的代码 循环执行：通过循环语句，执行响应的代码 进制1.十进制2.二进制 0b开头，取值为0或13.八进制 0o开头，取值0-74.十六进制 0x开头，取值0-9，a-f5.进制转换(1）十进制转多进制 toString(n) (2) 多进制转十进制 parseInt(num,n); (3) toFixed(n) 保留n位小数 语句分支选择语句（一）if语句1.单分支 if(条件){满足条件执行代码}if(a == 5){ alert(&quot;这个数是5&quot;); } 2.双分支 if(条件){满足条件执行}else{不满足if条件执行这里的代码} if(a == 5){ alert(“这个数是5”); }else{ alert(“这个数不是5”) } 3.多分支if(条件1){ 满足条件1执行}else if(条件2){ 满足条件2执行}else{ 不满足以上所有条件执行} 常犯错误： = 代表的是赋值号， a = b; a =c;相当于b =c。这种说法是不存在的，从始至终，只改变了a的取值，b没有任何变化。 补充：点击事件执行函数（1）给元素添加[onclick = “函数名（）”] （2）定义函数：function 函数名(){}(2) ele.onclick = 函数名 （2）定义函数：function 函数名(){}(3)ele.onclick = function(){} &lt;== 匿名函数switch语句switch(变量||表达式){ case 值1: case 值2: 满足值1执行这里代码; break; case 值3: 满足值2执行这里代码; break; ….. default: 以上条件都不满足执行这里的代码; break;}注意事项： 语句在比较值时使用的是全等操作符 break: 跳出switch语句 switch (true){**case _num1&gt;85:** box.innerHTML = &quot;优秀&quot; ; break; **case _num1&gt;=75&amp;&amp;_num1&lt;=85:** box.innerHTML = &quot;良好&quot; ; break; **case _num1&gt;=60&amp;&amp;_num1&lt;=75:** box.innerHTML = &quot;及格&quot; ; break; **case _num1&lt;60:** box.innerHTML = &quot;不及格&quot; ; break; }当其中case的条件为真时执行冒号后面的代码. 循环语句概念：当满足一定条件的前提下，反复执行某一段代码（死循环）,直到条件不再满足时退出。三大要素：变量初始化、条件、变量更新 while语句变量初始化while(条件){ //条件成立就会不断地执行这里的代码，直到条件不成立 //所以这里一般会伴随着条件的更新 } 备注：若想在输出多个值作为元素的内容，可以考虑字符串拼接的方式。在循环结束后，再给元素赋值。 do while 语句 do{ **这里代码必执行一次** **}while(条件)｛** ｝ for(变量初始化;条件;变量更新){执行的代码}for(var i=10;i&gt;0;i–){ console.log(i);}如何找bug？（1）console提示bug （2）source-打断点-watch添加观察的变量-f10跳过一个函数-f11执行函数的每一句代码 备注：window.onload = function(){}当页面中的所有内容加载完毕后，才执行函数里面的代码 break、continue（循环语句使用）1.break 跳出当前整个循环2.continue 跳出本次循环，继续下一次循环 break一旦运行，当前循环语句里面的代码都不再执行。 在多层循环嵌套中，一个break语句只向外跳一层循环。 break和continue后如果带标识，可以跳出标识所在循环 循环嵌套for(var i=0;i&lt;3;i++){ for(var j=0;j&lt;3;j++){ console.log(i,j); //00 01 02 10 11 12 20 21 22 } } // 执行完里层循环，再执行外层循环]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(1)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F01.js%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[（一）js历史(1)JavaScript的诞生JavaScript 诞生于 1995 年。由Netscape(网景公司)的程序员Brendan Eich(布兰登)与Sun公司联手开发一门脚本语言, 最初名字叫做Mocha，1995年9月改为LiveScript。12月，Netscape公司与Sun公司（Java语言的发明者）达成协议，后者允许将这种语言叫做JavaScript。这样一来，Netscape公司可以借助Java语言的声势。 1996年3月， Netscape公司的浏览器Navigator2.0浏览器正式内置了JavaScript脚本语言. 此后其他主流浏览器逐渐开始支持JavaScript. (2)js版本JavaScript这种语言的基本语法结构是由ECMAScript来标准化的, 所以我们说的JavaScript版本一般指的是ECMAScript版本. · 1997年7月，ECMAScript 1.0发布。 · 1998年6月，ECMAScript 2.0版发布。 · 1999年12月，ECMAScript 3.0版发布。 · 2007年10月，ECMAScript 4.0版草案想要提交ECMA组织, 但由于4.0版的目标过于激进, 改动太大, 并且微软,谷歌等大公司极力反对；一直到2008年7月ECMA开会决定，中止ECMAScript 4.0的开发（即废除了这个版本） · 2009年12月，ECMAScript 5.0版正式发布 · 2011年6月，ECMAscript 5.1版发布 · 2015年6月，ECMAScript 6正式发布，并且更名为“ECMAScript 2015”。 (3)js语言的组成javascript = ECMAScript + BOM + DOM · 核心(ECMAScript) · 浏览器对象模型(BOM) · 文档对象模型(DOM) ECMA 欧洲电脑厂商联合会 制定js规范。 W3c 指定html及css规范 一、js语法（一）js的书写位置1.script[src引入外部js文件][type=&quot;text/javascript&quot;可以省略] * 若是存在src属性，在当前script标签里写代码无效。 2.作为a标签的href属性值[href=&quot;javascript:js代码;&quot;] (二)js注释// 单行注释 /* 多行注释,不要嵌套多行注释 (三) 声明变量及赋值 1. 声明变量(容器)，通过关键字 var var a; 2. 给变量赋值,将10的值赋给a a = 10; 3. 同时声明变量及赋值 var 变量名 = 值; var uname = &quot;lemon&quot;; 4. 同时声明多个变量，用逗号隔开 var b,c,d; b = 100; c = 200; d = 300; var b = 100,c = 200,d = 300; 二、输出1.alert(变量不加引号||具体的值) 弹窗输出alert(uname);alert(10);alert(“uname”); 2. document.write(变量不加引号||具体的值) 在body里面输出内容document.write() 可配合标签使用document.write(“啦啦啦，我是买包小行家“);document.write(uname); 3. console.log(变量不加引号||具体的值) 往控制台console输出内容调试 4.元素.innerHTML=”” 作为元素代码输出（1）将外层引号改成不一样的（单引、双引） （2）通过反斜杠\转义字符 三、运算（一）算术运算 + - * / %(求余数)1.字符串拼接： 当+运算符两侧有一侧为字符串，此时为字符串拼接。例如1+&quot;2&quot;=&quot;12&quot;. *备注：字符串内拼接变量口诀 &quot;+变量+&quot; (引号可以是单引号) 计算两个文本框的值 1.获取到两个文本框 document.getElementById(&quot;id名&quot;) 2.获取到两个文本框里面的内容 value 3.文本框内容进行算术运算，将最终结果输出 4.点击按钮时，才执行23代码 （1）给按钮元素添加点击事件 [onclick=&quot;函数名()&quot;] （2）定义函数，函数里面定义23代码 function 函数名(){js代码} 备注遇到的问题（1）代码执行顺序是从上往下的，必须在元素创建之后才能获取 (2) 点击事件[onclick=&quot;函数名()&quot;]触发函数,自定义函数通过function 函数名(){js代码} （3）**文本框的值肯定是字符串类型，会存在字符串拼接的问题** （二）赋值运算 = 将右边的值赋值给左边 += 在原来基础的内容上追加内容 同理 -= *= /= %= (三)关系运算 !!!!!返回布尔值(存在隐式转换)!!!!!123456789**1. == 等于，判断两边的值的内容发生隐式转换后一致，就返回true**2. != 不等于，只有当两边的值的内容发生隐式转换后不一致，才返回true3. &gt; &gt;= &lt; &lt;=4. === 全等于，只有类型以及内容都一致的情况下（不发生隐式转换），才会返回true5. !== 不全等于 • 关系运算符的比较规则: 1. 数字和数字比较, 直接比较大小 2. 数字和字符串比较, 字符串转换为数字后再比较 **3. 字符串和字符串比较, 进行字符的ASCII码值比较** (四)逻辑运算1234561.与运算 &amp;&amp; * 运算符两侧的值都为true才返回true* !!!!!若与运算左侧的值返回false，直接终止运算!!!!!!!!2.或运算 || * 运算符两侧的值都为false才返回false * 若或运算左侧的值返回true，直接终止运算 (五)一元运算++ 自增1前置 ++a,先对a进行自增1，再将a的值返回出去 后置 a++,先将a的值返回出去，再对a进行自增1 – 自减1同上 (六)三元运算符(双分支情况使用)条件 ？满足条件执行这里:不满足条件执行这里 四、数据类型（值）（一）基本数据类型1.数字类型 Number1var uage = 17; 2.字符串类型String,带引号的值都是字符串类型1var uname = &quot;lemon&quot;; 3.布尔类型 Boolean。两个值：true、false1var result = true; (二)特殊数据类型1.Null 类型只有一个特殊的值为 null,表示一个空对象引用(指针)。2.Undefined 只有一个值undefined。当声明一个变量但未赋值，返回undefined。12345备注：区分undefined与is not definedundefined 声明变量未赋值is not defined 报错，变量未声明 定义 syntax error 语法错误 (三) 引用数据类型1Array(数组)、Object （四）、typeof() 判断数据类型123456typeof(123);//numbertypeof(NaN);//numbertypeof(&quot;123&quot;);//stringtypeof(true);//booleantypeof(null);//object typeof(undefined);//undefined (五）数据类型的转换1.主动转换Number() 将其他数据类型转换成数字类型2.隐式转换：当运算无法进行下去时，内部就会尝试进行数据类型的转换。 1.直接转换 (1）Number() 转换成数字类型 Number(字符串) =&gt; 数字、NaN Number(布尔值) =&gt; 1、0（2）String() 转换成字符串类型,在值两侧加双引号 (3）Boolean() 转换成布尔类型,true、false 备注：数字0、NaN、””、underfine、null 转换成布尔值为false，其余的都是true 隐式转换 当运算无法进行下去时，内部就会尝试进行数据类型的转换。 常用的方法：1.parseInt(a) 将a取整 parseInt(&quot;123.333abc&quot;)====&gt;123 2.parseFloat(a) 取浮点数 parseFloat(“123.333abc”)====&gt;123.3333.Math.round(a) 对a进行四舍五入取整4.Math.random() 取[0,1)里面的随机数，包含0不包含1。 5.getElementById(“id名”) 获取id名所在的元素 6.定义函数 function 函数名(){ var 变量 = .**getElementById(&quot;id名&quot;)**；（获取id名所在元素） var 变量 = 上面变量.属性值； (获取id名元素的属性值) }]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP简介]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2Fphp%E3%80%81ajax%2F02.php%2F</url>
    <content type="text"><![CDATA[wampserver安装及使用1. wampserver安装 a:安装 Web 服务器Apache p:安装 PHP解析器 m:安装MySQL数据库 对于初学者建议使用集成的服务器组件（如：WampServer），它已经包含了 PHP、Apache、Mysql 等服务,免去了开发人员将时间花费在繁琐的配置环境过程。 WampServer下载地址：http://www.wampserver.com/ 若是缺乏某个dll，直接安装vc_redist.x64_2015.exe 【计算机-管理-服务和应用程序-服务-wampapache-wampmysql（开启服务前，先停止svn、mysql、iis）】 测试： 当wampserver图片变成绿色： 网址中输入localhost或127.0.0.1（本机ip），默认打开C:\wamp64\www路径下的index.php 同样可以localhost/*** 访问默认路径下（C:\wamp64\www）的任意文件 2.创建虚拟目录 左键小图标—-&gt;apache—-&gt;alias directories—&gt;add an alias 创建虚拟目录名字，例如aaa。enter后 创建虚拟目录对应的url，即需要开启web服务的文件夹路径(路径不可有中文、空格) 以上步骤完毕，访问虚拟目录只需在浏览器输入http://localhost/aaa，可访问目录下任意文件。 3.创建端口 左键小图标—-&gt;apache—-&gt;httpd-vhost.conf 复制如下代码，往下写。（//只是注释，记得删掉） 12345678910listen 1704 //端口号&lt;VirtualHost *:1704&gt; //端口号 ServerName localhost DocumentRoot D:\laoxie\01Basic //端口对应url(不可有中文路径、空格) &lt;Directory &quot;D:\laoxie\01Basic&quot;&gt; //端口对应url Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 以上步骤完毕，访问端口下目录只需在浏览器输入http://localhost:1704，可访问目录下任意文件。 4.开启局域网服务器1.查看本机ip地址：common+r进入cmd，输入ipconfig，查看ipv4。 2.在vhost.conf给端口对应的url添加一句代码 12#Require local //#代表注释Require all granted //允许其他主机访问 PHP1.概念 PHP是一种通用开源服务端脚本语言，将程序嵌入到HTML文档中去执行，结果以纯 HTML 形式返回给浏览器。PHP: Hypertext Preprocessor “超文本预处理器”，1994年由Rasmus Lerdorf创建，刚刚开始仅仅是为了要维护他本人个人网页而制作的一个简单程序（Perl语言编写），原名Personal Home Page（PHP由此得名），后用C语言重新编写，改名Hypertext Preprocessor PHP能做什么： 生成动态页面内容 创建、打开、读取、写入文件 收集ajax数据 发送和接收cookie 添加、删除、修改您的数据库中的数据 限制用户访问您的网站上的一些页面 加密数据 2.基本语法 默认文件扩展名是 “.php”。 通常包含 HTML 标签和一些 PHP 脚本代码。 分界标示符12345&lt;?php //开始 //...php代码 ?&gt; //结束 注释 与js一样，分单行和多行注释 单行注释：// 多行注释：/**/ 输出语句 echo可以输出一个或多个字符串（字符串可以包含HTML标签），速度较快，一般用于向前端返回数据 123456&lt;?php //输出一个字符 echo &quot;Hello world!&lt;br&gt;&quot;; //输出多个字符 echo &quot;This&quot;, &quot; string&quot;, &quot; was&quot;, &quot; made&quot;, &quot; with multiple parameters.&quot;;?&gt; 12345json_encode(array,JSON_UNESCAPED_UNICODE); 把数组转成字符串 php5.4+ 使用JSON_UNESCAPED_UNICODE防止中文转义json_decode(json,assoc);把字符串转成数组/对象 json：待解码的 json string 格式的字符串 assoc：默认false,返回object, 当该参数为 true 时，将返回array print_r()打印关于变量的信息，适用于数组、对象的打印，一般用于测试 var_dump()判断一个变量的类型与长度,并输出变量的数据类型和数值，一般用于测试 3.变量命名规则 以 $ 符号开始，后面跟着变量的名称（$称为标识符，不属于变量组成部分） 只能包含字母、数字字符以及下划线，不能以数字开头（不能包含空格） 区分大小写 12345//PHP 没有声明变量的命令，也没有声明提前的概念。//变量在第一次赋值时被创建：&lt;?php $txt=&quot;Hello world!&quot;;?&gt; 拼接字符串及变量123456&lt;?php $myname = &quot;lemon&quot;; echo &apos;My name is&apos; . $myname; //1.通过并置运算符.拼接字符串及变量 //或者 echo &quot;My name is $myname&quot;； //2.双引号内可以直接输出变量，无需拼接?&gt; 函数中访问全局变量！！！ 全局变量：在函数外部定义的变量，可以在任意位置访问(需要手动定义为全局变量) 局部变量：函数内部声明的变量，仅能在函数内部访问 （1） $GLOBALS 123456789101112&lt;?php $x=&apos;global x&apos;; function myTest()&#123; //echo $x;//报错 Undefined variable:未声明定义的变量 echo $GLOBALS[&apos;x&apos;]; //1.获取全部变量正确写法：$GLOBALS[变量名]，其中变量名不带$。 //2.同时，可以在函数中创建全局变量 $GLOBALS[&apos;y&apos;] = $GLOBALS[&apos;x&apos;] + $GLOBALS[&apos;y&apos;]; &#125; myTest(); echo $y;?&gt; （2）global 关键字 123456789&lt;?php $x=5; function myTest()&#123; global $x; $y=$x; &#125; myTest(); echo $y; ?&gt; 超级全局变量 $GLOBALS是PHP的一个包含所有全局变量的数组，可以在任意位置使用 $_SERVER是一个包含了头信息(header)、路径(path)等信息的数组 $_POST / $_GET被广泛应用于收集表单数据，常用于ajax请求等操作 $_COOKIE用于收集前端发送过来的cookie数据 $_REQUEST变量包含了 $_GET、$_POST 和 $_COOKIE 的内容 $_SESSION服务器版cookie $_FILES 常量 规范 命名规则与变量一致，但常量名不需要加 $ 修饰符。 常量值被定义后，在脚本的其他任何地方都不能被改变。 默认是全局作用域，可以在整个运行的脚本的任何地方使用。 常量名建议全部大写 格式： define(name常量名称,value常量值) 1define(&quot;EN_NAME&quot;, &quot;laoxie&quot;); // const MY_NAME = &quot;lemon&quot;; 4.运算符及语句（等同于js）算术运算符、赋值运算符、递增/递减运算符、比较运算符(等于大于...)、逻辑运算符(与或非)、三元运算符 条件语句、循环语句 5.数据类型$$String（字符串）Integer（整型）Float（浮点型）Boolean（布尔型）Array（数组）Object（对象）NULL（空值）$$ String strlen() 获取字符串长度，得到的字符的字节数 mb_strlen() 获取字符串长度， strpos() 查找某个字符在字符串中的索引，如果未找到匹配，则返回 false 1strpos(&quot;Hello world!&quot;,&quot;world&quot;);//=&gt;6 Array 数组是一个能在单个变量中存储多个值的特殊变量。 （1）创建数组：array()12345//1.数值数组，等同于js的数组$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);//2.关联数组，等同于js的对象$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);//3.多维数组，包含一个或多个数组的数组 （2）数组常用方法 count() 获取数组长度 in_array() 判断某个值是否存在数组中 array_slice() 从数组中取出一段 array_rand() 随机获取数组的索引值 练习案例：在php文件里生成动态商品页面（3）遍历数组 for 一般用于遍历数值数组 foreach() 一般用于遍历关联数组,或者对象 123456789101112131415161718192021&lt;?php //遍历数值数组：for循环 $cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); $arrlength=count($cars); for($x=0;$x&lt;$arrlength;$x++)&#123; echo $cars[$x] . &quot;&lt;br&gt;&quot;; &#125; //关联数组： $age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); //获取单个值 echo $age[&apos;peter&apos;]; //遍历关联数组：foreach..as foreach($age as $key=&gt;$value)&#123; echo $key .&quot;:&quot;. $value; echo &quot;&lt;br&gt;&quot;; &#125; //多维数组： foreach($age as $item)&#123; //item代表数组里面的关联数组 &#125;?&gt; 数组排序 sort() 对数组进行升序排列 rsort() 对数组进行降序排列 asort() 根据关联数组的值，对数组进行升序排列 ksort() 根据关联数组的键，对数组进行升序排列 arsort() 根据关联数组的值，对数组进行降序排列 krsort() 根据关联数组的键，对数组进行降序排列]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax简介]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2Fphp%E3%80%81ajax%2F01.Ajax%2F</url>
    <content type="text"><![CDATA[Ajax了解AJAX AJAX: Asynchronous Javascript And Xml，Ajax 技术的核心是XMLHttpRequest对象（简称XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现 *Ajax起源：最早出现在2005年的google搜索建议 ajax优点 增加速度：减轻服务器的负担,按需加载数据,最大程度的减少冗余请求 改善的用户体验：局部刷新页面,减少用户等待时间,带来更好的用户体验 页面和数据分离：前后端分离，操作更灵活，后期维护更方便 后端语言和服务器配置 php + Apache + mySQL NodeJS + MongoDB Java + tomcat + Oracle .NET + IIS + SQL Server jsonjson数据(json字符串)1&#123;&quot;id&quot; : 21465461461461, &quot;name&quot;: &quot;张三&quot;&#125;,[&#123;&quot;id&quot; : 21465461461461, &quot;name&quot;: &quot;张三&quot;&#125;] json字符串与对象的转换12345678//（一）json字符串转成对象的转换//1. eval(&quot;(&quot;+json字符串+&quot;)&quot;); 它的作用是，将一个普通的json格式的字符串，转换成Json格式的对象//var list = eval(&quot;(&quot;+request.responseText+&quot;)&quot;);//2. JSON.parse(); //把JSON字符串转成JSON对象(js对象/数组)【es5】//（二）把JSON对象转成JSON字符串JSON.stringify(); 了解json文件存在的意义123456789//模拟数据(与后端先商量)[ &#123; &quot;id&quot;:&quot;G001&quot;, &quot;name&quot;:&quot;Thermos 膳魔师 Funtainer系列水杯 12盎司（340g） 粉红色&quot;, &quot;imgurl&quot;:&quot;images/g1.jpg&quot;, &quot;price&quot;:899, &#125;] Ajax请求步骤创建请求对象,返回一个异步请求对象var xhr = new XMLHttpRequest(); 处理服务器返回数据123456xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; //responseText：保存服务器返回的数据（从服务器返回的数据是“字符串”）。 alert(xhr.responseText); &#125;&#125; 设置请求参数，建立与服务器连接1xhr.open(&quot;get&quot;, &quot;http://localhost/api/ajaxtest&quot;, true); 向服务器发送请求xhr.send(null); 案例：演示向goodslist.json请求数据XMLHttpRequest对象属性方法open(type,url（同源策略）,async（同步、异步）)12345678910111213141.open(type,url,async): 建立与服务器的连接 type：请求的类型，get、post * 区别? get请求数据接在url后面，post请求数据通过send方法传递 get传递的数据会比较少 get传递的数据会暴露出来 url：数据请求的地址（API地址），一般由后端开发人员提供 * 当前页面访问地址，API地址两者一定要同域 * 同域（同源策略）：协议，域名，端口三者一致 * 报错： No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. async：是否异步发送请求（true,false），默认为true * 同步：按步骤顺序执行，前面的代码执行完后，后面的代码才会执行 做完前一件事情, 才能下一件事情（排队） * 异步：与其他操作同时执行，也叫并发（图片加载，ajax请求，定时器） send(data)1234567892.send(data): 向服务器发送请求 data：可选参数，post请求时才生效，表示发请求时传送的数据字符串。 xhr.send(&apos;size=20&amp;type=music&apos;); 在某些浏览器中，如果不需要通过post请求主体发送数据，则必须传入null//备注：get请求的数据写在url地址后 request.open(&quot;get&quot;, &quot;http://localhost/api/getdata.php?type=get&amp;qty=10&quot;, true); setRequestHeader(key,val)：设置请求头//备注：利用请求头设置POST提交数据格式： xhr.setRequestHeader(‘content-type’,”application/x-www-form-urlencoded”)；//open方法后设置 **在请求收到服务器的响应后，响应的数据会自动填充xhr 对象的属性，相关的属性简介如下： readyState1234560 － （未初始化）尚未调用open()方法。1 － （启动）已经调用open()方法，但尚未调用send()方法。2 － （发送）send()方法执行完成，但尚未接收到响应。3 － （接收）已经接收到部分响应数据。4 － （完成）响应内容解析完成，可以在客户端调用了只要readyState 属性的值由一个值变成另一个值，都会触发一次readystatechange 事件。必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 responseText保存服务器返回的数据（从服务器返回的数据是“字符串”）。 status12345678* 响应的HTTP 状态。200（OK）：服务器成功返回了页面304（Not Modified）：数据与服务器相同，不需要重服务器请求（直接使用缓存的数据）400（Bad Request）：语法错误导致服务器不识别401（Unauthorized）：请求需要用户认证404（Not found）：请求地址不存在500（Internal Server Error）：服务器出错或无响应503（ServiceUnavailable）：由于服务器过载或维护导致无法完 php本地数据操作获取前端数据123$_GET 获取前端用get方式传递过来的数据（url地址后面数据也能被获取）$_POST 获取前端用get方式传递过来的数据isset() 判断某个值是否被设置，若不存在返回boolean 文件的读取与写入fopen(path,mode)：打开文件 使用fopen函数打开文件时，你首先需要明确打开文件的模式：1.将数据写入文件，亦或者读写文件2.考虑如果文件中已经存在相关数据，你是覆盖原有文件中的数据呢，还是仅仅将新数据添加至文件末尾 文件模式: r 以只读方式打开文件，从文件头开始读 r+ 以读写方式打开文件，写入时以追加的方式写入文件 w 以写入方式打开文件，从文件头开始写。文件不存在则尝试创建，若存在，则先删除文件中的内容 w+ 以读写方式打开文件，从文件头开始读写。文件不存在则尝试创建，若存在，则先删除文件中的内容 a 以写入方式打开，从文件末尾开始追加写。如果文件不存在则尝试创建 a+ 以读写方式打开，从文件末尾开始追加写入或者读。如果文件不存在则尝试创建。 fread(file,length)：读取内容fwrite(file,json字符串)：写入内容fclose(file)：关闭文件,避免资源占用filesize(path)：读取文件字符长度//1.以读取模式打开文件 $path = &apos;./data/weibo.json&apos; $myfile = fopen($path, &apos;r&apos;); //2.读取文件内容 $content = fread($myfile, filesize($path)); //3.关闭文件，减少资源占用 fclose($myfile); 123456echo返回数据json_encode(); 把数组转成字符串 php5.4+ 使用JSON_UNESCAPED_UNICODE防止中文转义json_decode(json,assoc); 把字符串转成数组/对象 json：待解码的 json string 格式的字符串 assoc：默认false,返回嵌套对象的多维数组，通过arr-&gt;key获取对象键对应的值。当该参数为 true 时，将返回嵌套关联数组的多维数组，通过arr[key]获取关联数组键对应的值。 案例：微博点赞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//（html页面）1.发起ajax请求，将weibo.json的内容返回到页面var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; var res = JSON.parse(xhr.responseText); ul.innerHTML = res.map(item=&gt;&#123; return `&lt;li data-id=&quot;$&#123;item.id&#125;&quot;&gt; &lt;h4&gt;$&#123;item.username&#125;&lt;/h4&gt; &lt;p&gt;$&#123;item.content&#125;&lt;/p&gt; &lt;span&gt;$&#123;item.comtcnt&#125;&lt;/span&gt; &lt;span class=&quot;like&quot;&gt;$&#123;item.likecnt&#125;&lt;/span&gt; &lt;/li&gt;`; &#125;).join(&apos;&apos;); datalist.appendChild(ul); &#125;&#125;xhr.open(&apos;get&apos;,&apos;../data/weibo.json&apos;,true);xhr.send();//(html页面)2.点赞，获取到当前按钮对用的id，发送ajax请求，get方法通过url拼接参数传送id到后台。//随后php页面对json数据进行修改，再将当前被改变的对象返回。xhr对象通过responseText进行接收为字符串，转成对象，获取到linkcnt键对应的值，给当前事件源修改innerHTML。//考虑多次请求，可能存在缓存状态，所以补充若是status为304也为请求成功。datalist.onclick = function(e)&#123; if(e.target.className === &apos;like&apos;)&#123; // e.target.innerText = e.target.innerText*1+1; // 获取当前微博id let currentLi = e.target.parentNode; let id = currentLi.dataset.id; let xhr = new XMLHttpRequest(); let status = [200,304]; xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; status.indexOf(xhr.status)&gt;=0)&#123; let res = JSON.parse(xhr.responseText); e.target.innerHTML = res.likecnt; &#125; &#125; xhr.open(&apos;get&apos;,&apos;../api/weibo.php?id=&apos;+id,true); xhr.send(); &#125;&#125;//（php）//1.接收前端传过来的id，返回值为字符串$id = isset($_GET[&apos;id&apos;]) ? $_GET[&apos;id&apos;] : Null;//2.打开json文件fopen()，读取json文件数据fread()。$path = &apos;&apos;;//相对路径$file = fopen($path,&quot;r&quot;);$content = fread($file,filesize($path));fclose($file);//2.对得到的content内容转成json数组后，遍历里面每个item对象，若id键对应的值等于传入的$id,将该对象的linkcnt++。$contentArr = json.decode($content);//此处contentArr为对象数组$res;foreach($contentArr as $item)&#123; //此处item为一个对象 if($item-&gt;id == $id)&#123; $item-&gt;linkcnt++; $res = $item; &#125; &#125;//4.将contentArr转成字符串，重新写入json文件$file = fopen($path, &apos;w&apos;);fwrite($file, json_encode($arr,JSON_UNESCAPED_UNICODE));fclose($file);//5.将步骤2声明变量res，将改变的item对象用res接收，转成字符串，echo给前端echo json_encode($res,JSON_UNESCAPED_UNICODE); 补充：eval的使用12345var json = &apos;&#123;&quot;name&quot;:&quot;lemon&quot;,&quot;age&quot;:18&#125;&apos;; //标准json字符串var json = &apos;&#123;&quot;name&quot;:&quot;lemon&quot;,\&apos;age\&apos;:18&#125;&apos;;//不标准eval(&apos;(&apos;+json+&apos;)&apos;);//也可以转成对象eval(&apos;1+2&apos;);//3eval(&apos;定义函数；执行函数&apos;) //函数可以在字符串中执行 讲解：ajax的来历及同源策略、同步异步案例：用户名验证username.onblur = function(){ let _username = username.value; let status = [200,304]; let xhr = new XMLHttpRequest(); //xhr.onload意思为数据请求完成后，等同于xhr.readystate==4的状态 xhr.onload = function(){ if(status.includes(xhr.status)){ let res = xhr.responseText;//fail,success if(res === &apos;fail&apos;){ username.nextElementSibling.innerHTML = `${_username}太受欢迎，你走吧`； }else{ username.nextElementSibling.innerHTML = `恭喜你绿了`； } } } xhr.open(&apos;get&apos;,&apos;../api/checkname.php?username=&apos;+_username,true); xhr.send(); } //php //1.数组存放已经存在的用户名 $userlist = array(&apos;张三&apos;,&apos;李四&apos;,&apos;王尼玛&apos;,&apos;奥巴马&apos;,&apos;laoxie&apos;,&apos;lemon&apos;); //2. 获取前端传来的用户名 $username = isset($_GET[&apos;username&apos;]) ? $_GET[&apos;username&apos;] : null; //3. 判断前端传来的用户名是否已存在数组内 $res = in_array($username, $userlist); if($res){ // 用户名已存在，注册失败 echo &quot;fail&quot;; }else{ echo &quot;success&quot;; } 案例：分页数据加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//html页面：var qty = 5;// 1.发起ajax请求数据，拿到返回的数据，转成对象。let status = [200,304]let xhr = new XMLHttpRequest();xhr.onload = function()&#123; if(status.includes(xhr.status))&#123; let res = JSON.parse(xhr.responseText); // 2.拿到对象的data键对应的值(为json字符串)，渲染页面 datalist.innerHTML= res.data.map(function(item)&#123; return `&lt;li&gt; &lt;h4&gt;$&#123;item.name&#125;&lt;/h4&gt; &lt;div&gt;$&#123;item.content&#125;&lt;/div&gt; &lt;/li&gt;`; &#125;).join(&quot;&quot;); //3.得到总页码数pageNum，parseInt(数据总数res.total/每页数据qty).遍历生成页码 var pageNum = parseInt(res.total/res.qty); page.innerHTML = &quot;&quot;; for(var i=0;i&lt;pageNum;i++)&#123; var span = document.createElement(&quot;span&quot;); span.innerHTML = i+1; //5.拿到返回的当前页码-1，把当前索引设置高亮 var curidx = res.curpage -1; if(i == curidx)&#123;span.className = &quot;active&quot;;&#125; page.appendChild(span); &#125; &#125;&#125;xhr.open(&apos;get&apos;,&apos;../api/lemon.php?qty=&apos;+qty+&apos;&amp;curpage=1&apos;,true);xhr.send();// 4.点击分页切换page.onclick = function(e)&#123; if(e.target.tagName.toLowerCase() === &apos;span&apos;)&#123; let curpage = e.target.innerText; xhr.open(&apos;get&apos;,&apos;../api/lemon.php?qty=&apos;+qty+&apos;&amp;curpage=&apos;+curpage,true); xhr.send(); &#125;&#125;//php：&lt;?php $qty = isset($_GET[&quot;qty&quot;])? $_GET[&quot;qty&quot;] : 5; $curpage = isset($_GET[&quot;curpage&quot;])? $_GET[&quot;curpage&quot;] : 1; //1.拿到json数据,根据每页数量与当前页，裁切对应的数据 $path = &apos;../data/football.json&apos;; $file = fopen($path,&apos;r&apos;); $content = fread($file,filesize($path)); $data = json_decode($content); $curdate = array_slice($data,$qty*($curpage-1),$qty); //2.格式化数据，再返回给前端 $res = array( &quot;total&quot; =&gt; count($data), &quot;data&quot; =&gt; $curdate, &quot;qty&quot; =&gt; $qty*1, &quot;curpage&quot; =&gt; $curpage*1, ); echo json_encode($res,JSON_UNESCAPED_UNICODE);?&gt; ajax跨域解决方案JSONP JSONP 是JSON with padding（填充式JSON 或参数式JSON）的简写。 JSONP是一种可以绕过浏览器的安全限制，从不同的域请求数据的方法。 JSONP请求不是ajax请求，是利用script标签能加载其他域名的js文件的原理，来实现跨域数据的请求 局限性： 只能为get请求 接口必须有回调函数的执行 演示：使用script标签其他js文件调用本地js的某个函数123456789101112//html页面：&lt;script type=&quot;text/javascript&quot;&gt; function sum(n)&#123; console.log(n); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/common.js&quot;&gt;&lt;/script&gt;//common.js代码sum(6666);//此时html页面的控制台打印 6666。 演示：使用script标签其他php文件调用本地js的未知名方法，返回数据12345678910111213141516//html页面：&lt;script type=&quot;text/javascript&quot;&gt; function sum(data)&#123; console.log(data); &#125; function sum2(data)&#123; alert(data); &#125;&lt;/script&gt;&lt;script src=&quot;../api/lemon.php?callback=函数名&quot;&gt;&lt;/script&gt;//php文件：&lt;?php $fn = $_GET[&quot;callback&quot;]; echo &quot;$fn(数据)&quot;;?&gt; 案例：利用JSONP原理调用百度建议msg.oninput = function(){ let _msg = msg.value; clearTimeout(timer); timer = setTimeout(()=&gt;{ let script = document.createElement(&apos;script&apos;); script.src=&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/sujson=1&amp;cb=getData&amp;wd=&apos;+_msg; document.body.appendChild(script); },500); } window.getData = function(data){ suggest.innerHTML = data.s.map(item=&gt;{ return `&lt;li&gt;${item}&lt;/li&gt;` }).join(&quot;&quot;); } }) //原理性代码： //1.script的src中回调函数的传递 script.src=&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/sujson=1&amp;cb=getData&amp;wd=&apos;+_msg; //2.声明全局函数 window.getData = function(data){处理数据} CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing），它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 1.Access-Control-Allow-Origin header(&apos;Access-Control-Allow-Origin: * &apos;); 该字段是必须的。需要在后端响应头添加词字段，值要么是一个*，表示接受任意域名的请求，要么指定一个域名http://localhost。 2.Access-Control-Allow-Methods 3.Access-Control-Allow-Headers header(&apos;Access-Control-Allow-Methods:POST&apos;); header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;); 案例：天气预报//1.直接利用ajax请求得到数据 let xhr = new XMLHttpRequest(); let status = [200,304] xhr.onload = function(){ if(status.includes(xhr.status)){ let res = JSON.parse(xhr.responseText) console.log(res.data); //拿到数据，可以渲染部分到页面上 let title = document.createElement(&apos;h2&apos;); title.innerHTML = res.data.city + &apos;天气预报&apos;; let tips = document.createElement(&apos;p&apos;); tips.innerHTML = res.data.ganmao; let ul = document.createElement(&apos;ul&apos;); ul.innerHTML = res.data.forecast.map(item=&gt;{ return `&lt;li&gt; &lt;h4&gt;${item.date}&lt;/h4&gt; &lt;p&gt;${item.low} / ${item.high}&lt;/p&gt; &lt;p class=&quot;type&quot;&gt;${item.type}&lt;/p&gt; &lt;/li&gt;` }).join(&apos;\n&apos;); // 清空内容 weather.innerHTML = &apos;&apos;; weather.appendChild(title); weather.appendChild(tips); weather.appendChild(ul); } } xhr.open(&apos;get&apos;,&apos;http://wthrcdn.etouch.cn/weather_mini?city=广州&apos;,true); xhr.send(); //2.配合文本框实现，得到不同城市的天气预报 city.onblur = function(){ let _city = city.value.trim(); if(_city.length === 0){ return; } xhr.open(&apos;get&apos;,&apos;http://wthrcdn.etouch.cn/weather_mini?city=&apos;+_city,true); xhr.send(); } 演示：百度地图服务器代理后端不存在跨域问题，所以可以利用后端间接获取其他网站的数据 PromisePromise是一个构造函数，所谓的Promise对象，就是通过new Promise()实例化得到的对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 Promise 的三种状态Pending（未完成）可以理解为Promise对象实例创建时候的初始状态Resolved（成功） 可以理解为成功的状态Rejected（失败） 可以理解为失败的状态]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(一些面试问题、无答案)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[初级问题手写数组去重 手写数组倒序 各种场景下的this指针问题 冒泡，选择，插入排序用js怎么写，时间复杂度多少空间复杂度多少 http和https有什么区别 端口号多少 三次握手过程 四次挥手过程 域名解析过程 三列布局中间固定左右自适应的三种写法 变量提升问题 那些数组方法会生成一个新数组，那些不会生成新数组 上面那些问题回答不上来说明你不仅前端不行，上大学也没好好学习，赶紧滚去学习吧 进阶下面这些问题是针对一般学习前端两个月都应该会的问题，如果已经学习很久了这些问题还是有盲区的化说明前端不适合你，或者你不适合前端 怎样理解语义化 怎样理解表现与样式分离 什么是混杂模式严格模式，怎样触发 常见的mate 标签 什么是文本流 文档流 dom树 什么是行元素 什么是块元素 通过那些属性可以让行元素转换成块元素 可以设置宽高的行元素叫什么 css常见几种选择器 选择器的权重值分别多少 js中有几种变量类型 哪些放在堆 哪些放在栈 变量类型隐形转换问题 如何声明函数 高级下面这些问题是一个前端开发应该会的，如果不会就别去找工作让面试官鄙视你 闭包是什么，怎么形成这种结构 有什么用处何危害 有没有实际的案例 settimeout在不同的情况下的执行顺序 settimeout中的this指针指向 手写继承实现 手写深浅数组克隆 手写一个方法取出url后面的参数 几种跨域的方法 手写ajax函数兼容ie和标准浏览器 浏览器状态码有哪些 高级进阶下面这些问题是最近比较常问的，回答不上来一定会pass 什么是宏任务什么是微任务 promise的运行机制，几种状态 介绍缓存机制 cookie session localstorage区别 mvc mvvm区别 angular vue react区别 angular双向数据绑定原理 vue双向数据绑定原理 什么是虚拟dom 怎么实现 vue组件传值的五种方法 vuex是什么 输入一个url到页面显示都会发什么 性能优化的点 如何实现节省流量 前端安全攻击有几种 如何避免 dom树的节点遍历]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介(开发基础应用)]]></title>
    <url>%2F2019%2F05%2F19%2FJS%E5%9F%BA%E7%A1%80%2F%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[随机数1var randomNum = parseInt(Math.random()*100+1); //[1,101)随机数 Math.random()*几 就是0到几的随机数 验证码12var randomNum = &quot;&quot;+parseInt(Math.random()*10) + parseInt(Math.random()*10) + parseInt(Math.random()*10) + parseInt(Math.random()*10);//四位验证码：创建四位随机数前面加个空字符串变成字符串凭借 字符串转数组123var str = &quot;good good study&quot;; var arr = str.split(&quot; &quot;);//字符串截取 console.log(arr); 数组转字符串123var a, b;a = new Array(0,1,2,3,4);b = a.join(&quot;-&quot;); //&quot;0-1-2-3-4&quot; 对象转数组123456var obj = &#123;name:&apos;laoxie&apos;,age:18,gender:&apos;男&apos;&#125;;var all = []; for(var key in obj)&#123; all.push(obj[key]); console.log(all); &#125; 12345678910111213141516171819202122232425function fun5() &#123; var scoreObject = &#123; &quot;Tony&quot;: &#123; &quot;Math&quot;: 95, &quot;English&quot;: 79, &quot;Music&quot;: 68 &#125;, &quot;Simon&quot;: &#123; &quot;Math&quot;: 100, &quot;English&quot;: 95, &quot;Music&quot;: 98 &#125;, &quot;Annie&quot;: &#123; &quot;Math&quot;: 54, &quot;English&quot;: 65, &quot;Music&quot;: 88 &#125; &#125; var arr= []; for (var i in scoreObject)&#123; arr.push(i,scoreObject[i].Math,scoreObject[i].English,scoreObject[i].Music); &#125; console.log(arr); &#125; fun5();//对象内多个属性 页面数据传递12345678910111213141516171819var goods = &#123; name:&apos;阿联酋美女&apos;, age:18, price:&apos;20W&apos;, imgurl:&apos;../images/x.jpg&apos; &#125; var params = &quot;&quot;; // 对象转成字符串 // 传递数据时，不能直接传递对象。需要将对象转成name=阿联酋美女&amp;age=18&amp;price=20W这种格式 for(var key in goods)&#123; params += key + &quot;=&quot; + goods[key] + &quot;&amp;&quot;; &#125; params = params.slice(0,-1); console.log(params); var meinv= document.getElementsByClassName(&apos;meinv&apos;); //for循环 meinv[0].onclick = function()&#123; location.href = &quot;04details.html?&quot; + encodeURI(params); &#125; 1234567891011121314151617 var tupian = document.getElementById(&quot;tupian&quot;); var meinvName = document.getElementById(&quot;meinvName&quot;); // 1. var params = decodeURI(location.search).slice(1); // ===========================2.将字符串转成对象=========== // 字符串=split(&quot;&amp;&quot;)=&gt;数组[&quot;name=美女&quot;,&quot;age=18&quot;,] var paramsArr = params.split(&quot;&amp;&quot;); var paramsObj = &#123;&#125;; paramsArr.forEach(function(item)&#123; var arr = item.split(&quot;=&quot;); paramsObj[arr[0]] = arr[1]; &#125;);//&#123;name: &quot;%E9%98%BF%E8%81%94%E9%85%8B%E7%BE%8E%E5%A5%B3&quot;, age: &quot;18&quot;, price: &quot;20W&quot;,imgurl: &quot;../images/x.jpg&quot;&#125; // =========================== // 3.给元素赋值 tupian.src = paramsObj.imgurl; meinvName.innerHTML = paramsObj.name; 生成表格123456789101112131415function setTable(r,c)&#123; var table = document.createElement(&quot;table&quot;); var tbody = document.createElement(&quot;tbody&quot;); for(var i=0;i&lt;r;i++)&#123; var tr = document.createElement(&quot;tr&quot;); for(var j=0;j&lt;c;j++)&#123; var td = document.createElement(&quot;td&quot;); td.innerHTML = &quot;单元格&quot;+i+j; tr.appendChild(td); &#125; tbody.appendChild(tr); &#125; table.appendChild(tbody); return table; &#125; tab标签切换123456789101112131415161718192021222324252627282930/* tab标签切换 思路： 1）初始化 * 高亮第一个tab * 隐藏除第一张以外的图片 2）切换：鼠标点击tab（关键：获取点击的index值） * 高亮显示当前tab,去除其他所有高亮（遍历） * 切换相应的图片，隐藏其他所有图片（遍历） */ var tab = document.getElementsByClassName(&apos;tab&apos;)[0]; var tabItem = tab.children[0].children; var tabContent = tab.children[1].children; tabItem[0].className = &quot;active&quot;; tabContent[0].style.display = &quot;block&quot;; for(var i=0;i&lt;tabItem.length;i++)&#123; tabItem[i].idx = i; tabItem[i].onmouseover= function()&#123; for(var i=0;i&lt;tabItem.length;i++)&#123;//先遍历一遍让所有的项都为下面的样式 tabItem[i].className = &quot;&quot;; tabContent[i].style.display = &quot;none&quot;; &#125; this.className = &quot;active&quot;;//for循环结束后添加类名样式 实现单一内容显示 // var idx = this.getAttribute(&quot;idx&quot;); getAttribute() 方法返回指定属性名的属性值 // tabContent[idx].style.display = &quot;block&quot;; // 当前tab对应的content出现.通过索引 tabContent[this.idx].style.display = &quot;block&quot;; &#125; &#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单表格]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F%E8%A1%A8%E5%8D%95%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[表单HTML属性form 元素HTML 表单用于收集用户输入。 元素定义 HTML 表单： form: [action 提交到的后台地址] [methhod 提交方式=(get、post)] [name表单名字] form元素属性 属性 描述 accept-charset 规定在被提交表单中使用的字符集（默认：页面字符集）。 action 规定向何处提交表单的地址（URL）（提交页面）。 autocomplete 规定浏览器应该自动完成表单（默认：开启）。 enctype 规定被提交数据的编码（默认：url-encoded）。 method 规定在提交表单时所用的 HTTP 方法（默认：GET）。 name 规定识别表单的名称（对于 DOM 使用：document.forms.name）。 novalidate 规定浏览器不验证表单。 target 规定 action 属性中地址的目标（默认：_self）。 HTML 表单包含表单元素。 表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。 input 元素 元素是最重要的表单元素。 元素有很多形态，根据不同的 type 属性。 type]类型： 类型 描述 text 定义常规文本输入。 radio 定义单选按钮输入（选择多个选择之一） submit 定义提交按钮（提交表单） password 密码框 radio 单选框 checkbox 多选框 button 普通按钮 reset 重置按钮 file 上传文件 image 图像提交按钮 color 拾色器 email 邮箱（正则验证） number 数字 tel 电话号码 url 网址（正则验证） search 搜索 range 特定范围内的数值选择器 min最小值、max最大值、step( 步数 )、value当前值 date 用于应该包含日期的输入字段。 日期选择器 month 允许用户选择月份和年份 week 允许用户选择周和年 time 允许用户选择时间（无时区） input: [type]类型: 属性 text 文本框 password密码框 radio单选框 submit 提交按钮 button普通按钮 reset重置按钮 [name] 同一组单选框或者多选框要起一样的没名字. 要提交的表单内容必须要加名字 [checked] 默认选中 [value]给表单添加初始内容 ​ [type]类型: text 文本框 password密码框 radio单选框 submit 提交按钮 button普通按钮 reset重置按钮 [name] 同一组单选框或者多选框要起一样的没名字. 要提交的表单内容必须要加名字 [checked] 默认选中 [value]给表单添加初始内容 select下拉列表optiont选项form&gt;select&gt;optiont选项 value[selected默认选中] ​ textarea 文本域​ form&gt;textarea文本域【cols列】[rows行] button可点击按钮 元素定义可点击的按钮： 实例 1&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;Hello World!&apos;)&quot;&gt;Click Me!&lt;/button&gt; datalist 下拉列表元素 元素为 元素规定预定义选项列表。 用户会在他们输入数据时看到预定义选项的下拉列表。 拥有搜索框的下拉列表 元素的 list 属性必须引用 元素的 id 属性。 实例 通过 设置预定义值的 元素： 12345678910&lt;form action=&quot;action_page.php&quot;&gt;&lt;input list=&quot;browsers&quot;&gt;&lt;datalist id=&quot;browsers&quot;&gt; &lt;option value=&quot;Internet Explorer&quot;&gt; &lt;option value=&quot;Firefox&quot;&gt; &lt;option value=&quot;Chrome&quot;&gt; &lt;option value=&quot;Opera&quot;&gt; &lt;option value=&quot;Safari&quot;&gt;&lt;/datalist&gt; &lt;/form&gt; fieldset表单字段集&lt;fieldset&gt;&lt;/fieldset&gt; 对表单中的元素进行分组 label提示信息标签​ [for] 关联到id名所在的表单元素 若用于单选框或多选框，一般都是直接将文字及表单元素包含在label里面。 表单标签内加HTML属性1.autofocus 自动聚焦2.placeholder 占位符3.required 必填项4.pattern 正则输入限制这里列出了一些常用的输入限制（其中一些是 HTML5 中新增的）： 属性 描述 disabled 规定输入字段应该被禁用。 max 规定输入字段的最大值。 maxlength 规定输入字段的最大字符数。 min 规定输入字段的最小值。 pattern 规定通过其检查输入值的正则表达式。 readonly 规定输入字段为只读（无法修改）。 required 规定输入字段是必需的（必需填写）。 size 规定输入字段的宽度（以字符计）。 step 规定输入字段的合法数字间隔。 value 规定输入字段的默认值。 表格布局元素表格布局元素 表格 描述 定义表格 定义表格标题 定义表格列标题 定义表格的行 定义表格单元 定义表格的页眉 定义表格的主体 定义表格的页脚 定义表格列的分组 定义表格列的分组 ​ th标题行单元格，加粗居中 caption 表格标题(作为table的第一个子元素) 行分组 thead表头 tbody表体 tfoot表尾 ​ thead&gt;tr&gt;th tbody&gt;tr&gt;td tfoot&gt;tr&gt;td 书写顺序：thead、tfoot、tbody，这样子保证在数据加载完毕前，先呈现表头跟表尾。 **如果要使用 thead、tfoot 以及 tbody 元素，就必须使用全部的元素。(如果没有表尾，就省略tfoot)** 列分组colgroup[span表示每个列分组占据的列数]1&lt;colgroup span=&quot;2&quot; align=&quot;left&quot;&gt;&lt;/colgroup&gt; 表格的html属性1）colspan=”value” 合并列2）rowspan=“value” 合并行 [rules 添加分隔线]:cols列分隔线 rows行分隔线 all 行与行、列与列都存在分隔线 none没有 groups组分隔线 [align] 整个表格在其父元素的水平对齐方式 表格的css属性1.(table)border-spacing 单元格与单元格之间的间距,不可取负值2.(table)border-collapse 合并单元格边框 属性值：separate默认分离 collapse合并3.(td)empty-cells 无内容时单元格边框的设置 属性值：show默认出现 hide隐藏4.(caption)caption-side：top/right/bottom/left * left,right位置只有火狐识别]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用案例]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F%E5%B8%B8%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[*自适应布局宽度自适应： display:inline-block; 1234567891011 .market_b&#123;width: 1000px;height: 300px;border:1px solid #ccc;font-size:0;text-align:center;&#125; .market_b0&#123;display:inline-block;width: 210px;height: 300px;background: red;margin-right:39px;&#125; .last&#123;margin-right:0;&#125; &lt;body&gt; &lt;div class=&quot;market_b&quot;&gt; &lt;div class=&quot;market_b0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;market_b0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;market_b0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;market_b0 last&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 一、宽高自适应​ （一）宽度自适应 当块级元素的宽度设置成100%，或者不设置，宽度默认都是占父级元素的100%。 经验：当父元素脱离了标准流，可以由子元素撑开它的宽度。 1.自适应布局 元素的宽高自适应窗口或者子元素的大小，从而实现同一套页面适应不同的窗口、分辨率及设备。（！！！） 2.响应式布局（一般都是用于较为简单的页面） 响应不同的屏幕大小或者设备大小，对同一套页面的部分布局进行修改，但大体保持一致。 二、父元素的高度由子元素撑开 （高度自适应）​​ 1. 最小高度 min-height * 当内容高度小于最小高度，按最小高度显示； * 当内容高度大于最小高度，按内容高度显示。 应用场景：内容不确定，无法较好地控制父元素高度 盒模型 1.盒模型=内容content+内填充padding+边框border+外间距margin 2.width、height 不是指盒子的大小，而是内容contnt的大小 做页面的时候，一开始测量的是盒子的大小，但我们会直接设置成width、height。若之后才发现需要 ​ 添加padding、border,盒子会被撑大。为了保证盒子大小不变，width、height需要减去对应的值. 盒子在浏览器可视区域居中1.定位 {position:fixd;left:50%;top:50%; margin-left,top: - 自身高度宽度一半} 2.利用行内元素中线对齐 三个条件： 1：必须给容器（父元素）加上text-align:center; 2:必须给当前元素转成行内块元素（display:inline-block;）再给当前元素加上vertical-align:middle; 3：在当前元素的后面（没有回车）加上同级元素span;并对span进行,或者加个div（尺子） ​ {vertical-align:middle;width:0;height:100%;display:inline-block} 高度塌陷高度塌陷:当子元素都浮动了，父元素会没有子元素撑开高度。 解决办法： （1）给父元素加overflow:hidden; 缺点:若存在内容溢出，会被裁剪掉。 （2）给父元素添加最后一个子元素（块级){height:0;clear:both;overflow:hidden;} 缺点：会产生很多多余的标签 （3）伪元素清除法， 12345678.clearfix::after&#123; content:&quot;&quot;; display:block; height:0; clear:both; overflow:hidden; visibility: hidden; &#125; 一般我们用的时候,我们只需要将类名.clearfix添加到父元素上即可 margin塌陷：​ 父元素与第一个子元素存在上间距，若给第一个子元素加margin-top，会错误地渲染成父元素的margin-top。 解决办法： （1）子元素或者父元素浮动 （2）给父元素加overflow:hidden; （3）给父元素加border-top （4）将子元素的margin-top当作父元素的padding-top]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百分比、rem布局]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F15.%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80%E3%80%81rem%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、移动端页面布局1、弹性布局（100%布局）——拉勾网、天猫首页 px好处：充分发挥大手机的优势——显示内容越多.缺点：屏幕过大，间距过大，比例失调。 特点： 顶部与底部的bar不管分辨率怎么变，它的高度和位置都不变； 中间每条招聘信息不管分辨率怎么变，招聘公司的图标等信息都位于条目的左边，薪资都位于右边。 2、等比缩放布局（rem布局）——网易、淘宝首页 尽量保证不同设备显示效果一致 &lt;script type=&quot;text/javascript&quot;&gt; // 把尺寸放大N倍（N是window.devicePixelRatio） var wd = document.documentElement.clientWidthwindow.devicePixelRatio/10; //物理像素设备像素比=真实像素 document.getElementsByTagName(“html”)[0].style.fontSize = wd + “px”; // 把屏幕的倍率缩小到N分之一（N是window.devicePixelRatio） var scale = 1/window.devicePixelRatio; var mstr = ‘initial-scale=’+ scale +’, maximum-scale=’+ scale +’, minimum-scale=’+ scale +’, user-scalable=no’; document.getElementById(“vp”).content = mstr;&lt;/script&gt; 640px iphone5 px=根部字体大小=&gt;rem * 不同设备的根部字体大小 ==&gt;不同设备的具体px 视口(viewport)设置： 在html上根据不同分辨率设置不同font-size，通过js计算出来 页面里除了font-size之外的其它css尺寸都使用了rem作为单位 正文的font-size需要额外的媒介查询，并且不使用rem devicePixelRatio设备像素比 真实像素640/物理像素320(固定)视网膜屏幕 //1/4 5052/1263=4 动态设置viewport的scale，淘宝触屏版首页布局的前提是viewport的scale根据devicePixelRatio动态设置：在devicePixelRatio为1的时候，scale为1；在devicePixelRatio为2的时候，scale为0.5；在devicePixelRatio为3的时候，scale为0.3333 1.获取不同手机的设备像素比 22.求出对应的scale的值，给meta标签（js） 640px 动态计算html的font-size：font-size = deviceWidth / 10 布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10 每个元素的font-size可能需要额外的媒介查询，并且font-size不使用rem //1.百分比布局（量到多少写多少，js代码删掉前两句，记得meta加id）//2.复制一份百分比布局文件，在复制的文件夹上面改成rem布局（js代码。设计稿640px，说明你在iphone5上开发，插件px-rem：64；设计稿750px，说明在iphone6开发，px-rem75）//3.rem概念理解:以根部字体大小为基准。//每个元素的font-size可能需要额外的媒介查询]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F11.css%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、选择器（一）基本选择器 标签（元素）选择器：通过标签名获取元素 类选择器：通过.类名获取元素 id选择器：通过#id名获取元素 通配符选择器：通过*获取到页面中所有元素 群组选择器E1,E2：通过逗号同时获取到多个选择器，即获取E1和E2，以此类推。 (二）层次选择器 后代选择器E1 E2:表示获取到的E2元素是E1元素的后代 子代选择器E1&gt;E2:表示获取到的E2元素是E1元素的子代 相邻兄弟选择器 E1+E2:表示获取的E2元素紧跟在E1元素的后面 兄弟选择器E1~E2:表示获取E1后面的所有E2元素 (三) 动态伪类选择器 :link 锚链接被访问前添加的样式 :visited 锚链接被访问后添加的样式 :hover 鼠标悬停在任意元素上添加的样式 :active 鼠标点击任意元素时添加的样式 :focus 表单元素被聚焦时添加的样式 (四)目标伪类选择器URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element) ​ E:target 获取到E元素里面被作为当前目标的元素 (五)ui状态伪类选择器 :enabled 可用的表单元素添加样式 :disabled 可用的表单元素添加样式 :checked 选中的表单选框添加样式 (六)结构伪类选择器 选择器 5555555555555555555 描述 E:first-child 获取到其父元素的第一个子元素，且要满足为E元素 E:last-child 获取到其父元素的最后一个子元素，且要满足为E元素 E:nth-child(n) 获取到其父元素的第n个子元素，且要满足为E元素。从1开始计数。 E:nth-last-child(n) 获取到其父元素的倒数第n个子元素，且要满足为E元素。从1开始计数。 * n的取值： 具体数值 odd（2n-1）第奇数个孩子 even（2n）第偶数个孩子 -n +a 获取到父元素第一个到第a个孩子 E:first-of-type 获取到其父元素的第一个E类型的子元素 E:last-of-type 获取到其父元素的最后一个E类型的子元素 E:nth-of-type(n) 获取到其父元素的第n个E类型的子元素 E:nth-last-of-type(n) 获取到其父元素的倒数第n个E类型的子元素 E:empty 空文本的E元素（不能有空格）添加样式 E:only-child 获取到其父元素唯一的一个子元素,且要满足为E元素 E:only-of-type 获取到父元素的唯一一个E类型的孩子 :first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。 :first-of-type 匹配的是该类型的第一个，类型是指什么呢，就是冒号前面匹配到的东西，比如 p:first-of-type，就是指所有p元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了，当然这些元素的范围都是属于同一级的，也就是同辈的。 (七)否定伪类选择器​ F:not(E) 除了E条件以外的所有F元素 (八)伪元素选择器​ 1.E::before{content:””} 给E元素添加第一个子元素（行内元素） 2.E::after{content:””} 给E元素添加最后一个子元素 3.E::first-letter 给E元素的第一个文本添加样式 ​ 4.E::first-line 给E元素的第行文本添加样式 5.E::selection E元素的内容被选中时添加样式 兼容火狐::-moz-selection (九) 属性选择器​ 1. E[attr] 拥有该attr属性的E元素被获取到 2. E[attr=&quot;val&quot;] 拥有该attr属性，且属性值等于val值的E元素被获取到 3. E[attr*=&quot;val&quot;] 拥有该attr属性，且属性值包含val值的E元素被获取到 4. E[attr^=&quot;val&quot;] 拥有该attr属性，且属性值以val值开头的E元素被获取到 5. E[attr$=&quot;val&quot;] 拥有该attr属性，且属性值以val值结尾的E元素被获取到 (十) 语言伪类选择器 q:lang(no){quotes:””””;}​ * q[lang=”no”]在内容两侧会生成引号，若想改变符号，通过如上的语言伪类选择器 二、文本属性1.文本阴影​ text-shadow:x-offset y-offset blur color[,…]; * x-offset 水平偏移，往右为正 * y-offset 垂直偏移，往下为正 * blur 模糊区域，不能取负值 2.文本溢出 text-overflow​ * 属性值： clip默认不处理 ellipsis 以省略号的形式出现 * 配合三个属性使用：width、white-space:nowrap、overflow:hidden 3.单词换行 word-wrap:break-word;4.自定义字体 @font-face{font-family起名字;src:url(“字体路径”)}5.字体图标使用服务端字体矢量图 http://www.iconfont.cn 打开链接选择图片下载后打开CSS文件复制按以下方法使用 12345678910111213141516171819&lt;style type=&quot;text/css&quot;&gt; @font-face &#123;font-family: &quot;lemon&quot;; src: url(&apos;../iconfont/iconfont.eot?t=1475997645&apos;); /* IE9*/ src: url(&apos;../iconfont/iconfont.eot?t=1475997645#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;../iconfont/iconfont.woff?t=1475997645&apos;) format(&apos;woff&apos;), /* chrome, firefox */ url(&apos;../iconfont/iconfont.ttf?t=1475997645&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;../iconfont/iconfont.svg?t=1475997645#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */ &#125; .icon &#123; font-family:&quot;lemon&quot; !important; font-style:normal; font-size:100px; &#125; .fangzi:before &#123; content: &quot;\e667&quot;; &#125; .xiaoche:before &#123; content: &quot;\e668&quot;; &#125; .meinv:before &#123; content: &quot;\e66a&quot;; &#125; &lt;/style&gt;&lt;div&gt;我有一个大&lt;i class=&quot;icon fangzi&quot;&gt;&lt;/i&gt;,我有一辆大&lt;i class=&quot;icon xiaoche&quot;&gt;&lt;/i&gt;,我还有一个&lt;i class=&quot;icon meinv&quot;&gt;&lt;/i&gt;&lt;/div&gt; 三、背景属性1.背景图片的尺寸 background-size​ 取值： * 数值: 水平 垂直; 绝大部分情况会出现扭曲变形。 * cover 背景图片完全覆盖容器,绝大部分会出现背景图丢失一部分的情况 * contain 容器完全包含背景图片,绝大部分会出现容器留白现象 * 等比缩放：cover、contain * 应用：一般轮播图采用背景图片｛background-size:cover;background-position:center center;｝ 2.背景图片的定位区域 background-origin​ 属性值： * 默认从padding开始摆放 padding-box * 从content开始 content-box（说明此时background-position:0 0;在content内容的左上角。） * border-box 3.背景图片的裁剪（最终显示区域）background-clip​ * border-box 从边框部分开始裁剪 * padding-box 从padding部分开始裁剪 * content-box 从content部分开始裁剪]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边框属性、渐变、过渡、2d变换]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F12.%E8%BE%B9%E6%A1%86%E5%B1%9E%E6%80%A7%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%812d%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、边框属性1.边框阴影box-shadow: x-offset y-offset blur spread color inset[,…];​ * x-offset 水平偏移，往右为正值 * y-offset 垂直偏移，往下为正值 * blur 模糊区域 * spread 扩展区域 * color 颜色 * inset 往元素内部移动。若是不设置，则往元素外部添加边框阴影 2.边框图片 border-image​ * 边框图片引入border-image-source:url() * 边框图片的裁剪 border-image-slice 遵循上右下左原则(不带单位) * 边框图片的宽度 border-image-width 若省略该值，默认就是边框宽度 * 边框图片的重复 border-image-repeat *属性值：stretch默认拉伸 repeat重复 round压缩重复 * 边框图片向外延伸 border-image-outset 不能取负数 3.边框圆角 border-radius​ 某个角的边框圆角：border-垂直方位-水平方位-radius:水平半径 垂直半径; border-radius:水平半径/垂直半径; 水平或垂直半径遵循（从左上角开始）顺时针原则,缺省的值找对角 二.渐变（一）线性渐变 linear-gradient​ 1.gradient(linear,起点坐标,终点坐标,from(color),to(color)) * 坐标写法：水平坐标 垂直坐标; (只能用百分比) 2.gradient(linear,起点坐标,终点坐标,color-stop(渐变开始的位置,color)[,...]) * 渐变开始的位置取值为0-1 3.linear-gradient(方向||角度,颜色 渐变开始的位置) * 方向：top bottom left right * 角度单位:deg * 渐变开始的位置:0-100% * 老版本（加前缀的写法）+新版本 = 90deg (二)径向渐变radial-gradient​ 1. radial-gradient(圆心，颜色 开始渐变的位置[,….]) 2. radial-gradient(圆心,size||shape,颜色 开始渐变的位置[,....]) * size大小： closest-side：最近边； farthest-side：最远边； closest-corner：最近角； farthest-corner：最远角（默认值） * shape形状： ellipse椭圆形(默认)，circle表示圆形。 (三) 重复渐变 repeating-linear（radial）-gradient 用法同上浏览器的私有前缀 浏览器 内核 私有前缀 chrome、safari Webkit -webkit- opera Presto -o- ie Trident -ms- firefox Gecko -moz- chrome、opera blink 过渡 transition​ 需要过渡的属性 transition-property： 过渡的时间 transition-duration： 过渡的形式 transition-timing-function： *linear 匀速 ease慢速进入慢速离开 *ease-in 慢速进入 ease-out慢速离开 *ease-in-out慢速进入慢速离开 过渡的延迟 transition-delay： **总属性 transition: 1 2 3 4;(1跟2不可以省略) ** 多个属性同时过渡可以用**all**。 四.2d变换transform ==&gt;这是一种状态​ 写变换时，先写移动，再写旋转。 1. 移动变换 transform:translate(水平方向(右),垂直方向(下))​ 改变某个方向 transform:translateX(水平方向) transform:translateY(垂直方向) *取值取百分比的话，指的是参考自己的宽高 transform:translate(100px,20px): 2.缩放变换transform:scale(x,y)​ * 取值为缩放比（倍数），基准点为元素中心。 * transform:scaleX(x) transform:scaleY(y) 3.旋转变换 transform:rotate(deg)​ *顺时针旋转为正值，基准点在元素中心如：transform:rotate(30deg): 4.扭曲transform:skew(x轴旋转的角度，y轴旋转的角度)​ *transform:skewX(x轴旋转的角度) ​ transform:skew(30deg,10deg): 5.改变元素变换的基准点 transform-origin​ 取值：数值 百分比 方位]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弹性盒布局、媒体查询]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F14.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E3%80%81%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[一、弹性盒布局（一）设置在父元素上1.display:flex; 将父元素设置成弹性盒，那么里面的子元素会在主轴方向上默认不换行摆放；侧轴方向的大小不设置的话，就会在当前行默认被拉伸2.flex-direction 设置主轴方向​ 属性值： row 从左往右 row-reverse 从右往左 column 从上到下 column-reverse 从下到上 3.flex-wrap 伸缩换行​ nowrap默认不换行 wrap 换行 *wrap-reverse 换行反向 主轴是水平时，上下反向，主轴垂直时，左右反向； 4.flex-flow:flex-direction || flex-wrap;5.justify-content 设置子项目在主轴方向的对齐方式​ * flex-start 默认在主轴的起点位置靠齐摆放 * flex-end 在主轴的终点位置靠齐摆放 * center 在主轴的中间位置靠齐摆放 * space-between 将主轴方向空白区域平分在子项目之间 ​ *space-around 将主轴方向空白区域环绕在子项目两侧 6.align-items 设置子项目在（当前行）侧轴方向的对齐方式​ * stretch 若不设置子项目在侧轴方向的大小，会被默认拉伸 * flex-start 若设置子项目在侧轴方向的大小，会被默认摆放在侧轴的起点位置 * flex-end 摆放在侧轴的终点位置 * center 摆放在侧轴的中间位置 * baseline 子项目以基线对齐 7.align-content 控制子项目在侧轴方向的对齐方式（有换行情况下用此属性，单行用align-self）​ 属性值等同于 justify-content flex-start：各行向伸缩容器的起点位置堆叠； flex-end：各行向伸缩容器的结束位置堆叠； center：各行向伸缩容器的中间位置堆叠； space-between：各行在伸缩容器中平均分布； space-around：各行在伸缩容器中平均分布，两端保留一半的空间； stretch：各行将伸展以占用额外空间。 （二）设置在子元素上1.flex 设置子项目在主轴方向的比份2.align-self 设置单个子项目在（当前行）侧轴方向的对齐方式​ 取值同align-items flex-start：伸缩项目在侧轴起点边的外边距 紧靠住 该行在侧轴起始边；(侧轴的起点位置摆放) flex-end：伸缩项目在侧轴终点边的外边距 紧靠住 该行在侧轴终点边；（侧轴的终点位置摆放） center：伸缩项目的外边距盒 在该行的侧轴上居中放置；（侧轴居中摆放） baseline：伸缩项目根据伸缩项目的基线对齐；（侧轴方向子项目以基线对齐） stretch：伸缩项目拉伸填充整个伸缩容器。（伸缩项目不给高度时，默认会被拉伸。） 3.order 设置子项目的显示顺序​ * 设置了order会放在没设置order子项目后面 * 都设置了order,数字越小越靠前 二、多列布局1.column-width 每列的最小宽度2.column-count 最多的列数3.column-gap 列间距4.column-rule 列边框5.column-span 跨列​ *none不跨列 all跨所有列 ​ column-width:300px; column-count:4; column-gap:30px; column-rule:4px solid #ccc; 三.媒体查询1. 用法 @media screen and (条件){选择器{声明}}2. min-width 当页面宽度大于最小宽度，生效。（从小写到大）​ max-width 当页面宽度大于最小宽度，生效。（从大写到小） min-device-width 【设备宽度】 3.link[media=&quot;screen and (条件)&quot;][href]1.自适应布局​ 元素的宽高自适应窗口或者子元素的大小，从而实现同一套页面适应不同的窗口、分辨率及设备。（！！！） 2.响应式布局（一般都是用于较为简单的页面） 响应不同的屏幕大小或者设备大小，对同一套页面的部分布局进行修改，但大体保持一致。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒模型、3d变换、关键帧动画]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F13.%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%813d%E5%8F%98%E6%8D%A2%E3%80%81%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[(一)颜色模式（属性值：可以控制某个属性）​ 1.rgba(red0-255,green0-255,blue0-255,alpha不透明度0-1) 2.hsla(色调0-360,饱和度0-100%,亮度0-100%,alpha0-1) 3.transparent 完全透明 (三角形) (二)盒模型​ 盒模型由content内容、padding内填充、border边框、margin外间距组成。 1.标准盒模型：width、height指的是content的宽高 2.怪异盒模型: width、height指的是content+padding+border的宽高 box-sizing 规定盒模型​ *属性值：content-box（默认） border-box设置成怪异盒模型 三、3d变换1.transform:translate3d(x,y,z); 移动变换​ transform:translateZ(z),其他方向同理 2.transform-style:preserve-3d; 保持3d变换（父元素上）​ *flat平面（默认） 3.设置观察的距离，景深perspective(父元素上)4.旋转变换 ​ 左手定律：大拇指指向轴的正方向，其他手指卷曲的方向为旋转的正方向 transform:rotate3d(x,y,z,deg) x、y、z取值为0（不旋转）或1（旋转）​ transform:rotateX(deg); 立方体1.先把所有的面都定位在盒子的同一位置 2.设置3d变换，将每个面移动到指定位置 3.设置景深 4.transform-origin 变换的基准点 5.perspective-origin 观察的基准点 3D导航1.导航的套路2.两个a一开始先放在li同一位置再进行移动旋转变换3.hover之后整个li翻转即可。过渡及延迟。 四、关键帧动画（一）自定义动画​ （1）通过@keyframes指定动画序列；@keyframes name{} （2）通过百分比将动画序列分割成多个节点； （3）在各节点中分别定义各属性 （4）通过animation将动画应用于相应元素； @keyframes name{ 百分比{ 声明 } } (二) animation属性1. animation-name 动画名字2. animation-duration 动画播放时间3. animation-timing-function 动画播放的形式​ linear匀速 ease… steps(n) ​ steps(n)、steps(n,end)每一帧都分成n步，每一步都以前一步的状态填充时间段 steps(n,start)每一帧都分成n步，每一步都以后一步的状态填充时间段 4. animation-delay 动画播放的延迟5. animation-iteration-count 动画播放的次数 infinite无限次播放6. animation-direction 动画播放的方向​ 属性值：normal正向播放 reverse反向播放 alternate 交替播放 alternate-reverse反向交替播放 animation-play-state: paused; 动画暂停7. animation-fill-mode 动画完成后的状态 forwards保持最后的状态​ animation: 1 2 3 4 5 6 7;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5新语义标签]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F10.h5%E6%96%B0%E8%AF%AD%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[doctype html声明文档类型 &lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; HTML5新标签 header 头部标签，一般都是包含标题标签或者导航条。header、footer不互相嵌套。 hgroup 对标题进行组合 footer 一般都是版权信息、作者简介。。。 nav 导航条 main 主要内容，一个页面就用一次，外层结构。 article 文章、独立的内容块。article可以嵌套自己。 section 章节、区块，专题性的内容 aside 侧边栏，非正文的内容 figure对图片跟文字进行组合&gt;figcaption 对figure的内容进行说明 time时间 [datetime 规定具体时间] details细节[open默认显示细节]&gt;summary 对细节的总结 mark 定义带有记号的文本 progress 定义进度条 progress [max最大值 ]【value当前值】 meter 度量尺 min最小值 low较低的值 value当前值 optimum较佳的值，当取值小于较低的值说明越低越好，反之同理 ruby注释标签 &gt; rt对内容的注释信息 引入视频的方式：video[src] 或者 video&gt;source[src] (1)[controls]控制条 (2)[autoplay]自动播放 (3)[loop]循环播放 (4)[width] or [height] (5)[poster]等待加载时的图片 支持格式：ogg、mp4、webM]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单、表格]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F09.%E9%AB%98%E7%BA%A7%E8%A1%A8%E5%8D%95%E3%80%81%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[表单新增属性1、表单字段集： &lt;fieldset&gt;&lt;/fieldset&gt; 对表单中的元素进行分组 2、字段集标题 fieldset&gt;legend字段集标题（必须作为表单字段集的第一个子元素）[align控制它在fieldset的某一个位置] 3、label提示信息标签 ​ [for] 关联到id名所在的表单元素 若用于单选框或多选框，一般都是直接将文字及表单元素包含在label里面。 4、type属性值 ​ 1.input[type=”file”]上传文件 [multiple多选] 2. input[type=&quot;image&quot;] 图像提交按钮 [src图片路径] 表格新增属性表格布局元素表格 描述 定义表格 定义表格标题 定义表格列标题 定义表格的行 定义表格单元 定义表格的页眉 定义表格的主体 定义表格的页脚 定义表格列的分组 定义表格列的分组 th标题行单元格，加粗居中 caption 表格标题(作为table的第一个子元素) 行分组 thead表头 tbody表体 tfoot表尾 ​ thead&gt;tr&gt;th tbody&gt;tr&gt;td tfoot&gt;tr&gt;td 书写顺序：thead、tfoot、tbody，这样子保证在数据加载完毕前，先呈现表头跟表尾。 如果要使用 thead、tfoot 以及 tbody 元素，就必须使用全部的元素。(如果没有表尾，就省略tfoot) 列分组colgroup[span表示每个列分组占据的列数] table的html属性1）colspan=”value” 合并列2）rowspan=“value” 合并行 [rules 添加分隔线]:cols列分隔线 rows行分隔线 all 行与行、列与列都存在分隔线 none没有 groups组分隔线 [align] 整个表格在其父元素的水平对齐方式 表格的css属性1.(table)border-spacing 单元格与单元格之间的间距,不可取负值2.(table)border-collapse 合并单元格边框 属性值：separate默认分离 collapse合并3.(td)empty-cells 无内容时单元格边框的设置 属性值：show默认出现 hide隐藏4.(caption)caption-side：top/right/bottom/left * left,right位置只有火狐识别 html5新表单html表单标签 1.拥有输入功能的下拉列表 input[list]+datalist[id] 2.输出output，配合着form[oninput]使用。 表单类型type1.color 拾色器2.email 邮箱（正则验证）3.number 数字4.tel 电话号码5.url 网址（正则验证）6.search 搜索7.range 特定范围内的数值选择器，min最小值、max最大值、step( 步数 )、value当前值 8.date 用于应该包含日期的输入字段。 日期选择器 表单html属性1.autofocus 自动聚焦2.placeholder 占位符3.required 必填项4.pattern 正则]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容、bfc]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F08.%E5%85%BC%E5%AE%B9%E3%80%81bfc%2F</url>
    <content type="text"><![CDATA[常用浏览器1.主流浏览器：Internet Explorer、 Safari、Mozilla Firefox、 Google Chrome、Opera 2.最早浏览器：网景领航者 五大浏览器内核 内核 浏览器* Trident: IE、Maxthon(遨游)、腾讯 、Theworld世界之窗、360浏览器 只能应用于windows，不开源 Gecko： Mozilla Firefox (火狐)是开源的,它的最大优势是跨平台 Webkit : 代表作品Safari、Chrome ， 是一个开源项目。 Presto : Opera（欧朋）公认的渲染速度最快的引擎 Blink 由Google和Opera Software开发的浏览器排版引擎，2013年4月发布 CSS Bug、CSS Hack和Filter1.CSS Bug CSS样式在各浏览器中解析不一致的情况 在浏览器中不能正确显示的问题 2.CSS Hack 兼容CSS在不同浏览器中正确显示的技巧方法 补丁 3.Filter 表示过滤器 Filter是一种用来过滤不同浏览器的Hack类型 IE兼容性问题(1).图片有边框（ie8-） 解决办法： img{border:0 none;} (2)div&gt;img,img下方会存在间隙 描述：在div中插入图片时，图片会将div下方撑大大约三像素。​ 解决办法：​ img{display:block;}​ div{font-size:0;} (3)ie6以下，会错误地将浮动元素的浮向边margin加倍显示。​ 解决： ｛display:inline;｝ (4) ie7-，存在默认高度16px。​ 解决办法:​ {font-size:0;}​ {overflow:hidden;} (5)表单元素行高不一致问题（基线对齐的问题）​ 解决办法：​ {vertical-align: middle;}​ {float:left;} (6)表单元素样式在各浏览器渲染效果不一​ 解决办法：给input清除默认样式{display:block;border: 0 none;padding:0;}， ​ 给input外层嵌套标签，设置input需要的样式 (7)浮动元素50%+50%&gt;100% （ie6-）​ 解决办法： 若两个元素都左浮动，给元素添加{clear:right;}清除反向浮动 (8)ie8及以下浏览器才支持cursor:hand; （鼠标指针）​ 解决办法： ｛cursor:pointer;｝ (9)透明度​ opactity:val; val取值为0-1，越大越不透明。​ filter:alpha(opacity=val) val取值为0-100，整十数，越大越不透明。 (10).margin塌陷：​ 父元素与第一个子元素存在上间距，若给第一个子元素加margin-top，会错误地渲染成父元素的margin-top。​ 解决办法：​ （1）子元素或者父元素浮动​ （2）给父元素加overflow:hidden;​ （3）给父元素加border-top​ （4）将子元素的margin-top当作父元素的padding-top (11).margin合并当两个块级元素竖直排列时，上一个元素的margin-bottom与下一个元素的margin-top会发生合并，它们之间的margin取两者之间较大的值。 (12).ie8只支持单冒号写法(13).总属性（border、background）的多个属性值之间要用空格隔开(14).ul&gt;li(float)&gt;a(宽高)（float–&gt;ie6）​ ul&gt;li(float)&gt;a(高度)（float–&gt;ie6）&gt;span(padding)(假如span也设置成了display:block;也要float)(15).页面最外层设置最小宽度（版心容器宽度）兼容ie6：_width:expression(document.body.clientWidth &lt; 1190 ? “1190px” : “auto”); BFCBFC(Block formatting context)直译为“块级格式化上下文” 独立的渲染区域，只有Block-level box（块）参与，规定内部如何布局，与外部毫不相干。 BFC的布局规则1、内部的Box会在垂直方向，一个接一个地放置。 2、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻块会发生margin重叠。 3、每个元素的margin box的左边， 与包含块border box的左边相接触 盒模型=content+padding+border+margin。Width指的是content的宽，height=content的高。 4、BFC的区域不会与float box重叠。(应用场景：清除浮动的第二种方式、自适应两栏布局) 5、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 (应用场景：防止margin合并，对独立的bfc里面的子元素操作不会影响到外部元素) 6、计算BFC的高度时，里面的浮动元素也参与计算(应用场景:清除浮动的第一种方式) 触发BFC根元素html float属性不为none position为absolute（有定位的父元素或者html）或fixed（可视窗口） display为inline-block, table-cell, table-caption, flex, inline-flex（css3） overflow不为visible(overflow:hidden;) 应用：自适应两栏布局方法一： 左边定宽加浮动，右边margin-left留出左边的宽（因为浮动的元素会脱离标准流，第二个元素会跑上来占据第一个元素的位置，而块级元素的宽度刚好是100%，当设置了margin-left为第一个元素的宽度，它的宽度会自动调整为页面剩余部分的宽度）​​ .dv1{width: 200px;height:600px;background-color: red;float: left;}​ .dv2{margin-left:200px;height: 600px;background: blue;}*/ 方法二：​ 左边定宽加浮动，右边不定宽加overflow:hidden​ 原理：bfc的区域不会与浮动块重叠 防止margin重叠属于同一个bfc的两个相邻块会发生margin重叠 给第二个p添加一个盒子并添加overflow:hidden; 清除内部浮动计算BFC的高度时，里面的浮动元素也参与计算]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素类型]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F06.%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、元素类型(一) 块级元素特点： (1)默认占一整行。 即使设置了宽度，右边多余的部分也会用margin进行填充。 (2) 可以设置宽高 (3) 块级元素可以嵌套所有的行内元素以及部分的块级元素 错误： p&gt;p p&gt;div (4)大部分的块级元素都拥有默认的margin或padding，除了div、li… 应用场景： 怎么实现块级元素在父容器里水平居中？ 给该块级元素｛margin:0 auto;｝ 总结：body、h1-h6、p、列表ul&gt;li ol&gt;li dl&gt;dt+dd、form (二) 行内元素特点：（1）一行显示多个 （2）宽高由内容决定，不能设置宽高 （3）行内元素也遵循盒模型，但是设置上下的padding或margin无效 应用：行内元素如何实现在容器中水平居中呢？ 给其父容器添加text-align:center; 总结：加粗、倾斜、a、span、img、input、textarea、label 二.元素类型的转换display inline 转换成行内元素 block 转换成块级元素 list-item 转换成列表项 (li) inline-block 转换成行内块级元素 行内块级元素 行内可置换元素（由元素标签名及属性，决定最终的显示效果） （1）一行显示多个 （2）可以设置宽高 **img input textarea** 5.none 隐藏元素，不占位置 行内块级元素与浮动的区别:​ 1.两个行内块级元素之间存在空格，会在页面中存在一条缝隙。 解决办法：（1）将元素之间的空格删除 （2）给其父元素设置｛font-size:0;｝ 2.行内元素都存在垂直方向基线对齐的问题 解决办法: 设置vertical-align 属性设置元素的垂直对齐方式 baseline 默认。元素放置在父元素的基线上。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 top 把元素的顶端与行中最高元素的顶端对齐 text-top 把元素的顶端与父元素字体的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 把元素的顶端与行中最低的元素的顶端对齐。 text-bottom 把元素的底端与父元素字体的底端对齐。 length % 使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。 inherit 规定应该从父元素继承 vertical-align 属性的值。 导航条做法 ul{width height border padding} li{float;margin;} a{display:block;width;height;border;文本居中；文字大小颜色} li:hover 注意事项：若父元素与第一个子元素存在上间距，最好给父元素加padding-top。若子元素或父元素浮动了，则可以给子元素添加margin-top。 设置一个元素在一个容器中垂直居中1.定位 {position:fixd;left:50%;top:50%; margin: - 自身高度宽度一半} 2.利用行内元素中线对齐 三个条件： 1：必须给容器（父元素）加上text-align:center; 2:必须给当前元素转成行内块元素（display:inline-block;）再给当前元素加上vertical-align:middle; 3：在当前元素的后面（没有回车）加上同级元素span;并对span进行 ​ {vertical-align:middle;width:0;height:100%;display:inline-block}]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精灵图，滑动门，宽高自适应,伪元素]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F07.%E7%B2%BE%E7%81%B5%E5%9B%BE%EF%BC%8C%E6%BB%91%E5%8A%A8%E9%97%A8%EF%BC%8C%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94%2C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、精灵图（图片整合）图片整合的优势：1.通过图片整合来减少对服务器的请求次数，从而提高页面的加载速度。 ​ 2.通过整合图片来减小图片的体积。 原理：将导航背景图片、按钮背景图片等有规则的合并成一张背景图，即将多张图片合为一张整图，然后用 background-position”来实现背景图片的定位技术。 二、滑动门滑动门：通过多张背景图片进行层叠，从而在视觉上达到同一张图片的效果 a{padding-left存放左边的背景图片}&gt;span{padding-right以实现文本居中} 三、自适应布局一、宽高自适应 （一）宽度自适应 当块级元素的宽度设置成100%，或者不设置，宽度默认都是占父级元素的100%。 经验：当父元素脱离了标准流，可以由子元素撑开它的宽度。 二、父元素的高度由子元素撑开 （高度自适应） ​ 1. 最小高度 min-height * 当内容高度小于最小高度，按最小高度显示； * 当内容高度大于最小高度，按内容高度显示。 应用场景：内容不确定，无法较好地控制父元素高度 兼容ie6： ie6中，height代表的是最小高度。若想这个属性只让ie6识别，通过过滤器_height。 2.高度塌陷:当子元素都浮动了，父元素会没有子元素撑开高度。 解决办法： （1）给父元素加overflow:hidden; 缺点:若存在内容溢出，会被裁剪掉。 （2）给父元素添加最后一个子元素（块级){height:0;clear:both;overflow:hidden;} 缺点：会产生很多多余的标签 （3）伪元素清除法， 12345678.clearfix::after&#123; content:&quot;&quot;; display:block; height:0; clear:both; overflow:hidden; visibility: hidden; &#125; ​ 一般我们用的时候,我们只需要将类名.clearfix添加到父元素上即可。 四、伪元素 1.E::before 给E元素添加第一个子元素,content:””不能省略 元素类型默认为行内元素 content:url();添加图片 2.E::after 给E元素添加最后一个子元素 E::first-letter 给E元素的第一个文本添加样式 E::first-line 给E元素的第行文本添加样式]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定位]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F05.%E5%AE%9A%E4%BD%8D%2B%E9%94%9A%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、定位 position position:static; 静态定位(默认标准流定位)无法设置left、right、top、bottom值 position:relative; 相对定位(1)相对于自己本身所在的位置进行移动定位 (2)配合left、right、top、bottom进行移动定位。**相对于自己的某条边往元素中心移动为正值**。 (3)相对定位的元素**不脱离标准流**。（灵魂出窍） position:absolute; 绝对定位(1)绝对定位的元素是相对于html或者最近的有定位的父元素 进行定位 (2)配合left、right、top、bottom进行移动定位。**相对于包含块的某条边往包含块中心移动为正值** (3)绝对定位的元素会**脱离标准流** 如何实现元素在容器中居中？**子绝父相**（父元素可以是其他定位），子元素{top:50%;margin-top:-自己高度的一般;left:50%;margin-left:-自己宽度的一半。} position:fixed ; 固定定位(1) 相对于浏览器的可视区域进行移动定位 (2) 配合left、right、top、bottom进行移动定位。**相对于浏览器可视区域的某条边往浏览器可视区域中心移动为正值** (3) 脱离标准流 二、层级 z-index1.定位&gt;浮动&gt;标准流2.z-index 只能用于有定位的元素上3.z-index 可以取负数 三、命名锚点​ a[href=”#id名”]跳转到id名所在的元素上 a[href=”页面路径#id名”]跳转到其他页面该id名所在的元素上 四、overflow 内容溢出容器时的处理方式​ 属性值：visible 默认可见 hidden隐藏 scroll 滚动条 auto判断需要出现滚动条时才出现 设置某个方向： overflow-x 水平方向 overflow-y垂直方向 规定：当某一个方向的值设置不为visible，另外一个方向会自动设置成auto]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F04.%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[(一)盒模型 1.盒模型=内容content+内填充padding+边框border+外间距margin 2.width、height 不是指盒子的大小，而是内容contnt的大小 做页面的时候，一开始测量的是盒子的大小，但我们会直接设置成width、height。若之后才发现需要 ​ 添加padding、border,盒子会被撑大。为了保证盒子大小不变，width、height需要减去对应的值. (二)padding1.padding取值：遵循上右下左原则,缺省的值找反义词的值2.padding-方位3.注意； （1）padding不可以为负值； (2) 背景会从padding的区域开始摆放，说明background-position:0 0;在padding的左上角。 (三)margin1.margin取值：遵循上右下左原则，缺省的值找反义词的值2.margin-方位3注意: margin可以取负值 (四)页面结构： 最外层 #qianfeng -每一层大盒子#id名-版心容器（专门放内容的.container） 页面链接css文件时，先链接到base.css,再单独链接到页面对应的css文件。 ​ （base.css是公共部分样式） base.css 存在的意义: 1.清除默认样式 2.添加公共样式 3.添加页面公共部分 页面.css书写页面剩余部分的样式 (五)样式1.清除默认样式2.添加公共样式 版心容器{宽度1000、背景、居中}3.书写页面样式 最外层宽度100%-每一层大容器｛宽度100%、高度背景色｝，每一层的版心容器｛高度跟随｝ 注意： 1.h1最好是用背景图片 文本用text-indent隐藏 2.列表中，li（float:left;）,每个列表项的样式给a标签加， a｛display:block;width:;height:;｝但是宽度不一致的情况下，a标签就不能设置具体宽度，由其字体个数决定width.一般此时的盒子大小应由各自内容的width+左右padding. 3.若容器内都是文本的，都添加｛line-height:;font-size:;color:;｝从有参照文本的那一段开始量. ​ 4.列表悬停改变样式的话，建议鼠标悬停在li上，改变子元素a的样式，写法li:hover a ​ 5.当父元素与子元素存在上间距，若子元素不存在浮动的情况，就给父元素加padding-top,而不要给第一个字元素加margin-top ​]]></content>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本、列表、边框、背景、浮动]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F03.%E6%96%87%E6%9C%AC%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E8%BE%B9%E6%A1%86%E3%80%81%E8%83%8C%E6%99%AF%E3%80%81%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[(一)字体属性 font1.字体大小 font-size 默认字体大小为16px 最小的字体读大小为12px 9pt=12px 12pt=16px 2.字体加粗 font-weight 属性值: normal(100-500)默认正常 bold (600-900)加粗 bolder更加粗 3.字体倾斜 font-style 属性值: normal 默认正常 italic倾斜 4.字体家族 font-family 中文字体或者多个单词组成的字体要加双引号. 多个字体家族用逗号隔开 5.字体颜色 color 属性值: 英文单词 十六进制 十六进制表示:#000000 前两个0红色,中间两个0绿,后面两个0蓝色 每一位的取值为0-9 a b c d e f (二)文本属性 text1.设置文本大小写 text-transform (转换大小写) 属性值：none默认不转换 lowercase全部小写 uppercase全部大写 capitalize首字母大写 2.文本修饰 text-decoration (一般导航删除下划线) 属性值；none默认不修饰 underline下划线 overline 上划线 line-though删除线 3.首行缩进 text-indent 单位:em 以当前字体大小为基准 可以取负值 4.字间距 letter-spacing 5.词间距 word-spacing(以空格作为分隔符) 6.文本在容器中的水平对齐方式 text-align *属性值: left默认左边 center中间 right右边 text-justify自动跳转（英文两端对齐）(只支持IE) 7、行内元素在垂直方向的对齐方式 vertical-align 属性值:baseline 默认基线对齐 middle中线对齐 英文有 顶线，中线，基线底线 一般用在图片与文字垂直居中对齐 (三)列表属性 list-style1.列表样式类型 list-style-type1 属性值:disc实心圆 circle空心圆 square方块 none去掉2.列表样式图片 list-style-image:url(“”)3.列表样式位置 list-style-position 属性值: outside 默认列表样式在li内容外面 inside在内容里面 总属性值:list-style: 1||2 3 ; (1,2选其一)可以缺省值 用的最多 list-style:none; （去除列表圆点） (四)边框属性border1.边框宽度 borber-width2.边框样式 border-style *属性值: solid 实线 dashed虚线 dotted点线 double 双线3.边框颜色 borber-color 总属性:border:1 2 3 ; 1border: 3px dotted red; 边框大小为3px红色的电线 ​ border-方位(top、bottom、left、right): 1 2 3 border-方位-分属性 1border-left: 5px solid yellow; 左边边框线为5px黄色实线 (五)背景属性background1.背景颜色 background-color2.背景图片 background-image:url(“”); 当容器尺寸大于背景图片尺寸时会重复平铺满整个容器 当容器尺寸小于背景图片尺寸时会被裁减会丢失一部分 当容器尺寸等于背景图片尺寸时刚好放下3.背景平铺 background-repeat 属性值: repeat 平铺 no-repeat不平铺 repeat-x水平方向平铺 repeat-y垂直方向平铺4.背景图片在容器中的定位 background-position: 水平方向 垂直方向; 属性值：数值（往右为正、往下为正）、方位(left \ center\ right \ top\ center \bottom) 5.背景图片的固定 background-attachment 属性值: scroll 默认滚动 fixd固定 ​ 总属性 ：background:1 2 3 4 5; 分属性要写在总属性后面 (六) 浮动float属性值：left左浮动 right:有浮动 none默认不浮动 特点： （1）浮动的元素会脱离标准流 （标准流：从左往右，从上往下） 但文本不会脱离文本流 * (2) 浮动的元素相当于行内块级元素（一行显示多个、可以设置宽高） * (3)当浮动的元素换行摆放，垂直方向的位置会参考上一个元素的最低点 (七)line-height 行高1.单行文本若想实线在容器中垂直居中，将line-height大小设成height大小。 2..单行文本若想实线在容器中垂直居中，以上。将line-height&lt;height，以下。则设成line-height&gt;height 3.同一段文本，测量line-height时，从上一行文本的最顶端到下一行文本的最顶端，就是line-height]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.CSS基本语法]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F02.CSS%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标签总结1.div 没有语义的盒子,块级元素的代表. 特点:(1) 默认宽度占据一整行 (2) 可以设置宽高 块级元素: div h1-h6 p hr form 列表元素 body 大部分的块级元素都会默认存在margin 外间距, 除了div、li、dt 2.span 没有语义的盒子,行内元素的代表. 特点:(1) 宽高由内容决定（不能设置宽高） 行内元素: 加粗(b、strong) 倾斜(i、em) 删除(s、del) img、a、input、select、textarea CSS语法css简介: (cascading style sheets )汉译层叠样式表 ​ 层叠性：给同一个元素添加相同的css属性，属性值会存在覆盖问题 (一)css语法​ 1.样式的固定书写格式: 选择器{声明} 2.声明的组成 css属性:属性值; 3.css注释 (二)css属性​ 1.width 宽度 2.height 高度 3.background-color 背景颜色 4.color 字体颜色 red blue green pink (三)三种样式表​ 1.内部样式表 head&gt;style[type=”text/css”]在style标签里面书写css样式. 作用域:当前页面 1&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; ​ 2.外部样式表: 在css文件夹新建css文件,书写样式. 需要用到外部样式表的html文件， head&gt;link[href链接路径][rel=”stylesheet”][type=”text/css”] 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; /&gt; ​ 作用域:链接到该CSS文件的所有页面 ​ 3.内联样式表、行内样式表 将style作为html属性，将声明(css属性:属性值;)作为html属性值 作用域:当前元素 优先级: ​ 三种样式表的优先级: 内联样式&gt;内部样式&gt;外部样式 内部样式与外部样式，谁写在后面，就覆盖前面的相同 元素的相同属性 (四)选择器​ 1.标签选择器、元素选择器、通过标签名获取到的元素 2.类选择器:通过. 类名(class名)获取到元素 [class=””]给元素添加类名(绰号),可以重复. 命名规则:英文开头，包含数字、下划线。-。 3.id选择器：通过#id名获取到元素 [id=””]给元素添加id名（身份正号码），不可重复。 4.通配符选择器*获取到页面上的所有元素 5.群组选择器、并集选择器 将多个基本选择器用逗号隔开， 表示都获取到 ​ 6.伪类选择器 用冒号开头 (1) a:link 锚链接被访问前出现的样式 (2) a:visited 锚链接被访问后出现的样式 (3) E:hover 鼠标悬停在E元素上出现样式 (4) E:active 鼠标点击E元素时出现样式 lv-ha 顺序固定不能乱 ​ !important用法: 123div&#123; color:red !important; &#125; ​ 选择器的优先级: !important&gt;内联样式&gt;id选择器&gt;类选择器(伪类选择器)&gt;标签选择器&gt;通配符选择器 (五)权重​ 只有作用到同一个元素上才能比较权重 0000 第一个0代表important或者行内样式 第二个0代表id选择器 # 第三个0代表类选择器 . 第四个0代表标签选择器 div 继承的权重最低为0000 12345&lt;div class=&quot;yeye&quot; id=&quot;grandpa &quot;&gt; &lt;div class=&quot;baba&quot; id=&quot;father&quot;&gt; &lt;div class=&quot;erzi&quot; id=&quot;son&quot;&gt;我是什么颜色&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ​ 0110 （没有！important或者行内样式,1个id选择器，1个类选择器，0个标签选择器） #father .erzi{ color:red; }]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html简介]]></title>
    <url>%2F2019%2F05%2F18%2FHTML%2F01.HTML%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[html简介 HTML 指的是超文本标记语言 (Hyper Text Markup Language) XHTML指可扩展超文本标记语言（标识语言）（EXtensible HyperText Markup Language）。 Web标准，W3C,WHATWG,ECMA W3C制定的结构和表现的标准W3C( World Wide Web Consortium )万维网联盟 WHATWG 浏览器厂商临时组成的组织 ECMA：欧洲电脑场商联合会，制定的行为js的标准 html基本语法​ 1. html标签 由尖括号包裹起来的整体 2. html元素 由一对双标签或者一个单标签 组成 3. html属性 属性=：“属性值”，html属性书写在标签名字后面， 用空格隔开属性或者属性值。 4. html注释 &lt;!--这是html注释，说明解析且不会呈现在页面上(不能嵌套)--&gt; 标签标题标签​ h1-h6. 直观上字体越来越小，语义上越来越轻 一级标题最好一个页面只用一次 段落标签​ p 备注：浏览器解析时，会将多个空格解析成一个空格 换行标识符​ 标识符​ &nbsp; 空格 &lt;小于号 &gt; 大于号备注空格的大小不等同于文字大小，但是空格大小受 文字大小影响 加粗标签​ b strong 倾斜标签​ i、em 备注：视觉标签b、i、s 语义标签strong、em 分割线标签​ 列表标签无序列表 ul(unordered list)&gt;li(list item 列表项) 只能嵌套 li ​ 12345&lt;ul&gt; &lt;li&gt;猪肉&lt;/li&gt; &lt;li&gt;酱油&lt;/li&gt; &lt;li&gt;青菜&lt;/li&gt; &lt;/ul&gt; 有序列表 ol （ordered list）&gt;li ​ 12345&lt;ol&gt; &lt;li&gt;睁开眼&lt;/li&gt; &lt;li&gt;看手机&lt;/li&gt; &lt;li&gt;洗漱&lt;/li&gt; &lt;/ol&gt; 自定义列表dl(defintion list)&gt;dt(definition term 自定义列表项)+dd(definition description对自定义 列表项的描述) 12345678&lt;dl&gt; &lt;dt&gt;文具&lt;/dt&gt; &lt;dd&gt;钢笔&lt;/dd&gt; &lt;dd&gt;笔记本&lt;/dd&gt; &lt;dt&gt;蔬菜&lt;/dt&gt; &lt;dd&gt;白菜&lt;/dd&gt; &lt;dd&gt;茄子&lt;/dd&gt; &lt;/dl&gt; 图片标签 img [src 引入图片的路径] [alt] 图片无法加载出来时候呈现的文字 [title] 鼠标悬停时，出现的文字 锚链接、超链接 a [href]跳转的路径、#不跳转或者当前页面的最顶端 [target]跳转的窗口 属性值：_self 默认在当前窗口跳转 _blank 在新窗口跳转 表格​ table&gt;tr行&gt;td单元格 ​ table[border给单元格加上边框] [cell spacing]单元格与单元格之间的距离 [cell padding]单元格的内填充，单元格内容与边框之间的距离 [width] 表格宽度 [height] 表格高度 合并单元格 td[colspan 合并列] ​ td[rowspan] 合并行 表单​ form表单&gt;input表单控件+select下拉框 ​ form: [action 提交到的后台地址] [methhod 提交方式=(get、post)] [name表单名字] input: [type]类型: text 文本框 password密码框 radio单选框 submit 提交按钮 button普通按钮 reset重置按钮 [name] 同一组单选框或者多选框要起一样的没名字. 要提交的表单内容必须要加名字 [checked] 默认选中 [value]给表单添加初始内容 ​ form&gt;select&gt;optiont选项 value[selected默认选中] ​ form&gt;textarea文本域【cols列】[rows行] ​ ​]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML基础</tag>
      </tags>
  </entry>
</search>
